<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>2</id>
  <title>Combined summary - Trustless Watchtowers</title>
  <updated>2023-06-03T20:09:56.690555+00:00</updated>
  <author>
    <name>Conner Fromknecht 2018-11-14 00:28:38</name>
  </author>
  <author>
    <name>ZmnSCPxj 2018-11-12 09:17:36</name>
  </author>
  <author>
    <name>ZmnSCPxj 2018-11-15 08:23:36</name>
  </author>
  <author>
    <name>Conner Fromknecht 2018-11-14 00:12:05</name>
  </author>
  <link href="lightning-dev/Nov_2018/001591_Trustless-Watchtowers.xml" rel="alternate"/>
  <link href="lightning-dev/Nov_2018/001562_Trustless-Watchtowers.xml" rel="alternate"/>
  <link href="lightning-dev/Nov_2018/001608_Trustless-Watchtowers.xml" rel="alternate"/>
  <link href="lightning-dev/Nov_2018/001589_Trustless-Watchtowers.xml" rel="alternate"/>
  <generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator>
  <entry>
    <id>2</id>
    <title>Combined summary - Trustless Watchtowers</title>
    <updated>2023-06-03T20:09:56.690555+00:00</updated>
    <link href="https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-November/001591.html" rel="alternate"/>
    <summary>The email exchange discusses the development of watchtowers for Lightning Network Daemon (lnd) and Decker-Russell-Osuntokun (DRO) channels. While some code related to watchtowers already exists in lnd, it seems to be limited to data structures and messages without actual logic. Laolu suggests that DRO channels can simply "update" the blob side of a txid-blob entry, but this is unsafe unless the watchtower identifies the user somehow as identifying the user could potentially leak their privacy to the watchtower. Conner Fromknecht has been working on a watchtower design where the server side has been implemented and accepts encrypted blobs from clients and stores them. The functionality related to scanning blocks and publishing justice transactions has also been implemented but hasn't been merged yet. One of the main concerns is that if a watchtower is identified by a counterparty, the counterparty could give the commitment transaction's txid with a randomly-generated blob to the watchtower before giving the revocation key to the owner, thus spamming the watchtower until it runs out of resources and crashes. To prevent this, the chosen design uses a two-level bucketing structure that maps client_pubkey1 to encrypted_blob1 and client_pubkey2 to encrypted_blob2, ensuring that different clients can't overwrite each other.Watchtowers need to store all encrypted blobs keyed to the same partial txid. A two-level bucketing structure maps client_pubkey1:encrypted_blob1, client_pubkey2:encrypted_blob2 to ensure different clients can't overwrite each other. The client pubkeys are tied to what's referred to as a session to prevent attacks by paying the tower for multiple sessions tied to different ephemeral session keys. The same session-based, encrypted-blob approach would work eltoo towers as well, with some modifications to breach detection and justice txn construction. However, replacement implies that the watchtower can track channels. In the private tower case, there isn't necessarily payment, though it's more or less assumed that one wouldn't DOS their own tower.ZmnSCPxj notes that watchtowers would need to keep all encrypted blobs that are keyed to the same partial txid in order to avoid possible spam attacks. However, even with this measure in place, an attacker could still spam the watchtower until it runs out of resources and crashes. The watchtower design seems mostly solidified, and there will likely be follow-up posts on the ML. The tower could raise its price point if it detects such behavior and should only ever accept sessions if it can be certain it has the appropriate disk-space to facilitate them, so there isn't much risk in the node crashing due to a spam attack. Finally, the tower can't be sure which client is uploading the "real" blob, so the chosen design uses a two-level bucketing structure that maps client_pubkey1 to encrypted_blob1 and client_pubkey2 to encrypted_blob2.</summary>
    <published>2018-11-14T00:28:38+00:00</published>
  </entry>
</feed>
