<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>2</id>
  <title>Combined summary - Payment channel without timeout protected from malleability</title>
  <updated>2023-06-02T00:06:29.426343+00:00</updated>
  <author>
    <name>Nicolas Dorier 2015-11-27 16:18:21</name>
  </author>
  <author>
    <name>Anthony Towns 2015-11-27 20:11:13</name>
  </author>
  <author>
    <name>Nicolas Dorier 2015-11-27 07:37:04</name>
  </author>
  <author>
    <name>Anthony Towns 2015-11-27 09:09:46</name>
  </author>
  <author>
    <name>Mats Jerratsch 2015-11-27 09:10:13</name>
  </author>
  <author>
    <name>Nicolas Dorier 2015-11-27 21:46:34</name>
  </author>
  <link href="lightning-dev/Nov_2015/000359_Payment-channel-without-timeout-protected-from-malleability.xml" rel="alternate"/>
  <link href="lightning-dev/Nov_2015/000360_Payment-channel-without-timeout-protected-from-malleability.xml" rel="alternate"/>
  <link href="lightning-dev/Nov_2015/000353_Payment-channel-without-timeout-protected-from-malleability.xml" rel="alternate"/>
  <link href="lightning-dev/Nov_2015/000355_Payment-channel-without-timeout-protected-from-malleability.xml" rel="alternate"/>
  <link href="lightning-dev/Nov_2015/000356_Payment-channel-without-timeout-protected-from-malleability.xml" rel="alternate"/>
  <link href="lightning-dev/Nov_2015/000362_Payment-channel-without-timeout-protected-from-malleability.xml" rel="alternate"/>
  <generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator>
  <entry>
    <id>2</id>
    <title>Combined summary - Payment channel without timeout protected from malleability</title>
    <updated>2023-06-02T00:06:29.426343+00:00</updated>
    <link href="https://lists.linuxfoundation.org/pipermail/lightning-dev/2015-November/000359.html" rel="alternate"/>
    <summary>A new method to open a payment channel without being vulnerable to malleability attacks has been proposed by Nicolas Dorier, adapting an idea from gmaxwell. The process involves A asking B for their public key, creating the first commitment transaction, extracting the hash that B needs to sign to be able to broadcast the commitment, asking B to sign the hash and broadcasting the anchor only after confirmation. Neither A nor B can reuse public keys between channels, but this is good practice anyway. Nicolas Dorier and AJ discussed a protocol for channel creation, in which A passes the original unsigned commitment to B, who verifies that it's in the right format and hashes to the hash that he signed. However, if A passes the unsigned commitment to B before the anchor is confirmed in the blockchain, B can malleate the anchor. Both A and B can't reuse pubkeys between different channels with this protocol, but that's good practice anyway.A new method of opening a channel without suffering from a malleability attack has been adapted from an idea by gmaxwell. To initiate the process, A asks B for their pubkey and creates the first commitment transaction. A then extracts the hash that B needs to sign to be able to broadcast the commitment and asks B to sign the hash without disclosing the commitment. Once A broadcasts the anchor and it is confirmed, A announces the anchor to B. B cannot identify A's anchor before announcement because they do not know the P2SH of the multisig. The email thread discusses a way to open a channel without suffering from malleability attack. It is suggested by adapting an idea from gmaxwell, which requires A to ask B pubkey and then create the first commitment transaction. A extracts the hash that B needs to sign to be able to broadcast the commitment and then asks B to sign the hash but does not disclose the commitment. After broadcasting the anchor and confirmation, A announces the anchor to B. However, there are some concerns raised regarding the process.In this conversation, the speakers are discussing a protocol for creating a Bitcoin channel between two parties, A and B. A sends an unsigned commitment to B, who verifies that it's in the right format and hashes to the hash that he signed. However, if A passes the unsigned commitment to B, then B can malleate the anchor, so this step needs to happen after the anchor's confirmed in the blockchain and A's told B about the anchor. They also discuss the issue of pubkeys and redeem hashes being reused between different channels.It appears that using child-pays-for-parent (CPFP) seems plausible as a solution, but it does not work yet. Segregated witness appears to be a more likely solution. The speakers express concerns about random vandalism, but opening the channel as described is a good enough workaround until segregated witness is implemented. They also note that B won't be able to guess the hash, so won't be able to correlate with potential anchor transactions.</summary>
    <published>2015-11-27T16:18:21+00:00</published>
  </entry>
</feed>
