<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>2</id>
  <title>Combined summary - Payment channel without timeout protected from malleability</title>
  <updated>2023-06-03T15:55:22.673879+00:00</updated>
  <author>
    <name>Nicolas Dorier 2015-11-27 07:37:04</name>
  </author>
  <author>
    <name>Anthony Towns 2015-11-27 09:09:46</name>
  </author>
  <author>
    <name>Mats Jerratsch 2015-11-27 09:10:13</name>
  </author>
  <author>
    <name>Nicolas Dorier 2015-11-27 21:46:34</name>
  </author>
  <author>
    <name>Nicolas Dorier 2015-11-27 16:18:21</name>
  </author>
  <author>
    <name>Anthony Towns 2015-11-27 20:11:13</name>
  </author>
  <link href="lightning-dev/Nov_2015/000353_Payment-channel-without-timeout-protected-from-malleability.xml" rel="alternate"/>
  <link href="lightning-dev/Nov_2015/000355_Payment-channel-without-timeout-protected-from-malleability.xml" rel="alternate"/>
  <link href="lightning-dev/Nov_2015/000356_Payment-channel-without-timeout-protected-from-malleability.xml" rel="alternate"/>
  <link href="lightning-dev/Nov_2015/000362_Payment-channel-without-timeout-protected-from-malleability.xml" rel="alternate"/>
  <link href="lightning-dev/Nov_2015/000359_Payment-channel-without-timeout-protected-from-malleability.xml" rel="alternate"/>
  <link href="lightning-dev/Nov_2015/000360_Payment-channel-without-timeout-protected-from-malleability.xml" rel="alternate"/>
  <generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator>
  <entry>
    <id>2</id>
    <title>Combined summary - Payment channel without timeout protected from malleability</title>
    <updated>2023-06-03T15:55:22.673879+00:00</updated>
    <link href="https://lists.linuxfoundation.org/pipermail/lightning-dev/2015-November/000353.html" rel="alternate"/>
    <summary>Nicolas Dorier has adapted an idea from gmaxwell to propose a method for opening a payment channel without being vulnerable to malleability attacks. The process involves A asking B for their public key, creating the first commitment transaction, extracting the hash that B needs to sign to be able to broadcast the commitment, asking B to sign the hash and broadcasting the anchor only after confirmation. Neither A nor B can reuse public keys between channels, but that's good practice anyway. If A reuses a key, then B can guess the redeem hash and identify the transaction to malleate at broadcast time, before A's announcement. However, B won't be able to correlate with potential anchor transactions at all. The speakers in the conversation express concerns about random vandalism, but opening the channel as described is a good enough workaround until segregated witness is implemented. They also note that B won't be able to guess the hash, so won't be able to correlate with potential anchor transactions. Although child-pays-for-parent seems plausible, it does not work yet and segregated witness is expected to happen sooner. It is suggested to use segregated witness to fix the problem cleanly.Additionally, there are some concerns raised regarding the process. Firstly, 'without timeout' is only possible with OP_CSV - not naturally with what we have currently. Secondly, to build a valid payment channel on top of the anchor, B has to be sure that A cannot get her money back at any point in the future. Lastly, while this is a fair setup already, it does only protect against targeted attacks against a specific transaction, leaving a chance for someone to lose money doing that.</summary>
    <published>2015-11-27T07:37:04+00:00</published>
  </entry>
</feed>
