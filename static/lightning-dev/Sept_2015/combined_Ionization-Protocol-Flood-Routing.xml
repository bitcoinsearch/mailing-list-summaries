<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>2</id>
  <title>Combined summary - Ionization Protocol: Flood Routing</title>
  <updated>2023-06-03T15:33:22.455434+00:00</updated>
  <author>
    <name>Amos Bairn 2015-09-19 20:13:03</name>
  </author>
  <author>
    <name>Rusty Russell 2015-09-21 02:16:13</name>
  </author>
  <author>
    <name>Anthony Towns 2015-09-21 11:08:44</name>
  </author>
  <author>
    <name>Rusty Russell 2015-09-23 02:42:57</name>
  </author>
  <author>
    <name>Mats Jerratsch 2015-09-23 07:56:08</name>
  </author>
  <author>
    <name>Pieter Wuille 2015-09-25 03:38:59</name>
  </author>
  <author>
    <name>Anthony Towns 2015-09-21 07:12:42</name>
  </author>
  <author>
    <name>Mats Jerratsch 2015-09-21 14:06:32</name>
  </author>
  <author>
    <name>Amos Bairn 2015-09-23 04:28:06</name>
  </author>
  <author>
    <name>Rusty Russell 2015-09-23 04:59:00</name>
  </author>
  <author>
    <name>Rusty Russell 2015-09-25 00:26:02</name>
  </author>
  <author>
    <name>Anthony Towns 2015-09-25 05:54:06</name>
  </author>
  <author>
    <name>Anthony Towns 2015-09-25 10:11:40</name>
  </author>
  <author>
    <name>Rusty Russell 2015-09-27 04:24:45</name>
  </author>
  <author>
    <name>Rusty Russell 2015-09-27 05:42:56</name>
  </author>
  <author>
    <name>Rusty Russell 2015-09-27 05:26:29</name>
  </author>
  <author>
    <name>Anthony Towns 2015-09-28 10:37:19</name>
  </author>
  <author>
    <name>Anthony Towns 2015-09-28 11:12:56</name>
  </author>
  <author>
    <name>Rusty Russell 2015-09-30 05:12:54</name>
  </author>
  <author>
    <name>Anthony Towns 2015-09-23 05:42:40</name>
  </author>
  <author>
    <name>Rusty Russell 2015-09-24 20:56:55</name>
  </author>
  <author>
    <name>Rusty Russell 2015-09-25 01:53:42</name>
  </author>
  <author>
    <name>Anthony Towns 2015-09-25 05:08:36</name>
  </author>
  <link href="lightning-dev/Sept_2015/000197_Ionization-Protocol-Flood-Routing.xml" rel="alternate"/>
  <link href="lightning-dev/Sept_2015/000199_Ionization-Protocol-Flood-Routing.xml" rel="alternate"/>
  <link href="lightning-dev/Sept_2015/000201_Ionization-Protocol-Flood-Routing.xml" rel="alternate"/>
  <link href="lightning-dev/Sept_2015/000211_Ionization-Protocol-Flood-Routing.xml" rel="alternate"/>
  <link href="lightning-dev/Sept_2015/000217_Ionization-Protocol-Flood-Routing.xml" rel="alternate"/>
  <link href="lightning-dev/Sept_2015/000236_Ionization-Protocol-Flood-Routing.xml" rel="alternate"/>
  <link href="lightning-dev/Sept_2015/000200_Ionization-Protocol-Flood-Routing.xml" rel="alternate"/>
  <link href="lightning-dev/Sept_2015/000202_Ionization-Protocol-Flood-Routing.xml" rel="alternate"/>
  <link href="lightning-dev/Sept_2015/000212_Ionization-Protocol-Flood-Routing.xml" rel="alternate"/>
  <link href="lightning-dev/Sept_2015/000215_Ionization-Protocol-Flood-Routing.xml" rel="alternate"/>
  <link href="lightning-dev/Sept_2015/000230_Ionization-Protocol-Flood-Routing.xml" rel="alternate"/>
  <link href="lightning-dev/Sept_2015/000234_Ionization-Protocol-Flood-Routing.xml" rel="alternate"/>
  <link href="lightning-dev/Sept_2015/000235_Ionization-Protocol-Flood-Routing.xml" rel="alternate"/>
  <link href="lightning-dev/Sept_2015/000237_Ionization-Protocol-Flood-Routing.xml" rel="alternate"/>
  <link href="lightning-dev/Sept_2015/000238_Ionization-Protocol-Flood-Routing.xml" rel="alternate"/>
  <link href="lightning-dev/Sept_2015/000239_Ionization-Protocol-Flood-Routing.xml" rel="alternate"/>
  <link href="lightning-dev/Sept_2015/000240_Ionization-Protocol-Flood-Routing.xml" rel="alternate"/>
  <link href="lightning-dev/Sept_2015/000241_Ionization-Protocol-Flood-Routing.xml" rel="alternate"/>
  <link href="lightning-dev/Sept_2015/000246_Ionization-Protocol-Flood-Routing.xml" rel="alternate"/>
  <link href="lightning-dev/Sept_2015/000216_Ionization-Protocol-Flood-Routing.xml" rel="alternate"/>
  <link href="lightning-dev/Sept_2015/000227_Ionization-Protocol-Flood-Routing.xml" rel="alternate"/>
  <link href="lightning-dev/Sept_2015/000231_Ionization-Protocol-Flood-Routing.xml" rel="alternate"/>
  <link href="lightning-dev/Sept_2015/000233_Ionization-Protocol-Flood-Routing.xml" rel="alternate"/>
  <generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator>
  <entry>
    <id>2</id>
    <title>Combined summary - Ionization Protocol: Flood Routing</title>
    <updated>2023-06-03T15:33:22.455434+00:00</updated>
    <link href="https://lists.linuxfoundation.org/pipermail/lightning-dev/2015-September/000197.html" rel="alternate"/>
    <summary>The Lightning Network is a protocol layer built on top of Bitcoin that aims to solve scalability issues and allow for instant, high-volume micropayments. The conversation between Rusty Russell and Mats Jerratsch involves various topics including the use of beacon nodes for transactions, the number of beacons required, and the efficiency of using beacon nodes. There is also a discussion about DDoS attacks, centralization with reputation systems, and the need for a priority mechanism for information packages.The proposed flood-based route finding scheme could allow efficient routing while keeping the network shape hidden and providing anonymity. However, there is a trivial denial-of-service attack that needs to be solved. Additionally, the possibility of squeezing more bytes out of the signature and pubkey is discussed. Rusty Russell and Pieter suggest using the EC-Schnorr scheme in libsecp256k1 instead of ECDSA, which produces 64-byte non-malleable signatures that support pubkey recovery without an additional recovery id. The email conversation between Rusty Russell and Mats Jerratsch discusses the technical aspects of designing a payment channel network and developing a Lightning Network node. They exchange apologies for the inconvenience caused by opening a new thread and discuss various topics such as the use of IRC channels for node discovery, adding a reputation or web-of-trust system, and the issues related to anchor transactions in the blockchain as a map of the network. They also talk about the challenges of running a full node on a phone and suggest using hosted wallets or relying on the network to work out a cheap route.The discussion revolves around the implementation of a beacon network in Bitcoin's Lightning Network. Anthony Towns suggests using n*k beacons at any point in time, with the oldest k replaced every d days. The group discusses ideas to scale and modify parameters as the network grows, including scaling n with log2(number nodes) and utilizing DHTs for routes/fees. In terms of route prices, two cheapest beacons and three beacons from cohorts 3-n with recent currency and long term visibility would work okay. Moreover, the context discusses the feasibility of using a phone as a replacement for cash and credit cards for everyday transactions. However, it is acknowledged that certain things cannot go offline, such as IoT devices doing micropayments ($1-$10), routers/cloud computers paying for their internet ($10-$100), merchants doing reasonable volume ($1000-$5000) and nodes operating as revenue-generating investments ($1000-$100,000). The privacy concerns regarding the use of Lightning primarily as a wallet versus trying to be a profit-generating node are also discussed. The Lightning Network uses a routing protocol to update fees. The updates occur through the dijkstra-routing-gossip protocol, and the traffic generated is proportional to the number of channels, nodes, and channel fee updates per day. Payment information has to be provided by the payee shortly before the transaction to ensure that the route and fee information is up-to-date. The network will establish channels with new beacons, and beacons may want to bring offline funds online to handle the anticipated capacity.In a discussion about the network using the same set of beacons, Amos Bairn suggests that this may cause nodes to become overloaded. As a solution, each user should choose their own set of beacons randomly, but with enough overlap between users so that nodes can share the load evenly. The challenge with using random beacons is propagating current fee information across the network.Finally, in an email thread from September 2015, Rusty Russell and Mats Jerratsch discuss the number of beacons needed to support all transactions. They discuss that keeping old beacons does not help unless the payee uses them to advertise a route. Old beacons do not get their fee updates propagated and aren't known by people who just joined the network. Russell suggests establishing channels with five random nodes and using Barabasi-Albert graphs to select nodes based on how connected they already are.</summary>
    <published>2015-09-19T20:13:03+00:00</published>
  </entry>
</feed>
