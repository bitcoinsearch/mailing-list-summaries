<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>2</id>
  <title>Combined summary - [BOLT RFC#1] Encryption spec</title>
  <updated>2023-06-02T00:24:59.054850+00:00</updated>
  <author>
    <name>CJP 2016-06-26 11:53:11</name>
  </author>
  <author>
    <name>Peter Todd 2016-06-26 22:27:20</name>
  </author>
  <author>
    <name>Rusty Russell 2016-06-28 02:43:09</name>
  </author>
  <author>
    <name>Rusty Russell 2016-03-07 03:51:02</name>
  </author>
  <author>
    <name>Anthony Towns 2016-03-18 06:03:17</name>
  </author>
  <author>
    <name>Rusty Russell 2016-06-28 01:41:05</name>
  </author>
  <author>
    <name>Rusty Russell 2016-03-21 00:07:00</name>
  </author>
  <link href="lightning-dev/June_2016/000547_-BOLT-RFC-1-Encryption-spec.xml" rel="alternate"/>
  <link href="lightning-dev/June_2016/000548_-BOLT-RFC-1-Encryption-spec.xml" rel="alternate"/>
  <link href="lightning-dev/June_2016/000550_-BOLT-RFC-1-Encryption-spec.xml" rel="alternate"/>
  <link href="lightning-dev/March_2016/000456_-BOLT-RFC-1-Encryption-spec.xml" rel="alternate"/>
  <link href="lightning-dev/March_2016/000494_-BOLT-RFC-1-Encryption-spec.xml" rel="alternate"/>
  <link href="lightning-dev/June_2016/000549_-BOLT-RFC-1-Encryption-spec.xml" rel="alternate"/>
  <link href="lightning-dev/March_2016/000496_-BOLT-RFC-1-Encryption-spec.xml" rel="alternate"/>
  <generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator>
  <entry>
    <id>2</id>
    <title>Combined summary - [BOLT RFC#1] Encryption spec</title>
    <updated>2023-06-02T00:24:59.054850+00:00</updated>
    <link href="https://lists.linuxfoundation.org/pipermail/lightning-dev/2016-June/000547.html" rel="alternate"/>
    <summary>The Chief Justice of Pakistan (CJP) is working on implementing an encryption layer for Amiko Pay and has questions about the BOLT for encryption. One question is whether a node can use different public keys for different links, which could be good for privacy but may not solve the deniability problem. The CJP wonders about the degree to which communication truly looks like random data or can be distinguished from it and how to protect against timing analysis that could reveal the size of messages being sent. The authenticate message is distinguished from other messages as it is always the first message in a session. The Basis of Lightning Technology RFC 1 draft describes the encryption and authentication of communications between lightning nodes. The protocol uses Authenticated Encryption with Additional Data using ChaCha20-Poly1305, and nonces are used to encrypt packet headers and bodies. To authenticate peer identity, the first packet sent must be an authentication packet containing three required fields: bitcoin_pubkey node_id, signature session_sig, and a signature of the SHA256 of SHA256 of the receiver's node_id using the secret key corresponding to the sender's node_id.Rusty Russell of Blockstream authored the initial draft, and feedback is welcomed on the lightning-dev list. References include Secp256k1, RFC7539, and the libsodium documentation. In an email conversation with Peter Todd, CJP shares information regarding the work being done by Jonas Schnelli for Bitcoin on P at P layer encryption. Schnelli is using a subset of the encryption scheme OpenSSH uses, which allows him to benefit from all the review that has been done for OpenSSH. Using this encryption scheme, one can benefit from both the review that has been done for OpenSSH as well as the review from the Bitcoin Core team.In a discussion about the derivation of the shared secret and encryption keys, Anthony Towns suggests expanding on the sessionsecretkey calculation. The current implementation is different from NIST specifications, which only uses the x coordinate of the point directly and does not hash it. Reusing the secp256k1 elliptic curve already used in the bitcoin protocol avoids additional dependencies, but raises concerns about backwards compatibility if it breaks or gets deprecated. To handle upgrades, a second key can be added and the length field increased to cover it. If both sides send &gt;= 66 bytes, the second value will be used instead.</summary>
    <published>2016-06-26T11:53:11+00:00</published>
  </entry>
</feed>
