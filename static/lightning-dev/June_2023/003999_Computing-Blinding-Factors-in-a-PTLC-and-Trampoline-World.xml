<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>0</id>
  <title>Computing Blinding Factors in a PTLC and Trampoline World</title>
  <updated>2023-07-04T03:08:55.241010+00:00</updated>
  <author>
    <name>ZmnSCPxj 2023-06-28 20:34:37+00:00</name>
  </author>
  <generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator>
  <entry>
    <id>0</id>
    <title>Computing Blinding Factors in a PTLC and Trampoline World</title>
    <updated>2023-07-04T03:08:55.241033+00:00</updated>
    <link href="https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-June/003999.html" rel="alternate"/>
    <summary>In this message, ZmnSCPxj provides a mathematical demonstration of a method for computing blinding factors in a way that satisfies certain conditions. The purpose of this method is to allow for secure and private transactions in a network.The demonstration starts with the assumption that there is an ultimate receiver who has a secret value 'r'. The ultimate receiver shares a point 'R' with the ultimate sender, where R = r * G (G being a predetermined constant).In the simplest case where the ultimate sender is directly connected to the ultimate receiver, the ultimate sender selects a random scalar 'e' as the error blinding factor. It constructs an onion with 'e' encrypted for the ultimate receiver and offers a PTLC (Payment-Point Time-Locked Contract) with the point 'e * G + R'. The ultimate receiver can claim the PTLC by revealing 'e + r', as it knows 'e' from the onion and the contract requires 'r' for payment.If there is an intermediate node, Carol, between the ultimate sender and receiver, the ultimate sender still chooses a random scalar 'e'. However, it also generates two scalars 'c' and 'd' such that 'c + d = e'. The ultimate sender encrypts 'e' for the ultimate receiver and 'd' for Carol. The PTLC sent to Carol includes the point 'c * G + R'. Carol adds the received point with 'd * G' and sends a PTLC with the point 'c * G + R + d * G' to the next hop. This allows each intermediate non-Trampoline node to add its per-hop blinding factor to the input point and send it to the next hop.It's important to note that the PTLC received by Carol, '(c + d) * G + R', is equal to 'e * G + R' received in the direct case. The ultimate receiver cannot differentiate whether it received the PTLC from Carol, a further node, or directly, as both cases result in the point 'e * G + R'.When the ultimate receiver releases 'e + r', Carol can compute 'c + r' by taking 'e + r - d'. Carol can claim the incoming PTLC with scalar 'c + r', but it cannot compute 'r' because it only knows 'd' and not 'c'.Next, the scenario is explored where Carol is a Trampoline node, and the ultimate sender doesn't provide a detailed route from Carol to the next Trampoline hop. In this case, the ultimate sender learns 'R' and selects a random 'e'. It also selects 'c' and 'd' such that 'c + d = e'. The ultimate sender creates a Trampoline-level onion with 'e' encrypted for the ultimate receiver, 'd' encrypted for Carol, and the next Trampoline hop encrypted for Carol.Carol decrypts the onion and gets 'd'. It then searches for a route from itself to the ultimate receiver. If Carol finds a route (let's say Carol -&gt; Alice -&gt; ultimate receiver), it needs to make 'c * G + d * G + R' reach the ultimate receiver. Carol achieves this by selecting two scalars, 'a' and 'b', such that 'a + b = d'. Carol creates an onion with 'b' encrypted for Alice and sends the PTLC with the point 'c * G + R + a * G' to Alice. Alice decrypts the onion and learns 'b'. She forwards the PTLC with the point 'c * G + R + a * G + b * G' to the next hop, the ultimate receiver.Again, it can be observed that '(c + d) * G + R' received by the ultimate receiver is equal to 'e * G + R'. The ultimate receiver cannot differentiate whether it was reached via a Trampoline, a non-Trampoline intermediate, or directly.In conclusion, this demonstration shows a method for computing blinding factors that allows for secure and private transactions in a network. It ensures that non-Trampoline nodes only need to know one blinding factor, the receiver only needs to know one blinding factor, and Trampoline nodes can provide blinding factors without revealing their presence as a Trampoline node.</summary>
    <published>2023-06-28T20:34:37+00:00</published>
  </entry>
</feed>
