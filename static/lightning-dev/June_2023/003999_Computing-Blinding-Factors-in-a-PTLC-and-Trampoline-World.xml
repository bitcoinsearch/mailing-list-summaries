<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>0</id>
  <title>Computing Blinding Factors in a PTLC and Trampoline World</title>
  <updated>2023-07-01T03:26:00.729876+00:00</updated>
  <author>
    <name>ZmnSCPxj 2023-06-28 20:34:37+00:00</name>
  </author>
  <generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator>
  <entry>
    <id>0</id>
    <title>Computing Blinding Factors in a PTLC and Trampoline World</title>
    <updated>2023-07-01T03:26:00.729906+00:00</updated>
    <link href="https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-June/003999.html" rel="alternate"/>
    <summary>In this message, ZmnSCPxj explains a mathematical demonstration for computing blinding factors in a specific way. The goal is to ensure that non-Trampoline intermediate nodes only need one blinding factor, the receiver only needs one blinding factor, and Trampoline nodes can provide blinding factors without revealing their presence.The demonstration starts by assuming that the ultimate receiver has a secret 'r' and gives the ultimate sender the point 'R', which is equal to 'r * G'. In the simplest case where there are no intermediate nodes, the ultimate sender chooses a random scalar 'e' as the error blinding factor. It constructs an onion with 'e' encrypted for the ultimate receiver and offers a PTLC with the point 'e * G + R'. The ultimate receiver can claim the PTLC by revealing 'e + r'.Next, the scenario is expanded to include an intermediate node named Carol. In this case, the ultimate sender still chooses a random scalar 'e', but it also generates two scalars 'c' and 'd' such that 'c + d = e'. The ultimate sender encrypts 'e' for the ultimate receiver and encrypts 'd' for Carol. The PTLC sent to Carol is 'c * G + R'. Carol adds 'd * G' to the point it received and sends a PTLC with the point 'c * G + R + d * G' to the next hop. This process ensures that the ultimate receiver cannot distinguish whether it received from Carol or a further node.Now, let's consider the case where Carol is a Trampoline node and the ultimate sender does not provide a detailed route from Carol to the next Trampoline hop. The ultimate sender selects 'e', 'c', and 'd' using the same technique as before. It then creates a Trampoline-level onion with 'e' encrypted for the ultimate receiver and 'd' and the next Trampoline hop encrypted for Carol. The PTLC sent to Carol is 'c * G + R'. Carol decrypts the onion and gets 'd'. It then looks for a route from Carol to the ultimate receiver and selects scalars 'a' and 'b' such that 'a + b = d'. Carol creates a new onion with 'b' encrypted for Alice, and the PTLC sent to Alice is 'c * G + R + a * G'. Alice decrypts the onion and learns 'b', then forwards the PTLC to the next hop, the ultimate receiver.By carefully constructing the onions and blinding factors, it is ensured that the ultimate receiver always receives 'e * G + R' regardless of whether it came through a Trampoline or non-Trampoline intermediate node, or even directly. Each intermediate node has enough information to claim its incoming PTLC, but only the ultimate sender knows 'c', allowing it to recover 'r'.Overall, this demonstration shows a way to compute blinding factors while preserving the privacy and anonymity of the transaction route.</summary>
    <published>2023-06-28T20:34:37+00:00</published>
  </entry>
</feed>
