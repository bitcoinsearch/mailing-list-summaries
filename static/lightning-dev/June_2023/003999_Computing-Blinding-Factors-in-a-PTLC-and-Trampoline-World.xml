<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>0</id>
  <title>Computing Blinding Factors in a PTLC and Trampoline World</title>
  <updated>2023-07-08T02:53:55.347321+00:00</updated>
  <author>
    <name>ZmnSCPxj 2023-06-28 20:34:37+00:00</name>
  </author>
  <generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator>
  <entry>
    <id>0</id>
    <title>Computing Blinding Factors in a PTLC and Trampoline World</title>
    <updated>2023-07-08T02:53:55.347345+00:00</updated>
    <link href="https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-June/003999.html" rel="alternate"/>
    <summary>In this mathematical demonstration, the author explains a method to compute blinding factors in a way that ensures certain conditions are met. These conditions include the need for non-Trampoline intermediate nodes to only know one blinding factor, the receiver only needing to know one blinding factor, and Trampoline nodes being able to provide blinding factors without revealing their role as a Trampoline.The demonstration begins with the ultimate receiver having a secret value 'r' and providing the point 'R' to the ultimate sender, where R = r * G (G being a base point). In the simplest case, if the ultimate sender is directly connected to the ultimate receiver, it chooses a random scalar 'e' as the error blinding factor and constructs an onion with 'e' decryptable by the receiver. The ultimate sender also offers a Payment-Point Time-Locked Contract (PTLC) with the point e * G + R. The receiver can claim this PTLC by revealing e + r, as it learns e from the onion and knows r.Next, the scenario is expanded to include an intermediate node called Carol. The ultimate sender still chooses a final error scalar 'e', but now it needs to generate two scalars, 'c' and 'd', such that c + d = e. This is achieved by selecting a random 'd' and computing c = e - d. The ultimate sender encrypts the onion with e encrypted to the receiver and the ciphertext, along with d, encrypted to Carol. The ultimate sender sends the PTLC with the point c * G + R to Carol.At each intermediate non-Trampoline node, such as Carol, the input point (c * G + R) is added with its per-hop blinding factor times G and this result becomes the output point to the next hop. Carol receives c * G + R, adds d * G (the error received from the onion), and sends a PTLC with the point c * G + R + d * G. It is important to note that e = c + d, so the PTLC sent by Carol can be rearranged as (c + d) * G + R, which is equal to e * G + R.In the case where Carol is a Trampoline node, the ultimate sender does not provide a detailed route from Carol to the next Trampoline hop. The ultimate sender learns R and selects a random e. It also selects c and d such that c + d = e, using the same technique as before. The ultimate sender then computes a Trampoline-level onion with e encrypted to the receiver and the above ciphertext, d, and the next Trampoline hop encrypted to Carol. The PTLC with the onion and point c * G + R is sent to Carol.Carol decrypts the onion and obtains d. It then searches for a route from Carol to the ultimate receiver (the next Trampoline hop). Let's assume the route is Carol -&gt; Alice -&gt; ultimate receiver. Carol needs to make c * G + d * G + R reach the ultimate receiver. To achieve this, Carol selects scalars a and b such that a + b = d. It creates an onion with the copied ciphertext from the ultimate sender, along with b, encrypted to Alice. The PTLC with the point c * G + R + a * G is sent to Alice.Alice decrypts the onion and learns b. She then forwards the PTLC with the point c * G + R + a * G + b * G to the next hop, the ultimate receiver. By construction, a + b = d, so a * G + b * G = d * G. Also, c + d = e, so c * G + d * G = e * G. Therefore, the ultimate receiver receives the same e * G + R, regardless of whether it was reached via a Trampoline, a non-Trampoline intermediate node, or directly.On claiming the PTLC, every intermediate node has enough data to claim its incoming PTLC. Only the ultimate sender knows c, which allows it to recover r.Overall, this demonstration provides a mathematical explanation of how blinding factors can be computed to meet specific requirements in a routing scenario involving Trampoline and non-Trampoline nodes.</summary>
    <published>2023-06-28T20:34:37+00:00</published>
  </entry>
</feed>
