<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>0</id>
  <title>Computing Blinding Factors in a PTLC and Trampoline World</title>
  <updated>2023-07-07T02:58:55.061635+00:00</updated>
  <author>
    <name>ZmnSCPxj 2023-06-28 20:34:37+00:00</name>
  </author>
  <generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator>
  <entry>
    <id>0</id>
    <title>Computing Blinding Factors in a PTLC and Trampoline World</title>
    <updated>2023-07-07T02:58:55.061664+00:00</updated>
    <link href="https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-June/003999.html" rel="alternate"/>
    <summary>In this message, ZmnSCPxj provides a mathematical demonstration of a method for computing blinding factors in a way that allows for increased privacy and flexibility in routing payments in a network. The goal is to ensure that non-Trampoline intermediate nodes only need to know one blinding factor, the receiver only needs to know one blinding factor, and Trampoline nodes can provide sub-routes without revealing their role.The demonstration starts with the ultimate receiver having a secret value 'r' and providing the ultimate sender with a point 'R' (computed as R = r * G), where G is a generator point on the elliptic curve.In the simplest case where there are no intermediate nodes, the ultimate sender chooses a random scalar 'e', known as the error blinding factor, and constructs an onion with e decryptable by the ultimate receiver. The ultimate sender also offers a Payment-Time Lock Contract (PTLC) with the point e * G + R. The ultimate receiver can claim this PTLC by revealing e + r.When an intermediate node, named Carol, is introduced, the ultimate sender still chooses a random scalar 'e' but also needs to generate two scalars, 'c' and 'd', such that c + d = e. This is done by randomly selecting 'd' and computing c = e - d. The ultimate sender then encrypts the onion with e encrypted to the ultimate receiver and the ciphertext along with 'd' encrypted to Carol. The PTLC sent by the ultimate sender to Carol has the point c * G + R.Each intermediate non-Trampoline node adds its per-hop blinding factor times G to the input point received and uses the result as the output point to the next hop. In this case, Carol receives c * G + R, adds d * G (the d error from the onion), and sends a PTLC with the point c * G + R + d * G.Since e = c + d, the PTLC sent by Carol to the ultimate sender can be rearranged as (c + d) * G + R, which is equal to e * G + R. Therefore, the ultimate receiver cannot differentiate whether it received from Carol or a further node because both cases yield e * G + R.When the ultimate receiver releases e + r, Carol can compute c + r by taking e + r - d. Since c = e - d, e + r - d = e - d + r = c + r. Carol can then claim the incoming c * G + R with scalar c + r. However, Carol does not know c, only d, and thus cannot compute r.In the case where Carol is a Trampoline node and the ultimate sender does not provide a detailed route from Carol to the next Trampoline hop, the ultimate sender still learns R and selects a random e. It also selects c and d such that c + d = e. The ultimate sender then computes a Trampoline-level onion with e encrypted to the ultimate receiver and the ciphertext along with d and the next Trampoline hop encrypted to Carol. The PTLC sent by the ultimate sender to Carol has the point c * G + R.Carol decrypts the onion and obtains d. Carol then searches for a route from itself to the ultimate receiver, the next Trampoline hop. Suppose Carol finds a route Carol -&gt; Alice -&gt; ultimate receiver. Carol needs to make c * G + d * G + R reach the ultimate receiver. To achieve this, Carol selects two scalars, a and b, such that a + b = d. Carol creates an onion with the above ciphertext copied from the ultimate sender, along with b encrypted to Alice. Carol sends the PTLC with the point c * G + R + a * G to Alice.Alice decrypts the onion and learns b. Alice forwards the PTLC with the point c * G + R + a * G + b * G to the next hop, the ultimate receiver.Since a + b = d, a * G + b * G = d * G. Also, c + d = e, so c * G + d * G = e * G. Therefore, the ultimate receiver receives the same e * G + R and cannot differentiate whether it was reached via a Trampoline, a non-Trampoline intermediate, or directly.On claiming, every intermediate node has enough data to claim its incoming PTLC, and only the ultimate sender knows c, allowing it to recover r.Overall, this demonstration shows a method for computing blinding factors that provides increased privacy and flexibility in routing payments through a network of nodes.</summary>
    <published>2023-06-28T20:34:37+00:00</published>
  </entry>
</feed>
