<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>0</id>
  <title>Computing Blinding Factors in a PTLC and Trampoline World</title>
  <updated>2023-07-03T03:17:23.012966+00:00</updated>
  <author>
    <name>ZmnSCPxj 2023-06-28 20:34:37+00:00</name>
  </author>
  <generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator>
  <entry>
    <id>0</id>
    <title>Computing Blinding Factors in a PTLC and Trampoline World</title>
    <updated>2023-07-03T03:17:23.012990+00:00</updated>
    <link href="https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-June/003999.html" rel="alternate"/>
    <summary>In this message, the author provides a mathematical demonstration of a method for computing blinding factors in a specific way. The aim is to ensure that only one blinding factor is needed by all non-Trampoline intermediate nodes and the receiver. Additionally, Trampoline nodes are able to provide blinding factors to the nodes on the sub-routes without revealing their true nature.The demonstration starts with an ultimate receiver having a secret value, denoted as 'r'. The receiver gives the ultimate sender a point 'R', which is equal to 'r' multiplied by the generator point 'G'.In the simplest case, where there are no intermediate nodes, the ultimate sender chooses a random scalar 'e' as the error blinding factor. It constructs an onion with 'e' encrypted for the ultimate receiver, and offers a PTLC (Point-Time Lock Contract) with the point 'e * G + R'. The ultimate receiver can claim this PTLC by revealing 'e + r', as it learns 'e' from the onion and knows 'r'. Next, the author introduces the scenario where the ultimate receiver needs to go through an intermediate node named Carol. In this case, the ultimate sender still chooses a random scalar 'e' as the final error factor. However, it also generates two scalars 'c' and 'd' such that 'c + d = e'. This is done by selecting a random 'd' and computing 'c = e - d'. The ultimate sender encrypts the onion with 'e' for the ultimate receiver, and with 'd' for Carol. The PTLC sent to Carol is 'c * G + R'.For each intermediate non-Trampoline node, like Carol, it adds its per-hop blinding factor times 'G' to the input point and uses the result as the output point to the next hop. In the case of Carol, it receives 'c * G + R', adds 'd * G' (the 'd' error it got from the onion), and sends a PTLC with the point 'c * G + R + d * G'.Since 'e = c + d', the PTLC sent by Carol to the ultimate sender can be rearranged as '(c + d) * G + R', which is equal to 'e * G + R'. Hence, the ultimate receiver cannot determine whether it received from Carol or a further node, as both scenarios result in 'e * G + R'.When the ultimate receiver releases 'e + r', Carol can compute 'c + r' by taking 'e + r - d'. Since 'c = e - d', 'e + r - d = e - d + r = c + r'. Carol can then claim the incoming 'c * G + R' with scalar 'c + r'. However, Carol does not know 'c'; it only knows 'd', so it cannot compute 'r'.The author then presents another scenario where Carol is a Trampoline node and the ultimate sender does not provide a detailed route from Carol to the next Trampoline hop. In this case, the ultimate sender learns 'R', selects a random 'e', and chooses 'c' and 'd' such that 'c + d = e'. It encrypts 'e' for the ultimate receiver and 'd' along with the next Trampoline hop (ultimate receiver's node ID) for Carol. The PTLC sent to Carol is 'c * G + R'.Carol decrypts the onion and obtains 'd'. It then searches for a route from Carol to the ultimate receiver. Assuming it finds a route Carol -&gt; Alice -&gt; ultimate receiver, Carol needs to make 'c * G + d * G + R' reach the ultimate receiver. It does this by selecting scalars 'a' and 'b' such that 'a + b = d'. Carol creates an onion with 'b' encrypted for Alice, along with the existing ciphertext from the ultimate sender. The PTLC sent to Alice is 'c * G + R + a * G'.Alice decrypts the onion and learns 'b'. She forwards the PTLC with point 'c * G + R + a * G + b * G' to the next hop, the ultimate receiver. It can be shown that 'a * G + b * G = d * G' and 'c * G + d * G = e * G'. Therefore, the ultimate receiver still receives 'e * G + R' and cannot differentiate whether it was reached via a Trampoline, a non-Trampoline intermediate, or directly.In terms of claiming, every intermediate node has enough information to claim its incoming PTLC, and only the ultimate sender knows 'c', allowing it to recover 'r'.</summary>
    <published>2023-06-28T20:34:37+00:00</published>
  </entry>
</feed>
