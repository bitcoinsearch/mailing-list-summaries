<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>0</id>
  <title>Computing Blinding Factors in a PTLC and Trampoline World</title>
  <updated>2023-07-05T02:58:41.365189+00:00</updated>
  <author>
    <name>ZmnSCPxj 2023-06-28 20:34:37+00:00</name>
  </author>
  <generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator>
  <entry>
    <id>0</id>
    <title>Computing Blinding Factors in a PTLC and Trampoline World</title>
    <updated>2023-07-05T02:58:41.365219+00:00</updated>
    <link href="https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-June/003999.html" rel="alternate"/>
    <summary>In this email, the author presents a mathematical demonstration of a method to compute blinding factors in a particular way. The goal is to satisfy certain conditions: all non-Trampoline intermediate nodes should only need to know one blinding factor, the receiver should also only need to know one blinding factor, and Trampoline nodes should be able to provide the blinding factors for sub-routes without the non-Trampoline intermediate nodes knowing they are on a trampoline. The demonstration begins with the ultimate receiver having a secret `r` and giving the ultimate sender the point `R = r * G`, where `G` is a base point. In the simplest case where there is a direct channel between the ultimate sender and receiver, the ultimate sender chooses a fresh random scalar `e` as an "error" blinding factor. It constructs an onion with `e` encryptable by the ultimate receiver and offers a PTLC (Point-Time Lock Contract) with the point `e * G + R`. The ultimate receiver can claim the PTLC by revealing `e + r`.In the case where there is an intermediate node, Carol, the ultimate sender still chooses a final error scalar `e` randomly. Additionally, it generates two scalars `c` and `d` such that `c + d = e`. The onion is then encrypted with `e` for the ultimate receiver and with `d` for Carol. The PTLC sent to Carol is `c * G + R`. Each intermediate non-Trampoline node adds its per-hop blinding factor times `G` to the input point and uses the result as the output point to the next hop. Carol receives `c * G + R`, adds `d * G`, and sends a PTLC with the point `c * G + R + d * G`. The ultimate receiver cannot differentiate whether it received from Carol or a further node since it sees `e * G + R`. In the case where Carol is a Trampoline node and does not know that the ultimate receiver is the final Trampoline hop, the ultimate sender learns `R`, selects a random `e`, and generates `c` and `d` such that `c + d = e`. It then computes a Trampoline-level onion with `e` encrypted to the ultimate receiver and with `d` and the next Trampoline hop encrypted to Carol. The PTLC sent to Carol is `c * G + R`. Carol decrypts the onion, gets `d`, and searches for a route from Carol to the ultimate receiver. Suppose Carol finds a route Carol -&gt; Alice -&gt; ultimate receiver. Carol creates an onion with the ciphertext from the ultimate sender, `b` encrypted to Alice, and sends a PTLC with point `c * G + R + a * G` to Alice. Alice decrypts the onion and learns `b`, then forwards the PTLC with point `c * G + R + a * G + b * G` to the next hop, the ultimate receiver. The ultimate receiver still receives `e * G + R` and cannot differentiate how it was reached. In both cases, each intermediate node has enough data to claim its incoming PTLC, and only the ultimate sender knows `c`, allowing it to recover `r`. This method allows for efficient computation of blinding factors while preserving privacy and flexibility in routing.</summary>
    <published>2023-06-28T20:34:37+00:00</published>
  </entry>
</feed>
