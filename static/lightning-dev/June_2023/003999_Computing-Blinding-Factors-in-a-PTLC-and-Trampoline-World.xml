<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>0</id>
  <title>Computing Blinding Factors in a PTLC and Trampoline World</title>
  <updated>2023-06-30T03:06:56.124476+00:00</updated>
  <author>
    <name>ZmnSCPxj 2023-06-28 20:34:37+00:00</name>
  </author>
  <generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator>
  <entry>
    <id>0</id>
    <title>Computing Blinding Factors in a PTLC and Trampoline World</title>
    <updated>2023-06-30T03:06:56.124499+00:00</updated>
    <link href="https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-June/003999.html" rel="alternate"/>
    <summary>In this message, ZmnSCPxj presents a mathematical demonstration of a method for computing blinding factors in a privacy-preserving routing system. The goal is to ensure that non-Trampoline intermediate nodes only need to know one blinding factor, the receiver only needs to know one blinding factor, and Trampoline nodes can provide blinding factors without revealing their involvement.The demonstration starts with the ultimate receiver having a secret value 'r' and providing the point 'R' to the ultimate sender. The ultimate sender then selects a random scalar 'e', which represents the error blinding factor, and constructs an onion that can be decrypted by the ultimate receiver. Along with the onion, the ultimate sender offers a Payment-Triggered Lightning Contract (PTLC) with the point 'e * G + R', where 'G' represents a generator point.In the simplest case where there are no intermediate nodes, the ultimate receiver can claim the PTLC by revealing 'e + r'. This works because the ultimate receiver learns 'e' from the onion and knows 'r', fulfilling the contract to provide 'r' in exchange for payment.However, if there is an intermediate node, such as Carol, involved, the ultimate sender needs to generate two scalars, 'c' and 'd', such that 'c + d = e'. This is done by selecting a random 'd' and calculating 'c = e - d'. The ultimate sender then encrypts the onion with 'e' encrypted to the ultimate receiver and 'd' encrypted to Carol. The PTLC sent to Carol is now 'c * G + R'.At each intermediate non-Trampoline node, like Carol, the input point is obtained by adding its per-hop blinding factor times 'G' to the received point. In Carol's case, it receives 'c * G + R', adds 'd * G' obtained from the onion, and sends a PTLC with the point 'c * G + R + d * G' to the next hop.It is important to note that since 'e = c + d', the PTLC sent by Carol to the ultimate sender can be rearranged as '(c + d) * G + R', which equals 'e * G + R'. Therefore, the ultimate receiver cannot differentiate whether it received from Carol or a further node because both cases result in the same value 'e * G + R'.When the ultimate receiver reveals 'e + r', Carol can compute 'c + r' by subtracting 'd' from 'e + r'. Since 'c = e - d', 'e + r - d = e - d + r = c + r'. Carol can then claim the incoming 'c * G + R' using scalar 'c + r'. However, Carol does not know 'c', only 'd', so it cannot compute 'r'.In the situation where Carol is a Trampoline node and the ultimate sender does not provide a detailed route from Carol to the next Trampoline hop, the process is slightly different. The ultimate sender selects 'R', a random 'e', and computes 'c' and 'd' such that 'c + d = e'. Then, the ultimate sender creates a Trampoline-level onion with 'e' encrypted to the ultimate receiver and 'd' encrypted to Carol.Carol decrypts the onion and obtains 'd'. It then searches for a route from itself to the ultimate receiver, finding a path through Alice. Carol needs to make 'c * G + d * G + R' reach the ultimate receiver, so it selects scalars 'a' and 'b' such that 'a + b = d'. Carol creates an onion with 'b' encrypted to Alice and sends the PTLC with the point 'c * G + R + a * G' to Alice.Alice decrypts the onion and learns 'b'. It forwards the PTLC with the point 'c * G + R + a * G + b * G' to the next hop, the ultimate receiver. In this case, 'a + b = d' implies that 'a * G + b * G = d * G', and 'c + d = e' implies that 'c * G + d * G = e * G'. Therefore, the ultimate receiver receives the same value 'e * G + R' regardless of whether it is reached via a Trampoline, a non-Trampoline intermediate node, or directly.In conclusion, ZmnSCPxj's demonstration highlights a method for computing blinding factors in a privacy-preserving routing system. This method ensures that only essential information is revealed to different nodes while maintaining the privacy and integrity of the transaction flow.</summary>
    <published>2023-06-28T20:34:37+00:00</published>
  </entry>
</feed>
