<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>0</id>
  <title>Computing Blinding Factors in a PTLC and Trampoline World</title>
  <updated>2023-07-09T03:03:03.993307+00:00</updated>
  <author>
    <name>ZmnSCPxj 2023-06-28 20:34:37+00:00</name>
  </author>
  <generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator>
  <entry>
    <id>0</id>
    <title>Computing Blinding Factors in a PTLC and Trampoline World</title>
    <updated>2023-07-09T03:03:03.993340+00:00</updated>
    <link href="https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-June/003999.html" rel="alternate"/>
    <summary>In this email, the sender introduces a mathematical demonstration of a method to compute blinding factors for routing in a privacy-preserving manner. The goal is to ensure that certain nodes along the route only need to know one blinding factor, while still allowing trampoline nodes to provide blinding factors without revealing their role.The demonstration begins with the ultimate receiver having a secret value `r`. The receiver gives the ultimate sender the point `R`, which is calculated as `R = r * G`, where `G` is a predefined point on the curve.In the simplest case where there are no intermediate nodes, the ultimate sender chooses a random scalar `e` as the error blinding factor and constructs an onion with `e` encrypted to the ultimate receiver. The sender also offers a payment contract with the point `e * G + R`. The ultimate receiver can claim the payment by revealing `e + r`.However, when there is an intermediate node involved, such as Carol, the ultimate sender needs to generate two scalars, `c` and `d`, such that `c + d = e`. This is done by selecting a random `d` and computing `c = e - d`. The sender then encrypts the onion with `e` encrypted to the ultimate receiver and `d` encrypted to Carol. Each non-Trampoline intermediate node adds its per-hop blinding factor times `G` to the input point and forwards the result to the next hop.When Carol receives the onion, it adds the `d * G` (the error it got from the onion) to the received point and sends a modified PTLC with the point `c * G + R + d * G`. By rearranging the terms, this is equivalent to `(c + d) * G + R`, which is the same as `e * G + R` seen by the ultimate receiver. Therefore, the ultimate receiver cannot differentiate between a direct route and a route with intermediate nodes.In the case where Carol is a Trampoline node, the ultimate sender encrypts the onion with `e` encrypted to the ultimate receiver, `d` encrypted to Carol, and the next Trampoline hop encrypted to Carol. Carol then decrypts the onion and searches for a route from itself to the ultimate receiver. Let's say it finds a route through Alice. Carol needs to make `c * G + d * G + R` reach the ultimate receiver, which can be achieved by selecting scalars `a` and `b` such that `a + b = d`. Carol creates a new onion with `b` encrypted to Alice and forwards the PTLC with the point `c * G + R + a * G` to Alice. Alice decrypts the onion and forwards the PTLC with the point `c * G + R + a * G + b * G` to the ultimate receiver. Again, the ultimate receiver sees the same `e * G + R`, regardless of whether there are trampoline or non-trampoline intermediate nodes.Each intermediate node has enough information to claim its incoming PTLC, but only the ultimate sender knows `c`, allowing it to recover the secret value `r`.This demonstration shows a method for computing blinding factors in routing that ensures privacy and allows trampoline nodes to provide blinding factors without revealing their role.</summary>
    <published>2023-06-28T20:34:37+00:00</published>
  </entry>
</feed>
