<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>0</id>
  <title>Computing Blinding Factors in a PTLC and Trampoline World</title>
  <updated>2023-07-10T03:03:32.918254+00:00</updated>
  <author>
    <name>ZmnSCPxj 2023-06-28 20:34:37+00:00</name>
  </author>
  <generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator>
  <entry>
    <id>0</id>
    <title>Computing Blinding Factors in a PTLC and Trampoline World</title>
    <updated>2023-07-10T03:03:32.918282+00:00</updated>
    <link href="https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-June/003999.html" rel="alternate"/>
    <summary>In this email, ZmnSCPxj provides a mathematical demonstration of a method for computing blinding factors in a way that ensures:- Non-Trampoline intermediate nodes only need to know one blinding factor.- The receiver only needs to know one blinding factor.- Trampoline nodes can provide the blinding factors for the sub-routes without the non-Trampoline intermediate nodes knowing they are on a trampoline.The demonstration starts with the ultimate receiver having a secret `r` and giving the ultimate sender the point `R = r * G`, where `G` is a constant. In the simplest case where the ultimate sender is directly connected to the ultimate receiver, the ultimate sender chooses a random scalar `e`, constructs an onion with `e` encrypted for the receiver, and offers a PTLC (Payment Tokenized Lightning Contract) with the point `e * G + R`. The ultimate receiver can claim the PTLC by revealing `e + r`.If there is an intermediate node, Carol, between the ultimate sender and the ultimate receiver, the ultimate sender still chooses a random scalar `e`, but it also generates two scalars, `c` and `d`, such that `c + d = e`. The ultimate sender encrypts `e` for the ultimate receiver and `d` for Carol. Each non-Trampoline intermediate node adds its per-hop blinding factor times `G` to the input point and sends the updated point to the next hop. The ultimate receiver cannot differentiate whether it received the PTLC from Carol or a direct source-to-destination route since it sees `e * G + R` in both cases.If Carol is a Trampoline node and the ultimate sender does not provide a detailed route from Carol to the next Trampoline hop, the ultimate sender selects a random `e`, computes `c` and `d` such that `c + d = e`, and creates a Trampoline-level onion with `e` encrypted for the ultimate receiver and `d` encrypted for Carol. Carol decrypts the onion, searches for a route to the next Trampoline hop, and creates a new onion with `b` encrypted for Alice. Alice decrypts the onion, forwards the PTLC to the next hop, and the ultimate receiver receives the PTLC with the same `e * G + R` value as in the previous cases.In claiming the PTLC, every intermediate node has enough data to claim its incoming PTLC, but only the ultimate sender knows `c` to recover `r`.Overall, this mathematical demonstration shows a way to compute blinding factors that allows for efficient routing without compromising privacy or requiring multiple blinding factors to be known by different nodes in the network.</summary>
    <published>2023-06-28T20:34:37+00:00</published>
  </entry>
</feed>
