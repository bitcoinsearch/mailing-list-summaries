<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>2</id>
  <title>Combined summary - Potential vulnerability in Lightning backends: BOLT-11 "payment hash" does not commit to payment!</title>
  <updated>2023-07-06T03:05:54.427874+00:00</updated>
  <author>
    <name>callebtc 2023-06-19 15:26:05+00:00</name>
  </author>
  <author>
    <name>Antoine Riard 2023-06-19 20:34:10+00:00</name>
  </author>
  <link href="lightning-dev/June_2023/003983_Potential-vulnerability-in-Lightning-backends-BOLT-11-payment-hash-does-not-commit-to-payment-.xml" rel="alternate"/>
  <link href="lightning-dev/June_2023/003986_Potential-vulnerability-in-Lightning-backends-BOLT-11-payment-hash-does-not-commit-to-payment-.xml" rel="alternate"/>
  <generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator>
  <entry>
    <id>2</id>
    <title>Combined summary - Potential vulnerability in Lightning backends: BOLT-11 "payment hash" does not commit to payment!</title>
    <updated>2023-07-06T03:05:54.427943+00:00</updated>
    <link href="https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-June/003983.html" rel="alternate"/>
    <summary>Last month, the LNbits team discovered an exploit that allowed attackers to create fake balances by exploiting a vulnerability in how invoices are handled internally. The team quickly patched this issue in LNbits version 0.10.5 and urged users to update as soon as possible. They believe that similar exploits could be possible in other Lightning applications, especially those related to custodial wallets, payment processors, and account management software.In this attack, the attacker was able to manipulate the payment hashes of two invoices to trick the backend into believing that they were the same. The process involved creating invoice A with an amount of 1000 satoshis in LNbits, and creating a separate invoice B' with an amount of 1 satoshi on the attacker's own node. The attacker then inserted the payment hash of invoice A into invoice B, re-signed the invoice, and serialized it again to create a malicious invoice B. The attacker then created a new account in LNbits and paid invoice B.The LNbits backend uses the payment hash to determine whether a payment is internal or via the Lightning Network. In this case, the backend found invoice A in its database because it assumed that the payment hash committed to A. However, the critical part is that payment hashes do not actually commit to payment details like the amount. Instead, they only commit to the preimage. This allowed the attacker to settle the payment internally by crediting invoice A and debiting invoice B, effectively creating 999 satoshis out of thin air.To mitigate this issue, backends should either use self-generated unique "checking ids" for internal payments or implement additional checks to ensure that the invoice details have not been manipulated. For example, they can assert that the amounts of the two invoices are the same.The incident highlights two important lessons. Firstly, it demonstrates the level of sophistication of attackers familiar with Lightning Network protocols. This attack required a deep understanding of bolt-11 and custom tooling to create the malicious invoice. Secondly, it emphasizes the need to clarify the terminology used in Lightning Network invoices. The "payment hash" is more accurately described as a "preimage" hash, as it only commits to the preimage and not other payment details like the amount or public key.Overall, this incident serves as a reminder for developers and users of Lightning applications to stay vigilant and implement proper security measures to protect against potential exploits.</summary>
    <published>2023-06-19T15:26:05+00:00</published>
  </entry>
</feed>
