<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>2</id>
  <title>Combined summary - Potential vulnerability in Lightning backends: BOLT-11 "payment hash" does not commit to payment!</title>
  <updated>2023-07-04T03:06:43.841574+00:00</updated>
  <author>
    <name>callebtc 2023-06-19 15:26:05+00:00</name>
  </author>
  <author>
    <name>Antoine Riard 2023-06-19 20:34:10+00:00</name>
  </author>
  <link href="lightning-dev/June_2023/003983_Potential-vulnerability-in-Lightning-backends-BOLT-11-payment-hash-does-not-commit-to-payment-.xml" rel="alternate"/>
  <link href="lightning-dev/June_2023/003986_Potential-vulnerability-in-Lightning-backends-BOLT-11-payment-hash-does-not-commit-to-payment-.xml" rel="alternate"/>
  <generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator>
  <entry>
    <id>2</id>
    <title>Combined summary - Potential vulnerability in Lightning backends: BOLT-11 "payment hash" does not commit to payment!</title>
    <updated>2023-07-04T03:06:43.841613+00:00</updated>
    <link href="https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-June/003983.html" rel="alternate"/>
    <summary>Last month, the LNbits team discovered an exploit that allowed attackers to create balances by exploiting a quirk in how invoices are handled internally. This exploit has been patched in LNbits version 0.10.5, and users are urged to update as soon as possible. The team believes that similar exploits may be possible in other Lightning applications, particularly those involving custodial wallets, payment processors, and account management software.The attack involved the insertion of a bolt-11 payment hash of payment A into a different payment, creating a malicious invoice B that could trick the backend into believing that B was equal to A. The process involved the attacker creating invoice A with an amount of 1000 sat in LNbits, and then creating invoice B' with an amount of 1 sat on their own node. The attacker would then deserialize B', insert payment_hash(A) into payment_hash(B), re-sign the invoice, and serialize it again to produce the malicious invoice B. The attacker would then create a new account in LNbits and pay invoice B.The LNbits backend uses payment_hash(B) to determine whether a payment is internal or via the Lightning Network. In this case, the backend would find invoice A in its database since it assumes that payment_hash(A) commits to A. However, the critical part of this exploit is that payment hashes do not commit to payment details like amount, but only to the preimage.As a result, the backend would settle the payment internally by crediting A and debiting B, effectively allowing the attacker to "create" 999 sats. To mitigate this issue, backends should use self-generated unique "checking IDs" for looking up internal payments or implement additional checks to verify that the invoice details have not been tampered with.There are two lessons to be learned from this exploit. First, it highlights the level of sophistication of LN-savvy attackers, as this attack required a fundamental understanding of bolt-11 and custom tooling to produce the malicious invoice. Second, it emphasizes that the "payment hash" of an invoice is not actually a "payment" hash, but rather a "preimage" hash. This distinction is important to avoid developers implicitly assuming that the hash commits to payment details like amount or pubkey.In response to the report, Antoine acknowledges the possibility of the attack and suggests that custodial wallets, payment processors, and account management software based on LDK should not be affected if they follow the API recommendations. He also mentions potential safety issues with invoices that have been known since CVE-2020-26896 and advises good disclosure security practice, such as warning Lightning implementation maintainers in advance.</summary>
    <published>2023-06-19T15:26:05+00:00</published>
  </entry>
</feed>
