<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>2</id>
  <title>Combined summary - Potential vulnerability in Lightning backends: BOLT-11 "payment hash" does not commit to payment!</title>
  <updated>2023-07-29T19:15:33.276355+00:00</updated>
  <author>
    <name>Rusty Russell 2023-07-06 07:10:42+00:00</name>
  </author>
  <author>
    <name>callebtc 2023-07-06 07:22:59+00:00</name>
  </author>
  <author>
    <name>David A. Harding 2023-07-12 20:04:19+00:00</name>
  </author>
  <author>
    <name>fiatjaf 2023-07-13 21:03:11+00:00</name>
  </author>
  <author>
    <name>Martin Habovštiak 2023-07-15 20:30:06+00:00</name>
  </author>
  <author>
    <name>Olaoluwa Osuntokun 2023-07-16 11:32:08+00:00</name>
  </author>
  <author>
    <name>Martin Habovštiak 2023-07-16 18:11:58+00:00</name>
  </author>
  <author>
    <name>callebtc 2023-06-19 15:26:05+00:00</name>
  </author>
  <author>
    <name>Antoine Riard 2023-06-19 20:34:10+00:00</name>
  </author>
  <link href="lightning-dev/July_2023/004005_Potential-vulnerability-in-Lightning-backends-BOLT-11-payment-hash-does-not-commit-to-payment-.xml" rel="alternate"/>
  <link href="lightning-dev/July_2023/004006_Potential-vulnerability-in-Lightning-backends-BOLT-11-payment-hash-does-not-commit-to-payment-.xml" rel="alternate"/>
  <link href="lightning-dev/July_2023/004007_Potential-vulnerability-in-Lightning-backends-BOLT-11-payment-hash-does-not-commit-to-payment-.xml" rel="alternate"/>
  <link href="lightning-dev/July_2023/004008_Potential-vulnerability-in-Lightning-backends-BOLT-11-payment-hash-does-not-commit-to-payment-.xml" rel="alternate"/>
  <link href="lightning-dev/July_2023/004009_Potential-vulnerability-in-Lightning-backends-BOLT-11-payment-hash-does-not-commit-to-payment-.xml" rel="alternate"/>
  <link href="lightning-dev/July_2023/004010_Potential-vulnerability-in-Lightning-backends-BOLT-11-payment-hash-does-not-commit-to-payment-.xml" rel="alternate"/>
  <link href="lightning-dev/July_2023/004012_Potential-vulnerability-in-Lightning-backends-BOLT-11-payment-hash-does-not-commit-to-payment-.xml" rel="alternate"/>
  <link href="lightning-dev/June_2023/003983_Potential-vulnerability-in-Lightning-backends-BOLT-11-payment-hash-does-not-commit-to-payment-.xml" rel="alternate"/>
  <link href="lightning-dev/June_2023/003986_Potential-vulnerability-in-Lightning-backends-BOLT-11-payment-hash-does-not-commit-to-payment-.xml" rel="alternate"/>
  <generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator>
  <entry>
    <id>2</id>
    <title>Combined summary - Potential vulnerability in Lightning backends: BOLT-11 "payment hash" does not commit to payment!</title>
    <updated>2023-07-29T19:15:33.276355+00:00</updated>
    <link href="https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-July/004005.html" rel="alternate"/>
    <summary>The backend of the Lightning Network (LN) currently lacks a verification system for ensuring that the payment amount in an invoice matches the HTLC `amount_msat`. This issue does not affect custodial wallets, payment processors, and account management software based on LDK and following API recommendations. These implementations already handle checks for amount equivalence.However, the LNbits team discovered an exploit related to this vulnerability. The exploit allowed an attacker to manipulate invoices and create balances without proper verification. This issue has been addressed in LNbits version 0.10.5, and users are advised to update their software promptly. Developers working on Lightning applications should also take precautions against similar attacks.In the specific exploit scenario, the attacker manipulated the invoice by inserting the payment hash of one payment into another payment. By creating a malicious invoice, the attacker could deceive the backend into treating it as a legitimate payment and crediting them with 999 sats. The attack involved creating two invoices, A and B'. The attacker then deserialized B', inserted payment_hash(A) into payment_hash(B), re-signed the invoice, and serialized it again, resulting in the creation of the malicious invoice B. The backend, using payment_hash(B) to determine the payment's nature, found A in its database. However, payment hashes do not commit to payment details like the amount, only to the preimage. As a result, the backend settled the payment internally by crediting A and debiting B, allowing the attacker to "create" 999 sats.To prevent similar attacks, the LNBits team suggests two approaches. Backends can use self-generated unique "checking IDs" for internal payment lookups or implement additional checks to ensure that invoice details have not been tampered with. These measures would provide better protection against such exploits in the future.The author also highlights two important lessons from this attack. Firstly, it demonstrates the sophistication of LN-savvy attackers, as executing this exploit requires a deep understanding of bolt-11 and custom tooling. Secondly, the author suggests renaming the "payment hash" field in invoices to the "preimage hash" to avoid developers assuming that the hash commits to payment details like the amount and pubkey.</summary>
    <published>2023-07-06T07:10:42+00:00</published>
  </entry>
</feed>
