<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>2</id>
  <title>Combined summary - Potential vulnerability in Lightning backends: BOLT-11 "payment hash" does not commit to payment!</title>
  <updated>2023-07-01T03:24:00.328169+00:00</updated>
  <author>
    <name>callebtc 2023-06-19 15:26:05+00:00</name>
  </author>
  <author>
    <name>Antoine Riard 2023-06-19 20:34:10+00:00</name>
  </author>
  <link href="lightning-dev/June_2023/003983_Potential-vulnerability-in-Lightning-backends-BOLT-11-payment-hash-does-not-commit-to-payment-.xml" rel="alternate"/>
  <link href="lightning-dev/June_2023/003986_Potential-vulnerability-in-Lightning-backends-BOLT-11-payment-hash-does-not-commit-to-payment-.xml" rel="alternate"/>
  <generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator>
  <entry>
    <id>2</id>
    <title>Combined summary - Potential vulnerability in Lightning backends: BOLT-11 "payment hash" does not commit to payment!</title>
    <updated>2023-07-01T03:24:00.328217+00:00</updated>
    <link href="https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-June/003983.html" rel="alternate"/>
    <summary>Earlier last month, the LNbits team discovered an exploit that allowed attackers to create balances out of thin air by exploiting a quirk in how invoices are handled internally. The team has patched this exploit in LNbits version 0.10.5 and urges users to update as soon as possible. The team believes that similar exploits may be possible in other Lightning applications, especially for those working on custodial wallets, payment processors, and account management software.The attack involved creating a malicious invoice B by inserting the payment hash of payment A into a different payment. Here's how it worked: 1. The attacker created invoice A with an amount of 1000 sat in LNbits.2. The attacker also created invoice B' with an amount of 1 sat on their own node.3. The attacker deserialized B', inserted payment_hash(A) into payment_hash(B), re-signed the invoice, and serialized it again to produce malicious invoice B.4. The attacker then created a new account in LNbits and paid invoice B.5. When the LNbits backend checked the payment_hash(B), it mistakenly found invoice A in its database because it assumed that payment_hash(A) commits to A.6. The backend settled the payment internally by crediting A and debiting B, effectively allowing the attacker to "create" 999 sats.To mitigate this issue, backends should either use self-generated unique "checking ids" for internal payments or implement additional checks to ensure that the invoice details have not been tampered with (e.g., asserting amount(A) == amount(B)).There are two lessons to learn from this exploit. First, it highlights the sophistication of LN-savvy attackers who understand bolt-11 and can produce custom tooling for malicious invoices. Second, it emphasizes that the "payment hash" of an invoice is actually a "preimage" hash and does not commit to payment details like amount or pubkey. Calling it the "preimage hash" instead can help developers avoid assuming that the hash includes payment details.In response to the report, Antoine pointed out that custodial wallets, payment processors, and account management software based on LDK should not be affected if they follow the API recommendations for handling amount equivalence checks.It's important for Lightning implementation maintainers to be informed about potential safety issues with invoices to facilitate patch coordination with second-line vendors like wallets and processors. Good disclosure security practice suggests warning the maintainers in advance through their respective security communication channels.Overall, this exploit serves as a reminder of the need for robust security measures, continuous updates, and awareness of potential vulnerabilities in Lightning applications.</summary>
    <published>2023-06-19T15:26:05+00:00</published>
  </entry>
</feed>
