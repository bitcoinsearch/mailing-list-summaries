<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>2</id>
  <title>Combined summary - Potential vulnerability in Lightning backends: BOLT-11 "payment hash" does not commit to payment!</title>
  <updated>2023-06-28T03:45:09.879617+00:00</updated>
  <author>
    <name>callebtc 2023-06-19 15:26:05+00:00</name>
  </author>
  <author>
    <name>Antoine Riard 2023-06-19 20:34:10+00:00</name>
  </author>
  <link href="lightning-dev/June_2023/003983_Potential-vulnerability-in-Lightning-backends-BOLT-11-payment-hash-does-not-commit-to-payment-.xml" rel="alternate"/>
  <link href="lightning-dev/June_2023/003986_Potential-vulnerability-in-Lightning-backends-BOLT-11-payment-hash-does-not-commit-to-payment-.xml" rel="alternate"/>
  <generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator>
  <entry>
    <id>2</id>
    <title>Combined summary - Potential vulnerability in Lightning backends: BOLT-11 "payment hash" does not commit to payment!</title>
    <updated>2023-06-28T03:45:09.879661+00:00</updated>
    <link href="https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-June/003983.html" rel="alternate"/>
    <summary>Last month, the LNbits team discovered an exploit in their system that allowed attackers to create fake balances by exploiting a quirk in how invoices are handled internally. They have since patched this issue in LNbits version 0.10.5 and strongly recommend that users update their systems as soon as possible. The team believes that similar exploits may be possible in other Lightning applications, especially those related to custodial wallets, payment processors, and account management software.The attack works by inserting a bolt-11 payment hash of payment A into a different payment, creating a malicious invoice B that tricks the backend into thinking that B is equal to A. The attacker creates invoice A with an amount of 1000 sat (satoshi) in LNbits and also creates invoice B' with an amount of 1 sat on their own node. They then manipulate invoice B' by deserializing it, inserting payment_hash(A) into payment_hash(B), re-signing the invoice, and serializing it again to produce the malicious invoice B. The attacker then creates a new account in LNbits and pays invoice B.The LNbits backend uses payment_hash(B) to determine whether the payment is internal or via the Lightning Network. In this case, the backend finds invoice A in its database because it assumes that payment_hash(A) commits to A. However, the critical part is that payment hashes only commit to the preimage and not the payment details like the amount. This allows the attacker to settle the payment internally by crediting A and debiting B, effectively creating 999 sats out of thin air.To mitigate this vulnerability, backends should either use self-generated unique "checking ids" for internal payments or implement additional checks to ensure that the invoice details have not been tampered with (e.g., comparing the amounts of A and B). It is important for developers to understand the level of sophistication of LN-savvy attackers and to recognize that the "payment hash" of an invoice is actually a "preimage" hash, which only commits to the preimage and not the payment details.It is worth noting that custodial wallets, payment processors, and account management software based on LDK and following the API recommendations should not be affected by this exploit, as the implementation handles amount equivalence checks.In conclusion, this exploit in LNbits highlights the need for robust security measures in Lightning applications, especially when handling invoices. Developers should be aware of the sophisticated techniques employed by attackers and take necessary precautions to protect user funds.</summary>
    <published>2023-06-19T15:26:05+00:00</published>
  </entry>
</feed>
