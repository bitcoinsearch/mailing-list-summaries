<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>2</id>
  <title>Combined summary - Potential vulnerability in Lightning backends: BOLT-11 "payment hash" does not commit to payment!</title>
  <updated>2023-07-12T02:52:17.918514+00:00</updated>
  <author>
    <name>callebtc 2023-06-19 15:26:05+00:00</name>
  </author>
  <author>
    <name>Antoine Riard 2023-06-19 20:34:10+00:00</name>
  </author>
  <link href="lightning-dev/June_2023/003983_Potential-vulnerability-in-Lightning-backends-BOLT-11-payment-hash-does-not-commit-to-payment-.xml" rel="alternate"/>
  <link href="lightning-dev/June_2023/003986_Potential-vulnerability-in-Lightning-backends-BOLT-11-payment-hash-does-not-commit-to-payment-.xml" rel="alternate"/>
  <generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator>
  <entry>
    <id>2</id>
    <title>Combined summary - Potential vulnerability in Lightning backends: BOLT-11 "payment hash" does not commit to payment!</title>
    <updated>2023-07-12T02:52:17.918576+00:00</updated>
    <link href="https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-June/003983.html" rel="alternate"/>
    <summary>Last month, the LNbits team discovered an exploit that allowed an attacker to create balances out of thin air by exploiting how invoices are handled internally. This exploit has been patched in LNbits version 0.10.5, and users are urged to update their software as soon as possible. The team believes that similar exploits may be possible in other Lightning applications, particularly those related to custodial wallets, payment processors, and account management software.The attack involved inserting a bolt-11 payment hash of payment A into a different payment, creating a malicious invoice B that could trick the backend into believing that B was equal to A. The process involved creating invoice A with an amount of 1000 sat in LNbits, creating invoice B' with an amount of 1 sat on the attacker's node, deserializing B', inserting payment_hash(A) into payment_hash(B), re-signing the invoice, and serializing it again to produce malicious invoice B. The attacker then created a new account in LNbits and paid invoice B.The LNbits backend used payment_hash(B) to determine whether the payment was internal or via the Lightning Network. Since payment_hash(A) was assumed to commit to A, the backend found A in its database. However, it is important to note that payment hashes do not commit to payment details like amount but only to the preimage. As a result, the backend settled the payment internally by crediting A and debiting B, allowing the attacker to "create" 999 sats.To mitigate this type of attack, backends should either use self-generated unique "checking ids" for looking up internal payments or implement additional checks to ensure that the invoice details have not been tampered with, such as asserting that amount(A) is equal to amount(B).Two lessons can be learned from this exploit. First, it highlights the level of sophistication of LN-savvy attackers, as carrying out this attack required a fundamental understanding of bolt-11 and custom tooling. Second, it emphasizes that the "payment hash" of an invoice is not actually a "payment" hash but simply a "preimage" hash. Calling it a preimage hash reduces the chances of developers mistakenly assuming that the hash commits to payment details like amount and pubkey.Overall, it is important for users and developers of Lightning applications to be aware of these types of exploits and take appropriate measures to protect against them.</summary>
    <published>2023-06-19T15:26:05+00:00</published>
  </entry>
</feed>
