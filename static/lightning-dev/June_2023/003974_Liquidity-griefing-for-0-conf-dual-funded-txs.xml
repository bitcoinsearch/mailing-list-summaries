<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>1</id>
  <title>Liquidity griefing for 0-conf dual-funded txs</title>
  <updated>2023-07-03T02:58:46.867211+00:00</updated>
  <author>
    <name>Antoine Riard 2023-06-07 00:41:12+00:00</name>
  </author>
  <generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator>
  <entry>
    <id>1</id>
    <title>Liquidity griefing for 0-conf dual-funded txs</title>
    <updated>2023-07-03T02:58:46.867236+00:00</updated>
    <link href="https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-June/003974.html" rel="alternate"/>
    <summary>In a discussion on the Lightning-dev mailing list, Bastien Teinturier brings up the challenge of protecting against liquidity griefing attacks in dual-funded transactions. The issue arises when one peer locks their UTXOs as soon as they are added to the shared transaction, causing the other peer to be unable to use their locked liquidity if the remote node goes silent. Unlocking the UTXOs after detecting a fishy remote node is not a viable solution because the liquidity would still be locked for a duration and the remote node could launch similar attacks with different node IDs.To address this issue, a proposed solution is to never lock UTXOs used in dual-funded transactions. If a remote node goes silent, the UTXOs will automatically be reused in another instance of the protocol. However, this approach falls short when using 0-conf (zero-confirmation) channels because accidentally double-spending a 0-conf channel can result in loss of funds. This means that nodes offering 0-conf services expose themselves to liquidity griefing.Another related issue is the race scenario that occurs when the same UTXO is selected for both a non 0-conf funding attempt and a 0-conf funding attempt. This can result in accidental double-spending of the 0-conf channel. To address this, a "soft lock" can be used when selecting UTXOs for a non 0-conf funding attempt. Soft locked UTXOs should be ignored for 0-conf funding attempts but can be reused for non 0-conf funding attempts.In terms of mitigating liquidity griefing related to mempool vectors, one suggestion is for the honest counterparty to enforce that any contributed outputs must be encumbered by a 1 CSV (Check Sequence Verify) unless it is a 2-of-2 funding. However, this mitigation may have limitations as the initial commitment transaction must have anchor outputs on each side for each party to recover their contributed UTXOs.From the perspective of the 0-conf initiator, it may still be valuable to disable inbound payments or require a longer cltv_expiry_delta (time lock) in case of mempool fee spikes that delay the confirmation of the 0-conf chain. Despite efforts to mitigate liquidity griefing, issues related to the lack of signature release or mempool funny games may still persist. Even with package relay and nVersion deployment, there is still a duration between the pinning happening among network mempools and the replacement broadcast starting.As a more long-term solution, ideas from mitigating channel jamming could be reused as the abstract problem is similar. For example, the Staking Credentials framework could be deployed by dual-funding market-makers beyond routing hops. The dual-funding initiator would pay a fee to the maker based on the amount of UTXOs contributed and worst-case liquidity griefing scenario. A privacy-preserving credential can be introduced to unlink dual-funding initiators if the maker has enough volume to constitute a reasonable anonymity set.In conclusion, Bastien Teinturier seeks ideas to improve the situation and offer better protections against liquidity griefing for nodes offering 0-conf services. Although 0-conf is a pain point in implementations, it remains popular among users.</summary>
    <published>2023-06-07T00:41:12+00:00</published>
  </entry>
</feed>
