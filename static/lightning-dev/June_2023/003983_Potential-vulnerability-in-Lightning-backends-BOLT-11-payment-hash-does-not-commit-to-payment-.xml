<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>1</id>
  <title>Potential vulnerability in Lightning backends: BOLT-11 "payment hash" does not commit to payment!</title>
  <updated>2023-07-02T03:19:56.662877+00:00</updated>
  <author>
    <name>callebtc 2023-06-19 15:26:05+00:00</name>
  </author>
  <generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator>
  <entry>
    <id>1</id>
    <title>Potential vulnerability in Lightning backends: BOLT-11 "payment hash" does not commit to payment!</title>
    <updated>2023-07-02T03:19:56.662905+00:00</updated>
    <link href="https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-June/003983.html" rel="alternate"/>
    <summary>Earlier last month, the LNbits team discovered an exploit that allowed attackers to create fraudulent balances by exploiting a loophole in how invoices are handled internally. This exploit has been patched in LNbits version 0.10.5, and users are urged to update their software as soon as possible. The team believes that similar exploits may be possible in other Lightning applications, particularly for those working on custodial wallets, payment processors, and account management software.The attack involved inserting a bolt-11 payment hash of payment A into a different payment, creating a malicious invoice B that appears to be legitimate. The attacker would create invoice A with a certain amount and then create invoice B' with a smaller amount on their own node. They would then modify invoice B' by replacing its payment hash with the payment hash from invoice A, re-sign the invoice, and serialize it again to produce the malicious invoice B. The attacker would then create a new account in LNbits and pay invoice B.When LNbits' backend receives the payment, it uses the payment_hash(B) to determine whether it is an internal payment or a payment via the Lightning Network. Since the backend assumes that payment_hash(A) commits to invoice A, it finds A in its database. However, the critical issue is that payment hashes do not commit to any payment details, such as the amount. As a result, the backend settles the payment internally by crediting invoice A and debiting invoice B, effectively allowing the attacker to "create" 999 satoshis.To mitigate this exploit, backends should use self-generated unique "checking id's" for looking up internal payments or implement additional checks to ensure that the invoice details have not been tampered with. For example, they could verify that the amounts of the original and modified invoices match.This incident highlights two important lessons. Firstly, developers should be aware of the sophistication of attackers familiar with Lightning Network technology. This exploit required a deep understanding of bolt-11 and custom tooling to create the malicious invoice. Secondly, it is crucial to recognize that the "payment hash" of an invoice is actually a "preimage" hash and does not commit to payment details like the amount or public key. Referring to this field as the "preimage hash" instead can help avoid implicit assumptions about its functionality.In conclusion, LNbits has addressed an exploit that allowed attackers to generate fraudulent balances through manipulating invoices. Users are advised to update their software promptly, while developers should implement appropriate mitigations to prevent similar attacks in other Lightning applications.</summary>
    <published>2023-06-19T15:26:05+00:00</published>
  </entry>
</feed>
