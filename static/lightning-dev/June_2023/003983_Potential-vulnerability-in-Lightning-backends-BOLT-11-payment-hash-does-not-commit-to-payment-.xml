<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>1</id>
  <title>Potential vulnerability in Lightning backends: BOLT-11 "payment hash" does not commit to payment!</title>
  <updated>2023-06-27T04:38:05.978819+00:00</updated>
  <author>
    <name>callebtc 2023-06-19 15:26:05+00:00</name>
  </author>
  <generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator>
  <entry>
    <id>1</id>
    <title>Potential vulnerability in Lightning backends: BOLT-11 "payment hash" does not commit to payment!</title>
    <updated>2023-06-27T04:38:05.978846+00:00</updated>
    <link href="https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-June/003983.html" rel="alternate"/>
    <summary>The LNbits team has discovered an exploit that enables an attacker to create balances out of thin air by abusing a quirk in how invoices are handled internally. The attack is possible due to the insertion of a bolt-11 payment hash of payment A into a different payment, creating a malicious invoice B that can trick the backend into believing that B == A. The attacker creates invoice A of amount 1000 sat in LNbits, then creates invoice B' of amount 1 sat on their own node. They deserialise B', insert payment_hash(A) into payment_hash(B), re-sign the invoice, and serialise it again, producing malicious invoice B. The attacker then creates a new account in LNbits and pays B. The mitigation for this exploit is simple: backends should either use self-generated unique "checking id's" for looking up internal payments or use additional checks to ensure that the invoice details have not been messed around with (e.g., asserting amount(A) == amount(B)). This attack highlights the level of sophistication of LN-savvy attackers and their fundamental understanding of bolt-11, which requires custom tooling to produce a malicious invoice.The second lesson learned from this attack is that the "payment hash" of an invoice is not a "payment" hash but merely a "preimage" hash â€“ and nothing else. Naming this field as such increases the chance of developers implicitly assuming that the hash commits to payment details like amount, pubkey, etc. The LNbits team encourages developers to refer to this field as simply the "preimage hash."</summary>
    <published>2023-06-19T15:26:05+00:00</published>
  </entry>
</feed>
