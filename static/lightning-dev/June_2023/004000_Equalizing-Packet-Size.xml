<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>0</id>
  <title>Equalizing Packet Size</title>
  <updated>2023-07-09T03:03:14.335931+00:00</updated>
  <author>
    <name>ZmnSCPxj 2023-06-29 18:13:10+00:00</name>
  </author>
  <generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator>
  <entry>
    <id>0</id>
    <title>Equalizing Packet Size</title>
    <updated>2023-07-09T03:03:14.335962+00:00</updated>
    <link href="https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-June/004000.html" rel="alternate"/>
    <summary>Recently, it has been discovered that despite Noise encryption, a third-party eavesdropper can deduce the content of messages exchanged between Lightning Network (LN) nodes by analyzing the sizes of IP packets transmitted. This poses a potential security risk as it allows the eavesdropper to ascertain the routing of payments across the network. To address this issue, it is proposed to standardize the packet sizes.The BOLT8 specification builds upon TCP, where the receiver perceives the data as a continuous stream of bytes, even though it is actually transmitted in packets over IP. Most implementations have an object or software entity responsible for encrypting messages within BOLT8 tunnels. To tackle the packet size vulnerability, it is suggested to augment this object with a "buffer" functionality.The interface of the object would include two entry points: "send BOLT8 message" and "flush". The object would incorporate an internal buffer of fixed size, which would be filled with ciphertext from the "send BOLT8 message" entry point. When the buffer reaches its capacity, the object utilizes the POSIX `send` API to transmit it as a packet, ensuring uniform packet sizes.The "flush" entry point determines the level of buffer occupancy and appends a `pong` message to pad it until the buffer is completely filled. There is a special case where the buffer is almost full, leaving only enough space for the mandatory 2-byte message length and 2-byte message ID. In such instances, the object should handle this situation correctly.Since the object inserts `pong` messages, it cannot simply function as a basic buffer; it must modify the encryptor state to incorporate the `pong` message into the stream of BOLT8 messages. This approach enables the possibility of encapsulating a sequence of `update_add_htlc` messages followed by a `commitment_signed` message within a single fixed-size packet or a series of fixed-size packets. The implementation must invoke the "flush" entry point to ensure the counterparty receives the complete tail end of the `commitment_signed` message.To enhance robustness against internal bugs and adopt a defensive programming approach, the object could incorporate an individual randomized timer. This timer would periodically trigger a self-initiated "flush" operation, mitigating the risk of situations where the implementation fails to initiate "flush" while waiting for a response from the counterparty. This ensures that any such bugs are relegated to performance issues rather than interoperability problems.It is recommended that the buffer size align with the packet size of `update_add_htlc`, as this size is expected to fit within a single IP packet, optimizing latency.</summary>
    <published>2023-06-29T18:13:10+00:00</published>
  </entry>
</feed>
