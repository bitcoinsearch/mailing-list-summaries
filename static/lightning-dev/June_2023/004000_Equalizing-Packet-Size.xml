<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>0</id>
  <title>Equalizing Packet Size</title>
  <updated>2023-07-02T03:23:28.420999+00:00</updated>
  <author>
    <name>ZmnSCPxj 2023-06-29 18:13:10+00:00</name>
  </author>
  <generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator>
  <entry>
    <id>0</id>
    <title>Equalizing Packet Size</title>
    <updated>2023-07-02T03:23:28.421026+00:00</updated>
    <link href="https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-June/004000.html" rel="alternate"/>
    <summary>Recently, there has been a concern raised regarding the potential for a third-party eavesdropper to guess the content of messages being sent between Lightning Network (LN) nodes by analyzing the sizes of IP packets transmitted between them, even with Noise encryption in place. This raises the possibility of the eavesdropper figuring out how payments are being routed across the network. To address this issue, a solution is proposed to ensure that all packet sizes are the same. The BOLT8 specification builds on top of TCP, where the receiver perceives a stream of bytes despite the underlying IP being packetized. Most implementations have an object or similar software construction responsible for encrypting messages for BOLT8 tunnels. This object can be modified to include a "buffer" functionality in addition to its tunnel encryption capabilities.The interface of this object would then have entry points for sending BOLT8 messages and flushing the buffer. The object would have an internal buffer of a fixed size, which would be filled with ciphertext from the "send BOLT8 message" interface. Once the buffer is full, the object utilizes the POSIX `send` API to send it as a packet, ensuring that packets sent are of a fixed size.The "flush" entry point examines the level of filling in the buffer and adds a `pong` message to pad it until the entire buffer is full. However, there is a specific scenario where the buffer may already be filled enough that the mandatory 2-byte message length and 2-byte message ID will cause overflow. In such cases, the object should handle this correctly.Since the object inserts `pong` messages, it cannot simply function as a basic buffer. It needs to modify the encryptor state by inserting the `pong` message into the stream of BOLT8 messages. This approach allows a sequence of `update_add_htlc`s followed by a `commitment_signed` to potentially be included in a single fixed-size packet or a sequence of fixed-size packets. The implementation then calls the "flush" entry point to ensure that the counterparty receives the entire tail end of the `commitment_signed`.To account for robustness against internal bugs and for defensive programming, the object could include an individual randomized timer. This timer would periodically trigger a "flush" on the object itself, in case the implementation fails to properly "flush" when waiting for a response from the counterparty. This approach helps mitigate such bugs, transforming them into performance issues rather than interoperability problems.It is recommended that the buffer size be aligned with the packet size of `update_add_htlc`, as this is expected to fit within a single IP packet for optimal latency.</summary>
    <published>2023-06-29T18:13:10+00:00</published>
  </entry>
</feed>
