<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>0</id>
  <title>Equalizing Packet Size</title>
  <updated>2023-07-08T02:54:11.596673+00:00</updated>
  <author>
    <name>ZmnSCPxj 2023-06-29 18:13:10+00:00</name>
  </author>
  <generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator>
  <entry>
    <id>0</id>
    <title>Equalizing Packet Size</title>
    <updated>2023-07-08T02:54:11.596697+00:00</updated>
    <link href="https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-June/004000.html" rel="alternate"/>
    <summary>Recently, it has been discovered that even with Noise encryption, an eavesdropper can potentially guess the messages being sent between Lightning Network (LN) nodes by analyzing the sizes of IP packets transmitted between them. This raises concerns about the privacy and security of payment routing across the network. To address this issue, a solution is proposed to ensure that all packet sizes are the same.The BOLT8 specification, which builds on top of TCP, defines the receiver's perspective as receiving a continuous stream of bytes, although the reality is that the underlying IP is packetized. Most implementations of BOLT8 tunnels have an object or software construction responsible for encrypting messages. To enhance this encryption process, it is suggested to transform this object into a "buffer" in addition to a tunnel encrypter.The interface of this object would include "send BOLT8 message" and "flush" entry points. The object would internally maintain a fixed-sized buffer, which it fills with ciphertext from the "send BOLT8 message" interface. When the buffer reaches its capacity, the object uses the POSIX `send` API to send it as a packet, ensuring that packets are of a fixed size.The "flush" entry point monitors the buffer's filling status and adds a `pong` message to pad it until the entire buffer is full. However, there is an edge case where the buffer might already be filled enough that the mandatory 2-byte message length and the 2-byte message ID will exceed the buffer's capacity, which should be handled correctly.Since the object inserts `pong` messages, it cannot be a simple buffer; it needs to modify the encryptor state by inserting the `pong` message into the stream of BOLT8 messages. This approach allows a sequence of `update_add_htlc`s followed by a `commitment_signed` to potentially be combined into a single fixed-size packet or a sequence of fixed-size packets. The "flush" entry point needs to be called by the implementation to ensure that the counterparty receives the complete tail end of the `commitment_signed` message.To enhance robustness against internal bugs and implement defensive programming, the object could have an individual randomized timer that periodically triggers a self-"flush." This addresses situations where the implementation fails to properly "flush" when waiting for a response from the counterparty. By doing so, these bugs become performance-related rather than interoperability issues.It is suggested that the buffer size should match the packet size of `update_add_htlc` to ensure optimal latency, as it is expected to fit within a single IP packet.In conclusion, implementing a buffer in addition to the tunnel encrypter in BOLT8 tunnels can address potential privacy and security concerns related to eavesdropping on packet sizes. By using a fixed-sized buffer and the "flush" entry point, packets can be standardized, ensuring the confidentiality of messages transmitted between LN nodes. Additionally, incorporating a randomized timer for self-"flushing" enhances robustness against bugs and improves overall network performance.Regards,ZmnSCPxj</summary>
    <published>2023-06-29T18:13:10+00:00</published>
  </entry>
</feed>
