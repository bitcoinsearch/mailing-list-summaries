<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>1</id>
  <title>Proposal: Bundled payments</title>
  <updated>2023-07-09T02:57:03.962366+00:00</updated>
  <author>
    <name>SomberNight 2023-06-20 16:49:05+00:00</name>
  </author>
  <generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator>
  <entry>
    <id>1</id>
    <title>Proposal: Bundled payments</title>
    <updated>2023-07-09T02:57:03.962402+00:00</updated>
    <link href="https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-June/003990.html" rel="alternate"/>
    <summary>One important point to note in this proposal is that there are potentially three entities involved in these payments. This may not be obvious at first, especially in the case of submarine swaps. The three entities are the user (or customer), the server (or swap service provider), and the payer (or Bob). This is a key use case for the proposal.The proposal requires senders to be aware that the payment will result in a channel creation or splice on the receiver's end. This means that all existing software used by senders would need to be updated.In the case of a submarine swap scenario, there are three entities involved: Alice (the user receiving the payment), the swap service provider (server), and Bob (the payer). Alice generates an invoice to receive money on-chain, while Bob wants to pay that invoice via Lightning. Alice needs client-side logic for the swap, and Bob needs to implement the proposal (or an equivalent) to parse the invoice with two payment hashes and corresponding amounts.Using a swap service, Bob can pay Alice through Lightning, while Alice receives the payment on-chain. The process involves Alice generating a preimage and calculating its hash (RHASH1) for the main amount she wants to receive. Alice then contacts the swap server, providing RHASH1 and the amount. The swap server generates another preimage and its hash (RHASH2) for the small prepayment amount. The server creates a lightning invoice containing both payment hashes and amounts, which Alice checks before giving it to Bob. Bob sees the invoice with the two payment hashes and amounts and sends HTLCs to cover both. The HTLCs arrive at the swap server, who waits until sufficient money is offered for both the prepayment and main payment. Once the server has the preimage for RHASH2, it fulfills the HTLCs for the prepayment and creates a swap funding transaction on-chain. Alice sees the funding transaction on-chain, validates it, and broadcasts a claim transaction using the preimage for RHASH1. The server fulfills the remaining HTLCs for RHASH1.It should be noted that Bob is a simple lightning wallet that can parse and pay this type of LN invoice. All the security checks and swap logic are implemented on Alice's side. However, one drawback is that Bob expects the payment to go through quickly but ends up waiting for on-chain transactions to be mined.In addition to swaps, another use case is JIT (Just-in-Time) channels. Similar to the swap example, Alice could negotiate with the service provider to open a JIT channel and forward the HTLC using it. Alice can wait for the channel funding to be mined before releasing the preimage for the main payment by fulfilling the HTLC offchain. Bob remains unaware of what happens between the service provider and Alice and only experiences the delay in HTLC fulfillment.Overall, the proposal suggests adding a new feature to BOLT-11, where an invoice can contain two bundled payments with distinct preimages and amounts. This feature is useful for services that require prepayment of a mining fee for non-custodian exchanges, such as submarine swaps and JIT channels. The proposal requires senders to update their software and introduces the concept of three entities involved in the payments.In a recent discussion on the lightning-dev mailing list, ThomasV proposed a solution to address the vulnerability of Boltz, a lightning service provider, to Denial-of-Service (DoS) attacks. These attacks exploit the need for Boltz to show two invoices for simultaneous payment, which can force them to pay on-chain fees. To protect against this attack, ThomasV suggests implementing Just-In-Time (JIT) channels, where providers ask for the preimage of the main payment before opening the channel. However, this approach makes the service provider a custodian, subject to legal regulations like the European MICA regulation.To overcome this issue, ThomasV proposes bundling the prepayment and main payment in the same BOLT-11 invoice. The semantics of bundled payments would involve including two preimages and two amounts in the invoice. The receiver would wait for all the HTLCs (Hashed Time-Locked Contracts) of both payments to arrive before fulfilling the HTLCs of the prepayment. If the main payment fails to arrive, the prepayment would be failed with a Multi-Path Payment (MPP) timeout. Once all the HTLCs have arrived, the receiver would fulfill the HTLCs of the prepayment and broadcast their on-chain transaction. It is important to note that the main payment can still fail if the sender does not reveal the preimage.While this proposal does not prevent the service provider from stealing the pre-payment, ThomasV believes it would level the playing field in terms of competition among lightning service providers. Currently, using Loop requires a dedicated client, leaving competitors without an established user base vulnerable to the mining fee attack. Additionally, ACINQ, the company behind</summary>
    <published>2023-06-20T16:49:05+00:00</published>
  </entry>
</feed>
