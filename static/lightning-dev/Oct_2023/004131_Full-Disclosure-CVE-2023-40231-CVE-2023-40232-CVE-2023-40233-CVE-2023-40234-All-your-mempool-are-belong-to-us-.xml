<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>1</id>
  <title>Full Disclosure: CVE-2023-40231 / CVE-2023-40232 / CVE-2023-40233 / CVE-2023-40234 "All your mempool are belong to us"</title>
  <updated>2023-10-19T01:54:03.752789+00:00</updated>
  <author>
    <name>Antoine Riard 2023-10-17 18:34:52+00:00</name>
  </author>
  <generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator>
  <entry>
    <id>1</id>
    <title>Full Disclosure: CVE-2023-40231 / CVE-2023-40232 / CVE-2023-40233 / CVE-2023-40234 "All your mempool are belong to us"</title>
    <updated>2023-10-19T01:54:03.752824+00:00</updated>
    <link href="https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-October/004131.html" rel="alternate"/>
    <summary>In the email, the sender discusses a scenario involving channels and transactions in the context of Bitcoin programming. The sender mentions that without 'C' claiming it, 'B' forces the 'B====C' channel onchain. They explain that HTLC-timeout transactions do not confirm because they are replaced by C's HTLC-preimage, which remains valid after the HTLC timelock between 'B' and 'C' expires. This HTLC-preimage is then replaced itself.The sender provides a test link (https://github.com/ariard/bitcoin/commit/19d61fa8cf22a5050b51c4005603f43d72f1efcf) to support their explanation. They mention that 'A' drops the 'A====B' channel onchain and tries to recover the HTLC funds. They clarify that considering the fee rates and mempool congestion is unnecessary as the exploit lies in the replacement mechanism itself.The email also discusses low feerates and how CPFPs (Child Pays For Parent) the commitment transaction. It mentions that 'C' can use the knowledge of the preimage, as its own incoming HTLC has already been confirmed as claimed by 'A'. The sender explains that 'C' broadcasts an HTLC-success transaction at block height 144, but does so at every block between blocks 100 and 144 to replace 'B's HTLC-timeout transaction. They note that 'B' cannot feebump this transaction since it is presigned in this case, and they explain why 'B' cannot feebump it using the sighash_single | anyonecanpay on 'C's signature.</summary>
    <published>2023-10-17T18:34:52+00:00</published>
  </entry>
</feed>
