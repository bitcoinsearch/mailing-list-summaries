<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>0</id>
  <title>Multipath Keysend</title>
  <updated>2023-07-29T02:00:24.312085+00:00</updated>
  <author>
    <name>ZmnSCPxj 2023-07-27 17:13:59+00:00</name>
  </author>
  <generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator>
  <entry>
    <id>0</id>
    <title>Multipath Keysend</title>
    <updated>2023-07-29T02:00:24.312122+00:00</updated>
    <link href="https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-July/004028.html" rel="alternate"/>
    <summary>A scheme for creating a `keysend` protocol that allows for multipath payments is proposed. In this scheme, the preimage is embedded as TLV 5482373484 with a length of 32. The goal in the multipath case is to ensure that the receiver can only claim the payment once all parts have arrived.To achieve this, the sender splits the `keysend` into two parts. They select a true preimage `p` at random and generate the payment hash `h = SHA256(p)`. Then, they generate a new 256-bit scalar, `a`. For one part, the sender sends `a` as TLV 5482373484, and for the second part, they send `a ^ p`, where `^` represents XOR. It's important to note that all parts use the same payment hash `h`.When the receiver receives either part, it realizes that the supposed preimage does not match the actual HTLC payment hashes. However, instead of failing, the receiver holds the payment using the usual basic multipath payment rules.Once the receiver receives another part, it XORs together the supposed preimages. In the example mentioned earlier, it would XOR `a` and `a ^ p` to get `a ^ a ^ p` or `p`, which is now the correct preimage. This allows the receiver to claim the entire complete funds.This technique can be extended to any number of parts. For instance, if we split into `n` parts, we generate `n - 1` additional random scalars and use them for the first `n - 1` parts. Then, we XOR all of them with the scalar-to-be-split for the `n`th part. This scheme also works for dynamic splitting, meaning that if a part was already split off from another part, it can still be split further.To detect if the receiver supports multipath `keysend`, the sender can check if a part reaches the receiver and it errors with `incorrect_or_unknown_payment_details`. If the receiver is aware of multipath `keysend`, it will hold onto the incoming HTLCs until MPP timeout and instead error with `mpp_timeout`. Therefore, support for this feature on the receiver side does not need to be specially announced via a new feature bit. The same feature bit 55 can be reused.Overall, this proposed scheme provides a simple method for implementing a `keysend` protocol that allows for multipath payments without requiring additional feature bits or announcements.</summary>
    <published>2023-07-27T17:13:59+00:00</published>
  </entry>
</feed>
