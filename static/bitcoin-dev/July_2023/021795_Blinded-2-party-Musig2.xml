<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>1</id>
  <title>Blinded 2-party Musig2</title>
  <updated>2023-07-25T02:21:51.847175+00:00</updated>
  <author>
    <name>Erik Aronesty 2023-07-24 14:25:00+00:00</name>
  </author>
  <generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator>
  <entry>
    <id>1</id>
    <title>Blinded 2-party Musig2</title>
    <updated>2023-07-25T02:21:51.847212+00:00</updated>
    <link href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-July/021795.html" rel="alternate"/>
    <summary>In a discussion on the bitcoin-dev mailing list, Tom Trevethan shared details about implementing a version of 2-of-2 Schnorr MuSig2 for statechains. In this implementation, the server (referred to as party 1) would be fully "blinded," meaning it holds a private key required to generate an aggregate signature on an aggregate public key but does not learn the aggregate public key, the aggregate signature, or the message being signed.The security of the blinded statechains model relies on trusting the statechain server to report the number of partial signatures generated for a particular key and verifying the full set of signatures generated on the client side. Tom explains that in the MuSig2 protocol, party 1 generates a private key x1 and a public key X1 = x1G, while party 2 generates a private key x2 and a public key X2 = x2G. The set of public keys is denoted as L = {X1, X2}. The key aggregation coefficient is calculated as KeyAggCoef(L,X) = H(L,X), where H is a hash function. The shared (aggregate) public key X is computed as X = a1X1 + a2X2, where a1 = KeyAggCoef(L,X1) and a2 = KeyAggCoef(L,X2).To sign a message m, party 1 generates a nonce r1 and computes R1 = r1G. Party 2 generates a nonce r2 and computes R2 = r2G. These nonces are then aggregated into R = R1 + R2. Each party then computes a challenge c using the hash function H with the inputs X, R, and m. Party 1 calculates s1 = c.a1.x1 + r1, while Party 2 calculates s2 = c.a2.x2 + r2. Finally, the signature is represented as (R, s1+s2).In the case of blinding party 1 to the full public key and final signature, Tom suggests a modification to the protocol. Party 2 performs both the key aggregation and nonce aggregation, while party 1 only sends its public key X1 and nonce R1 to party 2. Party 2 then computes the challenge c and sends it to party 1, who can calculate s1 = c.a1.x1 + r1 without learning the final value of the signature or the message being signed.The discussion raises a question about the vulnerability of Tom's scheme to a specific attack. ZmnSCPxj points out that MuSig2 requires multiple 'R' points per signatory to prevent certain attacks. In Tom's scheme, there is only one 'R' per party, which may make it susceptible to such attacks.Overall, the discussion revolves around the implementation of 2-of-2 Schnorr MuSig2 for statechains, with Tom proposing a modification for party 1 to be blinded to the aggregate public key, aggregate signature, and message. There is some concern about the vulnerability of this modified scheme to specific attacks.</summary>
    <published>2023-07-24T14:25:00+00:00</published>
  </entry>
</feed>
