<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>1</id>
  <title>Blinded 2-party Musig2</title>
  <updated>2023-07-27T01:55:47.206221+00:00</updated>
  <author>
    <name>Erik Aronesty 2023-07-26 04:09:41+00:00</name>
  </author>
  <generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator>
  <entry>
    <id>1</id>
    <title>Blinded 2-party Musig2</title>
    <updated>2023-07-27T01:55:47.206260+00:00</updated>
    <link href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-July/021807.html" rel="alternate"/>
    <summary>Personally, the author believes that every time a public key is transmitted, it should come with a "proof of secret key" to prevent accidental vulnerabilities. The author suggests that this proof should be integrated into low-level protocols. The alt discussion link provided further elaborates on this idea (https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406).In the email thread, Tom Trevethan discusses the v=2 nonces signing protocol of musig2 and how it prevents the Wagner attack. He also mentions that the challenge value c must be blinded from the server to prevent the server from determining the signature from the on-chain state.Furthermore, in order to update the server's keyshare when a statecoin is transferred between users, the key aggregation coefficient must be set to 1 for each key. This coefficient prevents 'rogue key attacks' where one party can choose a public key derived from both their own secret key and the inverse of the other party's public key, giving them the ability to unilaterally produce a valid signature over the aggregate key. However, this can be prevented by the party producing a proof of knowledge of the private key corresponding to their supplied public key. This proof can be a signature, which is produced by signing the statechain state in the mercury protocol. The receiver of a coin must verify this signature, along with verifying that the server pubkey combines with the sender pubkey to get the coin address. This ensures that the server is required to co-sign to generate any signature for this address.The email then presents a modified protocol for key generation and signing, as well as a protocol for transferring statecoins. In the keygen protocol, the server generates a private key x1 and sends the corresponding public key X1 to the user. The user generates a private key x2, a blinding nonce z, and computes the aggregate public key X = z.(X1 + X2). The signing protocol involves the server generating nonces R11 and R12, and sending them to the user. The user generates their own nonces R21 and R22, computes R1 = R11 + R21, R2 = R12 + R22, b = H(X,(R1,R2),m), R = R1 + b.R2, and c = (X,R,m). The user then sends the values y = cz and b to the server. The server computes s1 = yx1 + r11 + br12 and sends it to the user. The user computes s2 = yx2 + r21 + br22, s = s1 + s2, and produces the signature (s,R).For statecoin transfer, the recipient must verify certain conditions. They need to retrieve the current public key from the server for the coin (X1), retrieve the public key X2 and blinding nonce z from the sender, verify that z.X1 + X2 equals the address of the statecoin, and verify that the sender has the private key used to generate X2 by verifying the statechain signature over the receiver public key X3 from X2. This ensures that the address was generated with the cooperation of the server and that no previous owner holds the full key.To update the key shares on transfer, the server generates a random blinding nonce e and sends it to the user. The user adds their private key x2 to the nonce to get t1 = e + x2. The client sends t1 and z (encrypted with the receiver public key X3) to the receiver as part of transfer_msg. The receiver decrypts t1, subtracts their private key x3 to obtain t2 = e + x2 - x3, and sends t2 to the server as part of transfer_receiver. The server updates the private key share x1_2 = x1 + t2 - e = x1 + e + x2 - x3 - e = x1 + x2 - x3. The old server key share x1 is then deleted.In a separate email, Erik Aronesty mentions that "posk" likely refers to "proof of secret key" and discusses the Wagner attack. Another email from AdamISZ confirms that the Wagner attack being referred to is the one mentioned earlier in the thread. Jonas Nick responds to Tom's proposal, expressing doubts about its effectiveness and suggesting that blind musig is still an open research problem. Jonas provides an attack scenario and proposes an alternative scheme that may work.Overall, the thread discusses the need for a proof of secret key when transmitting public keys, the use of blind musig protocols to prevent attacks, and specific protocols for key generation, signing, and statecoin transfer.</summary>
    <published>2023-07-26T04:09:41+00:00</published>
  </entry>
</feed>
