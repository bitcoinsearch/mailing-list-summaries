<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>mailing-list-bitcoin-2014-January-004112</id>
  <title>Bait for reusable addresses</title>
  <updated>2023-05-04T21:11:26.698978+00:00</updated>
  <author>
    <name>Gregory Maxwell</name>
  </author>
  <link href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2014-January/004112.html" rel="alternate"/>
  <generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator>
  <entry>
    <id>https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2014-January/004112.html</id>
    <title>Bait for reusable addresses</title>
    <updated>2023-05-04T21:11:26.698978+00:00</updated>
    <link href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2014-January/004112.html" rel="alternate"/>
    <summary>The challenge with reusable addresses is that while they create a small constant overhead for full nodes in searching for their own transactions, they create large overheads for Simplified Payment Verification (SPV) nodes. One solution is for SPV nodes to hand their servers their blinding private key so that the server may test addresses on their behalf. However, this method is non-reputable and makes privacy brittle. Another idea is including optional "bloom bait", a small token that distinguishes transactions which allow an anonymity set vs filtering trade-off. But bloom bait has privacy problems more severe than the current SPV bloom filtering. The author suggests instead adding optional bait to an address where the sender computes H(nonce-pubkey) and picks one byte at random out of the first 16 and xor it with the specified bait and store the result in the transaction. An SPV server can now index the bait as it comes in by extracting 16 8-bit keys from each transaction. When the client wants to search for transactions, it can give the server a list of keys it's interested in, including their real key and a number of random cover keys. This is a specific simple instance of a general class of solutions related to locally decodable error correcting codes. The parameters need to be fixed to make them the most useful, and schemes loosely based on fountain codes should only require picking some things and xoring, making them simple enough to implement.</summary>
    <published>2014-01-16T01:23:04+00:00</published>
  </entry>
</feed>
