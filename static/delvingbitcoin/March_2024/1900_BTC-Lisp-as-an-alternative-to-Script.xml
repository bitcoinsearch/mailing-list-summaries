<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>1</id>
  <title>BTC Lisp as an alternative to Script</title>
  <updated>2024-03-15T02:00:27.011034+00:00</updated>
  <author>
    <name>prozacchiwawa 2024-03-14 23:03:34.690000+00:00</name>
  </author>
  <generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator>
  <entry>
    <id>1</id>
    <title>BTC Lisp as an alternative to Script</title>
    <updated>2024-03-15T02:00:27.011066+00:00</updated>
    <link href="https://delvingbitcoin.org/t/btc-lisp-as-an-alternative-to-script/682/5" rel="alternate"/>
    <summary>In the realm of programming, particularly when dealing with languages like Chialisp and targets such as clvm, the use of source maps is initially considered a beneficial approach for tracing code execution back to its original source file. However, this method presents challenges unique to the structure and execution model of these languages. Unlike JavaScript, where the majority of executed code directly originates from a source file and can be easily mapped back using source maps, Chialisp operates differently. It frequently involves code that modifies or passes on the environment, similar to dynamically generated functions in JavaScript, which complicates direct mapping.

The core difficulties in accurately mapping clvm executions back to their original Chialisp code stem from several factors. Firstly, identifying the origin of values passed to the 'apply' function is essential yet challenging. This is crucial for understanding their relation to specific parts of the input clvm expression. Secondly, the absence of high-level sequencing outside functions or individual forms, combined with the compactness of clvm's structure, means that different subexpressions might share identical clvm representations. This similarity renders simple one-to-one mappings between literal values in 'apply' ineffective.

Moreover, the mutable nature of JavaScript environments facilitates inferable mappings between names and operations, an advantage not shared by clvm. In clvm environments, references are numeric and only established post-application, necessitating a more sophisticated approach for variable assignment recovery throughout various contexts. The complexity of these issues suggests that a tool as potent as Dwarf might be necessary to achieve comprehensive variable assignment recovery, ensuring accurate mappings in every scenario.</summary>
    <published>2024-03-14T23:03:34.690000+00:00</published>
  </entry>
</feed>
