{
    "id": "bitcointranscripts+lightning-specification+2022-03-14-specification-call",
    "title": "Lightning Specification Meeting - Agenda 0969",
    "body_formatted": "{\"type\":\"paragraph\",\"text\":\"Name: Lightning specification call\"}, {\"type\":\"paragraph\",\"text\":\"Topic: Agenda below\"}, {\"type\":\"paragraph\",\"text\":\"Location: Jitsi\"}, {\"type\":\"paragraph\",\"text\":\"Video: No video posted online\"}, {\"type\":\"paragraph\",\"text\":\"Agenda: <https://github.com/lightning/bolts/issues/969>\"}, {\"type\":\"heading\",\"text\":\"BOLT 4: Remove legacy format, make var_onion_optin compulsory\"}, {\"type\":\"paragraph\",\"text\":\"<https://github.com/lightning/bolts/pull/962>\"}, {\"type\":\"paragraph\",\"text\":\"I think eclair and c-lightning have both removed support for legacy payments.\"}, {\"type\":\"paragraph\",\"text\":\"I\u2019ll probably make a PR to add the feature bit or at least flip it to required. The only wallet I can think of that is somewhat more fringe now is Simple Bitcoin Wallet. I am assuming they are doing the new stuff because they have some other hosted channel thing that adds custom fields.\"}, {\"type\":\"heading\",\"text\":\"BOLT 2: coop-closing clarification\"}, {\"type\":\"paragraph\",\"text\":\"<https://github.com/lightning/bolts/issues/964>\"}, {\"type\":\"paragraph\",\"text\":\"Next one is some questions around co-op close clarification. Do you allow people to send the co-op `closing_signed` message when HTLCs are there? What do we define as a clean slate when a co-op close transaction was able to move forward?\"}, {\"type\":\"paragraph\",\"text\":\"This is about shutdown not `closing_signed`.\"}, {\"type\":\"paragraph\",\"text\":\"You should only send the shutdown message once there are no uncommitted changes including fee updates. If you receive one early then you should just wait until the coast is clear to enter the second stage of co-op close negotiation.\"}, {\"type\":\"paragraph\",\"text\":\"I have two more questions. One of my questions was if you get a shutdown or you send shutdown and then you reconnect should the state be cleared?\"}, {\"type\":\"paragraph\",\"text\":\"Good question. This is something that we do right now. We need to fix it, we consider it a bug. If someone starts co-op close and the connection dies we won\u2019t allow any force close or co-op close to resume after that. Co-op close is weird in that if you send a signature to someone and then resume the channel they can broadcast at any point. That is something on the side that maybe we should add to the spec as well.\"}, {\"type\":\"paragraph\",\"text\":\"It shouldn\u2019t really matter. Once somebody sends shutdown if you care about the shutdown and you reconnect you should also resend the shutdown and then you are in the shutdown again.\"}, {\"type\":\"paragraph\",\"text\":\"What if you don\u2019t send shutdown? That is one of my questions. Is that fine?\"}, {\"type\":\"paragraph\",\"text\":\"If nobody sends shutdown and then somebody sends `closing_signed`?\"}, {\"type\":\"paragraph\",\"text\":\"No if you send shutdown, reconnect and then don\u2019t send shutdown again and horde an HTLC.\"}, {\"type\":\"paragraph\",\"text\":\"That would be up to your counterparty. If your counterparty thinks you are in shutdown they will reject the HTLC. If your counterparty doesn\u2019t think they are in shutdown they will accept it. You are supposed to resend shutdown on reconnect? I don\u2019t actually know if we do.\"}, {\"type\":\"paragraph\",\"text\":\"I don\u2019t think so. I think he is bringing up a point that a channel could get stuck. If one side sends it and the other side remembers it. I think what we do is we remember the shutdown and then if things didn\u2019t happen we won\u2019t let a co-op close happen. It is kind of like a bug.\"}, {\"type\":\"paragraph\",\"text\":\"The solution to this is we should resend shutdown right?\"}, {\"type\":\"paragraph\",\"text\":\"You\u2019d need to remember.\"}, {\"type\":\"paragraph\",\"text\":\"If you require that `shutdown` gets resent then on reconnect if one party remembered it they will resend and then you will be in shutdown. If neither party remembered it then no one will resend it and you won\u2019t be in shutdown. As long as you resend it would be fine.\"}, {\"type\":\"paragraph\",\"text\":\"If they don\u2019t resend and you don\u2019t remember you won\u2019t be in shutdown which is fine. If they do remember to send it and you don\u2019t you\u2019ll still send `shutdown`.\"}, {\"type\":\"paragraph\",\"text\":\"Yeah as long as the party that is remembering resends.\"}, {\"type\":\"paragraph\",\"text\":\"I don\u2019t think it needs to be specified I guess.\"}, {\"type\":\"paragraph\",\"text\":\"I\u2019m not 100 percent sure that resend `shutdown` is currently required but it clearly should be.\"}, {\"type\":\"paragraph\",\"text\":\"Looking at our code, right now after we send a `shutdown` message we will commit that and stop the channel from being used altogether.\"}, {\"type\":\"paragraph\",\"text\":\"We do the same thing as you. We commit it async and we have it implemented in `channel_reestablish`. When we receive a `channel_reestablish` if we\u2019ve committed that and remembered that we have `shutdown` then we will resend that `shutdown` message and then we\u2019ll be in shutdown. It is not a concern as long as you have resend implemented. We may have a bug in it but according to the code it looks like we resend it.\"}, {\"type\":\"paragraph\",\"text\":\"Right now we won\u2019t allow it to resume. If we lack this behavior then I guess we should mandate retransmission on `shutdown`. At this point we will just resend it. If we come up and the thing is in co-op broadcast and we don\u2019t have the commitment transaction to broadcast we can just resend `shutdown`. That would fix the whole resume issue that we have right now.\"}, {\"type\":\"paragraph\",\"text\":\"The spec mandates that you remember `shutdown`. \u201cUpon reconnection: if it has sent a previous `shutdown` MUST retransmit `shutdown`\u201d. Technically it doesn\u2019t mandate that you remember if your counterparty sends it. Your counterparty could send it and you could have not sent it yourself. But in practice it mandates retransmission which mandates remembering that you were shutting down.\"}, {\"type\":\"paragraph\",\"text\":\"The usual fix is to commit locally before sending a message. Then you resend it upon reconnect. You can\u2019t force the other side to do it because a close message might have been lost. If we all just agree to resend a close on reconnect that should solve it.\"}, {\"type\":\"paragraph\",\"text\":\"We already store that we sent if so we can retransmit it. There\u2019s no other information you need really to retransmit after you\u2019ve sent one. I think that will resolve our quirk there?\"}, {\"type\":\"paragraph\",\"text\":\"Yeah.\"}, {\"type\":\"paragraph\",\"text\":\"I just commented on issue.\"}, {\"type\":\"paragraph\",\"text\":\"My next question was should `closing_signed` only be sent if there are no pending commitments?\"}, {\"type\":\"paragraph\",\"text\":\"That is already required. There has to be no pending anything for `closing_signed` to be sent. Can you specify your question a little more?\"}, {\"type\":\"paragraph\",\"text\":\"I think he means a dangling commitment. If I send one and you don\u2019t revoke yet can I send `closing_signed`? You have two commitments and you haven\u2019t revoked one of them. Is that the scenario?\"}, {\"type\":\"paragraph\",\"text\":\"Yeah it can be that the dangling commitment and your own local commitment are actually clear of any HTLCs.\"}, {\"type\":\"paragraph\",\"text\":\"You mean from the `update_fee`?\"}, {\"type\":\"paragraph\",\"text\":\"Yeah because the dangling commitment is an `update_fee`. Are we saying the `update_fee` hasn\u2019t been fully committed yet or something?\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, not locked in on both sides.\"}, {\"type\":\"paragraph\",\"text\":\"It shouldn\u2019t matter too much.\"}, {\"type\":\"paragraph\",\"text\":\"How does this interact with `shutdown`? You wouldn\u2019t enter shutdown until you had nothing pending?\"}, {\"type\":\"paragraph\",\"text\":\"It is saying if you are changing the fee, I don\u2019t know if you are allowed to do at that point.\"}, {\"type\":\"paragraph\",\"text\":\"You wouldn\u2019t have sent a `shutdown` if you had a pending fee update outstanding?\"}, {\"type\":\"paragraph\",\"text\":\"No but you could generate a fee update after you\u2019ve sent `shutdown`.\"}, {\"type\":\"paragraph\",\"text\":\"I think you are saying that that shouldn\u2019t be allowed. You should assume that you don\u2019t send anything new after you send `shutdown`.\"}, {\"type\":\"paragraph\",\"text\":\"It is awkward to not allow that though because you may have a HTLC that times out in 2 days. If you aren\u2019t allowed to do a fee update for 2 days while you are waiting on a HTLC to timeout that is kind of bad.\"}, {\"type\":\"paragraph\",\"text\":\"I thought the idea of sending a `shutdown` signals we are not updating this anymore.\"}, {\"type\":\"paragraph\",\"text\":\"The idea of `shutdown` is I\u2019m not going to add any more new HTLCs. Now we are just waiting for the HTLCs that are here to timeout before we do a `closing_signed`.\"}, {\"type\":\"paragraph\",\"text\":\"eclair opened an issue on our repo. Rather than postpone the shutdown we\u2019ll just say \u201cWe can\u2019t shutdown\u201d. Otherwise you get into an ambiguous state. Do you wait 2 days to send the `shutdown` with no feedback to the other party?\"}, {\"type\":\"paragraph\",\"text\":\"No you send the `shutdown` and then you wait for a `closing_signed`. That is what the spec says.\"}, {\"type\":\"paragraph\",\"text\":\"And then just waiting there potentially.\"}, {\"type\":\"paragraph\",\"text\":\"Yeah. `shutdown` says \u201cStop sending new stuff\u201d. Once the existing stuff gets resolved you do a `closing_signed`.\"}, {\"type\":\"paragraph\",\"text\":\"What\u2019s your HTLC case with `update_fee`? The reason that you\u2019d want to send it?\"}, {\"type\":\"paragraph\",\"text\":\"Once you send `shutdown` you are not adding new stuff but you could have a HTLC that doesn\u2019t timeout for quite some time. Yes you are about to do the `closing_signed` dance, you are about to do a co-op close, whatever, but you don\u2019t want to be in a state where you are not allowed to do an `update_fee` for 2 days while you are waiting for some HTLC to be resolved.\"}, {\"type\":\"paragraph\",\"text\":\"Something, something anchors so you don\u2019t care.\"}, {\"type\":\"paragraph\",\"text\":\"Anchors with package relay.\"}, {\"type\":\"paragraph\",\"text\":\"I think the answer is no. At that point you are waiting for the remote party to revoke. They have two different balances potentially. I think the answer is no, you should wait.\"}, {\"type\":\"paragraph\",\"text\":\"Ok. Everything clean?\"}, {\"type\":\"paragraph\",\"text\":\"But allow `update_fee` I guess.\"}, {\"type\":\"paragraph\",\"text\":\"That\u2019s the thing, you have no idea if everything is clean. Your counterparty might have sent a `commitment_signed` that you haven\u2019t received yet. Then you send a `closing_signed` and then you have to respond to the commitment transaction but you\u2019ve already sent a `closing_signed`.\"}, {\"type\":\"paragraph\",\"text\":\"For us we will remove the channel from the active set of forwarding stuff. If you sent a `commitment_signed` after we\u2019d sent `shutdown` it would get lost.\"}, {\"type\":\"paragraph\",\"text\":\"Certainly you have to be able to handle an update fulfil HTLC after shutdown.\"}, {\"type\":\"paragraph\",\"text\":\"We\u2019ll just disable the channel and make sure nothing routes to it.\"}, {\"type\":\"paragraph\",\"text\":\"You are not allowed to route anything new to it but you\u2019d handle an update fulfil.\"}, {\"type\":\"paragraph\",\"text\":\"You mean do we process a settle when are in the shutdown phase?\"}, {\"type\":\"paragraph\",\"text\":\"No.\"}, {\"type\":\"paragraph\",\"text\":\"That\u2019s not the intent of `shutdown`. The intent of `shutdown` is to declare an intent to stop adding new stuff. It sounds like you guys have implemented `shutdown` the way the spec intended `closing_signed` to be implemented.\"}, {\"type\":\"paragraph\",\"text\":\"At least we are saying you need to retransmit `shutdown` which seems to clear up some of these issues here and fixes a bug that we\u2019ve had for a long time to let people resume.\"}, {\"type\":\"paragraph\",\"text\":\"Yeah there is still definitely the question of how to handle fee updates post `shutdown` pre `closing_signed`. Do you mind taking an action item to try to draft an update to the section on `shutdown`?\"}, {\"type\":\"paragraph\",\"text\":\"Yeah. For `update_fee`?\"}, {\"type\":\"paragraph\",\"text\":\"The main thing here is should you allow `update_fee` after `shutdown` has been sent on both sides?\"}, {\"type\":\"paragraph\",\"text\":\"I guess the spec is clear already. It says \u201cThe only case where you are not allowed to send a new update is if there are no HTLCs\u201d. Once the HTLCs are gone you are not allowed to send an `update_fee`\u201d. I think that is clear. I don\u2019t see any immediate edge cases there.\"}, {\"type\":\"paragraph\",\"text\":\"I think that limitation to piggy back on top of `update_add_htlc` or remove HTLC should clarify that.\"}, {\"type\":\"paragraph\",\"text\":\"I don\u2019t think we implement this but you are allowed to send an `update_fee` as long as it is also with an update remove in the same `commitment_signed`.\"}, {\"type\":\"paragraph\",\"text\":\"You can\u2019t send it in isolation but you can send it when removing a HTLC.\"}, {\"type\":\"paragraph\",\"text\":\"Yes.\"}, {\"type\":\"paragraph\",\"text\":\"You definitely should allow removing generally because that can help you get a channel to a clean state.\"}, {\"type\":\"paragraph\",\"text\":\"You have to allow removing. I think the spec is clear. I don\u2019t have any questions here.\"}, {\"type\":\"paragraph\",\"text\":\"About fee, yeah ok but not about the pending commitment thing.\"}, {\"type\":\"paragraph\",\"text\":\"That needs a clarification. Do you mind trying to tackle that one?\"}, {\"type\":\"paragraph\",\"text\":\"I can do that.\"}, {\"type\":\"paragraph\",\"text\":\"I just [commented](https://github.com/lightning/bolts/issues/964#issuecomment-1067201164) on the issue. Number one, should you allow `update_fee` after shutdown has been sent but you still have HTLCs? Yes as long as there are HTLCs present. And it is packaged\u2026\"}, {\"type\":\"paragraph\",\"text\":\"I don\u2019t think it has to be packaged. It doesn\u2019t have to be packaged, there just has to be HTLCs.\"}, {\"type\":\"paragraph\",\"text\":\"You can send it if there are HTLCs?\"}, {\"type\":\"paragraph\",\"text\":\"Yes. There have to be HTLCs or it has to be packaged.\"}, {\"type\":\"heading\",\"text\":\"BOLT 1: introduce port convention for different networks\"}, {\"type\":\"paragraph\",\"text\":\"<https://github.com/lightning/bolts/pull/968>\"}, {\"type\":\"paragraph\",\"text\":\"I thought this was a non-standard port thing. Then I realized we already allow that. It is ports for different networks, mainnet, testnet etc.\"}, {\"type\":\"paragraph\",\"text\":\"You can do this today given we let you specify a port. It is kind of like adding a convention of using a different port for testnet. Funny how Litecoin is added there. Do people still support Litecoin? We kind of support it but not really.\"}, {\"type\":\"paragraph\",\"text\":\"Let\u2019s just drop the Litecoin part, I don\u2019t think we need it in BOLTs.\"}, {\"type\":\"paragraph\",\"text\":\"It is pretty broken in LND today. We broke it accidentally while we were doing some wallet stuff. I think someone has a fork somewhere. This sounds fine to me. It links to a bitcoind [PR](https://github.com/bitcoin/bitcoin/pull/23306) but I don\u2019t think that PR is related (Make AddrMan support multiple ports per IP). We already kind of have that.\"}, {\"type\":\"paragraph\",\"text\":\"I don\u2019t see how that is related.\"}, {\"type\":\"paragraph\",\"text\":\"I thought it was about letting people send out non 8333 port.\"}, {\"type\":\"paragraph\",\"text\":\"This is just convention, it seems fine. I left a comment on Litecoin and then I\u2019ll be fine with it.\"}, {\"type\":\"heading\",\"text\":\"BOLT 7: Onion message support\"}, {\"type\":\"paragraph\",\"text\":\"<https://github.com/lightning/bolts/pull/759>\"}, {\"type\":\"paragraph\",\"text\":\"Any updates here?\"}, {\"type\":\"paragraph\",\"text\":\"I don\u2019t Rusty is online.\"}, {\"type\":\"paragraph\",\"text\":\"I need to reply to his reply to my mailing list post.\"}, {\"type\":\"heading\",\"text\":\"Blinded fees\"}, {\"type\":\"paragraph\",\"text\":\"<https://github.com/lightning/bolts/pull/967>\"}, {\"type\":\"paragraph\",\"text\":\"Blinded fees, blinding more stuff. 967 is blinding more stuff in the blinded route itself. I guess including fees and CLTV, adding more data in the TLV I guess.\"}, {\"type\":\"paragraph\",\"text\":\"How does this work because you can\u2019t just add up the\u2026\"}, {\"type\":\"paragraph\",\"text\":\"How do you make the route?\"}, {\"type\":\"paragraph\",\"text\":\"You can make the route but it only works if there is a single hop. If you have two hops then you can\u2019t just add up the proportional and absolute fees and use them separately. You have to list the proportional and absolute fees. I haven\u2019t read the PR, does it require that you list them out?\"}, {\"type\":\"paragraph\",\"text\":\"For the CLTV you can at least increase your final hop delta whatever.\"}, {\"type\":\"paragraph\",\"text\":\"For the fees you can\u2019t just add them. You at least have to reveal how many hops there are.\"}, {\"type\":\"paragraph\",\"text\":\"Not even that works. With different fee schedules you can\u2019t compute that and it opens yourself up to being probed again by a strange fiddling of the fees.\"}, {\"type\":\"paragraph\",\"text\":\"I\u2019ll post on here does this work and let you compute fees properly?\"}, {\"type\":\"paragraph\",\"text\":\"Can you respond on the issue?\"}, {\"type\":\"paragraph\",\"text\":\"Sure.\"}, {\"type\":\"heading\",\"text\":\"Route blinding\"}, {\"type\":\"paragraph\",\"text\":\"<https://github.com/lightning/bolts/pull/765>\"}, {\"type\":\"paragraph\",\"text\":\"I guess this is related to the prior one? At least there is a new update to this one. Updating some notation.\"}, {\"type\":\"heading\",\"text\":\"Dual funding\"}, {\"type\":\"paragraph\",\"text\":\"<https://github.com/lightning/bolts/pull/851>\"}, {\"type\":\"paragraph\",\"text\":\"I don\u2019t have any immediate updates. There are still a few pending things that t-bast requested, making the reserve optional, that I need to get in. We are wrapping some stuff up for the next release. We\u2019ve also got someone who has started working on splicing in c-lightning. That is using the [draft](https://github.com/lightning/bolts/pull/863) that Rusty wrote up a while ago. It reuses a bunch of the stuff that we have in the dual funding, the interactive transaction protocol part to do the splicing. Hopefully we will have some more progress on that soon which is exciting.\"}, {\"type\":\"heading\",\"text\":\"Offers\"}, {\"type\":\"paragraph\",\"text\":\"<https://github.com/lightning/bolts/pull/798>\"}, {\"type\":\"paragraph\",\"text\":\"Offers, I saw there were some comments from Thomas from ACINQ. I\u2019m guessing still working on interop and stuff like that.\"}, {\"type\":\"heading\",\"text\":\"Add a max_dust_htlc_exposure_msat\"}, {\"type\":\"paragraph\",\"text\":\"<https://github.com/lightning/bolts/pull/919>\"}, {\"type\":\"paragraph\",\"text\":\"I\u2019m not sure this has legs still.\"}, {\"type\":\"paragraph\",\"text\":\"I updated the wording a while back based on Rusty\u2019s feedback.\"}, {\"type\":\"paragraph\",\"text\":\"The original feedback was that it was overly specific. Did you end up rewriting it to be less prescriptive and more just describing the issue?\"}, {\"type\":\"paragraph\",\"text\":\"Yeah I think so based on their feedback.\"}, {\"type\":\"paragraph\",\"text\":\"Re-request people to review.\"}, {\"type\":\"heading\",\"text\":\"Websocket address type: allow transport over RFC6455\"}, {\"type\":\"paragraph\",\"text\":\"Interop section, this web socket thing. I think Chrome enforces it, maybe Firefox and some other ones don\u2019t. That fragmentation probably makes it difficult to assume it is not there.\"}, {\"type\":\"paragraph\",\"text\":\"I think the solution to this is we need to drop the current design and replace it with a hostname. Have a flag to say \u201cI support SSL or TLS\u201d.\"}, {\"type\":\"paragraph\",\"text\":\"That\u2019s related to [PR 911](https://github.com/lightning/bolts/pull/911) that adds the hostname in the first place.\"}, {\"type\":\"paragraph\",\"text\":\"Yeah. I feel like we need to have a separate hostname but Rusty is not here so I\u2019m not going to try to declare how we should move forward, I\u2019ll let Rusty do it. We just need to have a hostname and you have to say \u201cYes I support SSL\u201d because it is going to be required.\"}, {\"type\":\"paragraph\",\"text\":\"That makes sense. The whole point of this is to do encryption in the plaintext web sockets but I guess that\u2019s not really a thing.\"}, {\"type\":\"paragraph\",\"text\":\"If you are going to proxy you might as well just proxy.\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, sure.\"}, {\"type\":\"heading\",\"text\":\"BOLT 7: add gossip address descriptor type DNS hostname\"}, {\"type\":\"paragraph\",\"text\":\"<https://github.com/lightning/bolts/pull/911>\"}, {\"type\":\"paragraph\",\"text\":\"This is also in waiting for interop section.\"}, {\"type\":\"paragraph\",\"text\":\"Hasn\u2019t it had interop? We haven\u2019t added it yet but I thought eclair had it though. t-bast isn\u2019t here.\"}, {\"type\":\"paragraph\",\"text\":\"I think they do. I know c-lightning has it. We have a similar feature that hacked around this but this is pretty straightforward.\"}, {\"type\":\"paragraph\",\"text\":\"We had a Summer of Bitcoin person open a PR but it needs a little love so we\u2019ll get it eventually.\"}, {\"type\":\"heading\",\"text\":\"Echo channel_type in accept_channel\"}, {\"type\":\"paragraph\",\"text\":\"<https://github.com/lightning/bolts/pull/960>\"}, {\"type\":\"paragraph\",\"text\":\"This came up in the zero conf discussion stuff, around making sure different modes could work. We got an ACK from Lisa. I think we already do this, it is just a thing to confirm on our end.\"}, {\"type\":\"paragraph\",\"text\":\"Was this the thing we were going back and forth on?\"}, {\"type\":\"paragraph\",\"text\":\"It is a thing we broke out.\"}, {\"type\":\"paragraph\",\"text\":\"I was confused. We always ack it back in the accept and I thought the existing language basically says that already. If you have the feature type set wouldn\u2019t you be sending it in `open_channel` in the first place anyway?\"}, {\"type\":\"paragraph\",\"text\":\"It is your counterparty not you right?\"}, {\"type\":\"paragraph\",\"text\":\"We checked it and it wasn\u2019t super clear so this is to make it more explicit.\"}, {\"type\":\"paragraph\",\"text\":\"If you negotiated the feature you have to send it in `open_channel` but somehow you could have ignored it in `accept_channel` and not have sent back anything. This would have been compliant with the spec but is obviously nonsensical.\"}, {\"type\":\"paragraph\",\"text\":\"My understanding of the spec and looking at the way it is implemented in c-lightning, if it is sent in `open_channel` we always send it back in `accept_channel`. That is because of the existing language in the spec, it should cover all those cases.\"}, {\"type\":\"paragraph\",\"text\":\"The existing language in the spec says that if you send it back you have to set it to the same thing. It doesn\u2019t say when you have to send it back.\"}, {\"type\":\"paragraph\",\"text\":\"If it is set you have to send it back?\"}, {\"type\":\"paragraph\",\"text\":\"No the spec doesn\u2019t say anything like that. It should.\"}, {\"type\":\"paragraph\",\"text\":\"If you don\u2019t echo it back you can just stop funding basically.\"}, {\"type\":\"paragraph\",\"text\":\"I thought the change was just to add an extra thing about the feature bit. It seems the thing you are actually trying to say is if it is in `open_channel` you should always echo it back.\"}, {\"type\":\"paragraph\",\"text\":\"The feature bit thing is trying to say \u201cIf it is in `open_channel` and you understood it and you support it then you should echo it back\u201d.\"}, {\"type\":\"paragraph\",\"text\":\"But you should always echo it back then?\"}, {\"type\":\"paragraph\",\"text\":\"If you understand it and you support it.\"}, {\"type\":\"paragraph\",\"text\":\"We had a few things where if they didn\u2019t send it we assumed that they liked what we had. At least if you send it it is more explicit.\"}, {\"type\":\"paragraph\",\"text\":\"Then it is a question of what\u2019s the behavior if they don\u2019t send it back. But that\u2019s not the part of the spec we\u2019re patching?\"}, {\"type\":\"paragraph\",\"text\":\"This PR is saying if they don\u2019t send it back you can just bail out.\"}, {\"type\":\"paragraph\",\"text\":\"Remember the history, the history was we did not have the feature bit at all in v1. In v1 of `channel_type` what happened was the initiator included it in `open_channel` and then either the `accept_channel` included the `channel_type` in which case they declared that they accept the channel type or they did not include the `channel_type` in which case you fallback to the classic behavior based on feature bits that exists. Then we added the `channel_type` feature and we said \u201cIf the `channel_type` feature has been negotiated you have to include it in `open_channel`\u201d but we didn\u2019t say anything about whether you had to accept it and include it in `accept_channel`. This is just saying \u201cThe feature bit is there. You definitely have to use the `channel_type` stuff and you can\u2019t ever fallback to the classic pseudo undefined logic of deciding the `channel_type` based on the features that exist.\"}, {\"type\":\"paragraph\",\"text\":\"I don\u2019t think we need to change the language on the top thing. If it is a `channel_type` you must set it to the `channel_type` for `open_channel` and that is a must.\"}, {\"type\":\"paragraph\",\"text\":\"The point is we want to declare that you have to use `channel_type` negotiation if you declare that you intend to use `channel_type` negotiation.\"}, {\"type\":\"paragraph\",\"text\":\"That is not what this PR does. This PR changes it from anytime the `channel_type` is set in `open_channel` you have to echo it back to only if the feature type was negotiated you have to echo it back. That seems like a downgrade from the current language.\"}, {\"type\":\"paragraph\",\"text\":\"To my understanding most of us already do this. It is just a matter of updating the spec to reflect our behavior. If you don\u2019t send it we\u2019ll reject.\"}, {\"type\":\"paragraph\",\"text\":\"I don\u2019t think we have to change it.\"}, {\"type\":\"paragraph\",\"text\":\"When the spec was written if both nodes set the `option_channel_type` feature node A sends a `channel_type` in `open_channel` and node B responds with an `accept_channel` without setting `channel_type` that is both completely well defined and is not an inference of acceptance of the `channel_type` that was declared. Instead it falls back to the init message, feature based `channel_type`.\"}, {\"type\":\"paragraph\",\"text\":\"We are trying to prevent that.\"}, {\"type\":\"paragraph\",\"text\":\"Yeah because that is dumb behavior but that is the way it is currently written.\"}, {\"type\":\"paragraph\",\"text\":\"Sure, that\u2019s my understanding as well. Right now if you send an `open_channel` with the `channel_type` and the other person sends `accept_channel` without the `channel_type` you are going back to the implicit feature bit.\"}, {\"type\":\"paragraph\",\"text\":\"You are not allowed to not send an `accept_channel` message without a `channel_type`.\"}, {\"type\":\"paragraph\",\"text\":\"It says \u201cIf it sets `channel_type`\u201d. It doesn\u2019t say that you must set `channel_type`.\"}, {\"type\":\"paragraph\",\"text\":\"The \u201cit\u201d here is the `open_channel` message. Maybe that is what is unclear. If the `open_channel` message sets a `channel_type` then you must set the `channel_type` from `open_channel`.\"}, {\"type\":\"paragraph\",\"text\":\"No \u201cit\u201d is the sender. The sender\u2026. sets `channel_type`.\"}, {\"type\":\"paragraph\",\"text\":\"I think that is weird wording. If it sets `channel_type` and \u201cit\u201d you are saying is the `open_channel` message so this is making it less ambiguous wording wise.  Now it is saying \u201cIf the `channel_type` is negotiated then you must set the `channel_type` from `open_channel.\u201d To me this is making it more explicit.\"}, {\"type\":\"paragraph\",\"text\":\"I see your understanding but I do not see how it refers to `open_channel`. The way that the specs are written is you have the top thing as the sender and then you have some bullet points. \u201cIt\u201d refers to the sender.\"}, {\"type\":\"paragraph\",\"text\":\"That\u2019s weird though right?\"}, {\"type\":\"paragraph\",\"text\":\"You just need this one bullet that says \u201cIf the `open_channel` sets the `channel_type` you must echo it back\u201d.\"}, {\"type\":\"paragraph\",\"text\":\"That is confusing given old nodes don\u2019t even know what these things are.\"}, {\"type\":\"paragraph\",\"text\":\"But the old node wouldn\u2019t send it back and then you would fail it because it was supposed to set it.\"}, {\"type\":\"paragraph\",\"text\":\"It wouldn\u2019t fail it. You\u2019d just fallback to the old style of negotiation.\"}, {\"type\":\"paragraph\",\"text\":\"There is no \u201cif the channel is not set\u201d.\"}, {\"type\":\"paragraph\",\"text\":\"If it is not set in `accept_channel` the intent is that you fallback to the old style pre `channel_type` negotiation, which is based on the feature flags in the init message.\"}, {\"type\":\"paragraph\",\"text\":\"We are trying to make it explicit that we don\u2019t want the fallback that you can reject if they try to do the fallback. That would less us delete a line or two from LND.\"}, {\"type\":\"paragraph\",\"text\":\"This update doesn\u2019t do that.\"}, {\"type\":\"paragraph\",\"text\":\"My reading is that it does. At the very bottom it says \u201cIf the `channel_type` was negotiated but the message doesn\u2019t include a `channel_type` you may reject the channel.\u201d I think it is referring to the receiver receiving the `accept_channel`. Now we are saying you can bail out so you don\u2019t have to do the weird implicit thing.\"}, {\"type\":\"paragraph\",\"text\":\"The original thing meant to have text of \u201cIt is a forward compatible change.\u201d That\u2019s part of why I read it that way. The initial wording was \u201cIt is forward compatible so if you don\u2019t set the `channel_type` it is implicitly falling back to the old style.\"}, {\"type\":\"paragraph\",\"text\":\"I re-approved it. I guess t-bast can potentially merge when he gets back.\"}, {\"type\":\"heading\",\"text\":\"Long term updates\"}, {\"type\":\"paragraph\",\"text\":\"I finished [MuSig2 stuff](https://github.com/btcsuite/btcd/pull/1820). Now it is fixing up the API, making it hard to re-use nonces, stuff like that.\"}",
    "body": "\nName: Lightning specification call\n\nTopic: Agenda below\n\nLocation: Jitsi\n\nVideo: No video posted online\n\nAgenda: <https://github.com/lightning/bolts/issues/969>\n\n# BOLT 4: Remove legacy format, make var_onion_optin compulsory\n\n<https://github.com/lightning/bolts/pull/962>\n\nI think eclair and c-lightning have both removed support for legacy payments.\n\nI\u2019ll probably make a PR to add the feature bit or at least flip it to required. The only wallet I can think of that is somewhat more fringe now is Simple Bitcoin Wallet. I am assuming they are doing the new stuff because they have some other hosted channel thing that adds custom fields.\n\n# BOLT 2: coop-closing clarification\n\n<https://github.com/lightning/bolts/issues/964>\n\nNext one is some questions around co-op close clarification. Do you allow people to send the co-op `closing_signed` message when HTLCs are there? What do we define as a clean slate when a co-op close transaction was able to move forward?\n\nThis is about shutdown not `closing_signed`.\n\nYou should only send the shutdown message once there are no uncommitted changes including fee updates. If you receive one early then you should just wait until the coast is clear to enter the second stage of co-op close negotiation.\n\nI have two more questions. One of my questions was if you get a shutdown or you send shutdown and then you reconnect should the state be cleared?\n\nGood question. This is something that we do right now. We need to fix it, we consider it a bug. If someone starts co-op close and the connection dies we won\u2019t allow any force close or co-op close to resume after that. Co-op close is weird in that if you send a signature to someone and then resume the channel they can broadcast at any point. That is something on the side that maybe we should add to the spec as well.\n\nIt shouldn\u2019t really matter. Once somebody sends shutdown if you care about the shutdown and you reconnect you should also resend the shutdown and then you are in the shutdown again.\n\nWhat if you don\u2019t send shutdown? That is one of my questions. Is that fine?\n\nIf nobody sends shutdown and then somebody sends `closing_signed`?\n\nNo if you send shutdown, reconnect and then don\u2019t send shutdown again and horde an HTLC.\n\nThat would be up to your counterparty. If your counterparty thinks you are in shutdown they will reject the HTLC. If your counterparty doesn\u2019t think they are in shutdown they will accept it. You are supposed to resend shutdown on reconnect? I don\u2019t actually know if we do.\n\nI don\u2019t think so. I think he is bringing up a point that a channel could get stuck. If one side sends it and the other side remembers it. I think what we do is we remember the shutdown and then if things didn\u2019t happen we won\u2019t let a co-op close happen. It is kind of like a bug.\n\nThe solution to this is we should resend shutdown right?\n\nYou\u2019d need to remember.\n\nIf you require that `shutdown` gets resent then on reconnect if one party remembered it they will resend and then you will be in shutdown. If neither party remembered it then no one will resend it and you won\u2019t be in shutdown. As long as you resend it would be fine.\n\nIf they don\u2019t resend and you don\u2019t remember you won\u2019t be in shutdown which is fine. If they do remember to send it and you don\u2019t you\u2019ll still send `shutdown`.\n\nYeah as long as the party that is remembering resends.\n\nI don\u2019t think it needs to be specified I guess.\n\nI\u2019m not 100 percent sure that resend `shutdown` is currently required but it clearly should be.\n\nLooking at our code, right now after we send a `shutdown` message we will commit that and stop the channel from being used altogether.\n\nWe do the same thing as you. We commit it async and we have it implemented in `channel_reestablish`. When we receive a `channel_reestablish` if we\u2019ve committed that and remembered that we have `shutdown` then we will resend that `shutdown` message and then we\u2019ll be in shutdown. It is not a concern as long as you have resend implemented. We may have a bug in it but according to the code it looks like we resend it.\n\nRight now we won\u2019t allow it to resume. If we lack this behavior then I guess we should mandate retransmission on `shutdown`. At this point we will just resend it. If we come up and the thing is in co-op broadcast and we don\u2019t have the commitment transaction to broadcast we can just resend `shutdown`. That would fix the whole resume issue that we have right now.\n\nThe spec mandates that you remember `shutdown`. \u201cUpon reconnection: if it has sent a previous `shutdown` MUST retransmit `shutdown`\u201d. Technically it doesn\u2019t mandate that you remember if your counterparty sends it. Your counterparty could send it and you could have not sent it yourself. But in practice it mandates retransmission which mandates remembering that you were shutting down.\n\nThe usual fix is to commit locally before sending a message. Then you resend it upon reconnect. You can\u2019t force the other side to do it because a close message might have been lost. If we all just agree to resend a close on reconnect that should solve it.\n\nWe already store that we sent if so we can retransmit it. There\u2019s no other information you need really to retransmit after you\u2019ve sent one. I think that will resolve our quirk there?\n\nYeah.\n\nI just commented on issue.\n\nMy next question was should `closing_signed` only be sent if there are no pending commitments?\n\nThat is already required. There has to be no pending anything for `closing_signed` to be sent. Can you specify your question a little more?\n\nI think he means a dangling commitment. If I send one and you don\u2019t revoke yet can I send `closing_signed`? You have two commitments and you haven\u2019t revoked one of them. Is that the scenario?\n\nYeah it can be that the dangling commitment and your own local commitment are actually clear of any HTLCs.\n\nYou mean from the `update_fee`?\n\nYeah because the dangling commitment is an `update_fee`. Are we saying the `update_fee` hasn\u2019t been fully committed yet or something?\n\nYeah, not locked in on both sides.\n\nIt shouldn\u2019t matter too much.\n\nHow does this interact with `shutdown`? You wouldn\u2019t enter shutdown until you had nothing pending?\n\nIt is saying if you are changing the fee, I don\u2019t know if you are allowed to do at that point.\n\nYou wouldn\u2019t have sent a `shutdown` if you had a pending fee update outstanding?\n\nNo but you could generate a fee update after you\u2019ve sent `shutdown`.\n\nI think you are saying that that shouldn\u2019t be allowed. You should assume that you don\u2019t send anything new after you send `shutdown`.\n\nIt is awkward to not allow that though because you may have a HTLC that times out in 2 days. If you aren\u2019t allowed to do a fee update for 2 days while you are waiting on a HTLC to timeout that is kind of bad.\n\nI thought the idea of sending a `shutdown` signals we are not updating this anymore.\n\nThe idea of `shutdown` is I\u2019m not going to add any more new HTLCs. Now we are just waiting for the HTLCs that are here to timeout before we do a `closing_signed`.\n\neclair opened an issue on our repo. Rather than postpone the shutdown we\u2019ll just say \u201cWe can\u2019t shutdown\u201d. Otherwise you get into an ambiguous state. Do you wait 2 days to send the `shutdown` with no feedback to the other party?\n\nNo you send the `shutdown` and then you wait for a `closing_signed`. That is what the spec says.\n\nAnd then just waiting there potentially.\n\nYeah. `shutdown` says \u201cStop sending new stuff\u201d. Once the existing stuff gets resolved you do a `closing_signed`.\n\nWhat\u2019s your HTLC case with `update_fee`? The reason that you\u2019d want to send it?\n\nOnce you send `shutdown` you are not adding new stuff but you could have a HTLC that doesn\u2019t timeout for quite some time. Yes you are about to do the `closing_signed` dance, you are about to do a co-op close, whatever, but you don\u2019t want to be in a state where you are not allowed to do an `update_fee` for 2 days while you are waiting for some HTLC to be resolved.\n\nSomething, something anchors so you don\u2019t care.\n\nAnchors with package relay.\n\nI think the answer is no. At that point you are waiting for the remote party to revoke. They have two different balances potentially. I think the answer is no, you should wait.\n\nOk. Everything clean?\n\nBut allow `update_fee` I guess.\n\nThat\u2019s the thing, you have no idea if everything is clean. Your counterparty might have sent a `commitment_signed` that you haven\u2019t received yet. Then you send a `closing_signed` and then you have to respond to the commitment transaction but you\u2019ve already sent a `closing_signed`.\n\nFor us we will remove the channel from the active set of forwarding stuff. If you sent a `commitment_signed` after we\u2019d sent `shutdown` it would get lost.\n\nCertainly you have to be able to handle an update fulfil HTLC after shutdown.\n\nWe\u2019ll just disable the channel and make sure nothing routes to it.\n\nYou are not allowed to route anything new to it but you\u2019d handle an update fulfil.\n\nYou mean do we process a settle when are in the shutdown phase?\n\nNo.\n\nThat\u2019s not the intent of `shutdown`. The intent of `shutdown` is to declare an intent to stop adding new stuff. It sounds like you guys have implemented `shutdown` the way the spec intended `closing_signed` to be implemented.\n\nAt least we are saying you need to retransmit `shutdown` which seems to clear up some of these issues here and fixes a bug that we\u2019ve had for a long time to let people resume.\n\nYeah there is still definitely the question of how to handle fee updates post `shutdown` pre `closing_signed`. Do you mind taking an action item to try to draft an update to the section on `shutdown`?\n\nYeah. For `update_fee`?\n\nThe main thing here is should you allow `update_fee` after `shutdown` has been sent on both sides?\n\nI guess the spec is clear already. It says \u201cThe only case where you are not allowed to send a new update is if there are no HTLCs\u201d. Once the HTLCs are gone you are not allowed to send an `update_fee`\u201d. I think that is clear. I don\u2019t see any immediate edge cases there.\n\nI think that limitation to piggy back on top of `update_add_htlc` or remove HTLC should clarify that.\n\nI don\u2019t think we implement this but you are allowed to send an `update_fee` as long as it is also with an update remove in the same `commitment_signed`.\n\nYou can\u2019t send it in isolation but you can send it when removing a HTLC.\n\nYes.\n\nYou definitely should allow removing generally because that can help you get a channel to a clean state.\n\nYou have to allow removing. I think the spec is clear. I don\u2019t have any questions here.\n\nAbout fee, yeah ok but not about the pending commitment thing.\n\nThat needs a clarification. Do you mind trying to tackle that one?\n\nI can do that.\n\nI just [commented](https://github.com/lightning/bolts/issues/964#issuecomment-1067201164) on the issue. Number one, should you allow `update_fee` after shutdown has been sent but you still have HTLCs? Yes as long as there are HTLCs present. And it is packaged\u2026\n\nI don\u2019t think it has to be packaged. It doesn\u2019t have to be packaged, there just has to be HTLCs.\n\nYou can send it if there are HTLCs?\n\nYes. There have to be HTLCs or it has to be packaged.\n\n# BOLT 1: introduce port convention for different networks\n\n<https://github.com/lightning/bolts/pull/968>\n\nI thought this was a non-standard port thing. Then I realized we already allow that. It is ports for different networks, mainnet, testnet etc.\n\nYou can do this today given we let you specify a port. It is kind of like adding a convention of using a different port for testnet. Funny how Litecoin is added there. Do people still support Litecoin? We kind of support it but not really.\n\nLet\u2019s just drop the Litecoin part, I don\u2019t think we need it in BOLTs.\n\nIt is pretty broken in LND today. We broke it accidentally while we were doing some wallet stuff. I think someone has a fork somewhere. This sounds fine to me. It links to a bitcoind [PR](https://github.com/bitcoin/bitcoin/pull/23306) but I don\u2019t think that PR is related (Make AddrMan support multiple ports per IP). We already kind of have that.\n\nI don\u2019t see how that is related.\n\nI thought it was about letting people send out non 8333 port.\n\nThis is just convention, it seems fine. I left a comment on Litecoin and then I\u2019ll be fine with it.\n\n# BOLT 7: Onion message support\n\n<https://github.com/lightning/bolts/pull/759>\n\nAny updates here?\n\nI don\u2019t Rusty is online.\n\nI need to reply to his reply to my mailing list post.\n\n# Blinded fees\n\n<https://github.com/lightning/bolts/pull/967>\n\nBlinded fees, blinding more stuff. 967 is blinding more stuff in the blinded route itself. I guess including fees and CLTV, adding more data in the TLV I guess.\n\nHow does this work because you can\u2019t just add up the\u2026\n\nHow do you make the route?\n\nYou can make the route but it only works if there is a single hop. If you have two hops then you can\u2019t just add up the proportional and absolute fees and use them separately. You have to list the proportional and absolute fees. I haven\u2019t read the PR, does it require that you list them out?\n\nFor the CLTV you can at least increase your final hop delta whatever.\n\nFor the fees you can\u2019t just add them. You at least have to reveal how many hops there are.\n\nNot even that works. With different fee schedules you can\u2019t compute that and it opens yourself up to being probed again by a strange fiddling of the fees.\n\nI\u2019ll post on here does this work and let you compute fees properly?\n\nCan you respond on the issue?\n\nSure.\n\n# Route blinding\n\n<https://github.com/lightning/bolts/pull/765>\n\nI guess this is related to the prior one? At least there is a new update to this one. Updating some notation.\n\n# Dual funding\n\n<https://github.com/lightning/bolts/pull/851>\n\nI don\u2019t have any immediate updates. There are still a few pending things that t-bast requested, making the reserve optional, that I need to get in. We are wrapping some stuff up for the next release. We\u2019ve also got someone who has started working on splicing in c-lightning. That is using the [draft](https://github.com/lightning/bolts/pull/863) that Rusty wrote up a while ago. It reuses a bunch of the stuff that we have in the dual funding, the interactive transaction protocol part to do the splicing. Hopefully we will have some more progress on that soon which is exciting.\n\n# Offers\n\n<https://github.com/lightning/bolts/pull/798>\n\nOffers, I saw there were some comments from Thomas from ACINQ. I\u2019m guessing still working on interop and stuff like that.\n\n# Add a max_dust_htlc_exposure_msat\n\n<https://github.com/lightning/bolts/pull/919>\n\nI\u2019m not sure this has legs still.\n\nI updated the wording a while back based on Rusty\u2019s feedback.\n\nThe original feedback was that it was overly specific. Did you end up rewriting it to be less prescriptive and more just describing the issue?\n\nYeah I think so based on their feedback.\n\nRe-request people to review.\n\n# Websocket address type: allow transport over RFC6455\n\nInterop section, this web socket thing. I think Chrome enforces it, maybe Firefox and some other ones don\u2019t. That fragmentation probably makes it difficult to assume it is not there.\n\nI think the solution to this is we need to drop the current design and replace it with a hostname. Have a flag to say \u201cI support SSL or TLS\u201d.\n\nThat\u2019s related to [PR 911](https://github.com/lightning/bolts/pull/911) that adds the hostname in the first place.\n\nYeah. I feel like we need to have a separate hostname but Rusty is not here so I\u2019m not going to try to declare how we should move forward, I\u2019ll let Rusty do it. We just need to have a hostname and you have to say \u201cYes I support SSL\u201d because it is going to be required.\n\nThat makes sense. The whole point of this is to do encryption in the plaintext web sockets but I guess that\u2019s not really a thing.\n\nIf you are going to proxy you might as well just proxy.\n\nYeah, sure.\n\n# BOLT 7: add gossip address descriptor type DNS hostname\n\n<https://github.com/lightning/bolts/pull/911>\n\nThis is also in waiting for interop section.\n\nHasn\u2019t it had interop? We haven\u2019t added it yet but I thought eclair had it though. t-bast isn\u2019t here.\n\nI think they do. I know c-lightning has it. We have a similar feature that hacked around this but this is pretty straightforward.\n\nWe had a Summer of Bitcoin person open a PR but it needs a little love so we\u2019ll get it eventually.\n\n# Echo channel_type in accept_channel\n\n<https://github.com/lightning/bolts/pull/960>\n\nThis came up in the zero conf discussion stuff, around making sure different modes could work. We got an ACK from Lisa. I think we already do this, it is just a thing to confirm on our end.\n\nWas this the thing we were going back and forth on?\n\nIt is a thing we broke out.\n\nI was confused. We always ack it back in the accept and I thought the existing language basically says that already. If you have the feature type set wouldn\u2019t you be sending it in `open_channel` in the first place anyway?\n\nIt is your counterparty not you right?\n\nWe checked it and it wasn\u2019t super clear so this is to make it more explicit.\n\nIf you negotiated the feature you have to send it in `open_channel` but somehow you could have ignored it in `accept_channel` and not have sent back anything. This would have been compliant with the spec but is obviously nonsensical.\n\nMy understanding of the spec and looking at the way it is implemented in c-lightning, if it is sent in `open_channel` we always send it back in `accept_channel`. That is because of the existing language in the spec, it should cover all those cases.\n\nThe existing language in the spec says that if you send it back you have to set it to the same thing. It doesn\u2019t say when you have to send it back.\n\nIf it is set you have to send it back?\n\nNo the spec doesn\u2019t say anything like that. It should.\n\nIf you don\u2019t echo it back you can just stop funding basically.\n\nI thought the change was just to add an extra thing about the feature bit. It seems the thing you are actually trying to say is if it is in `open_channel` you should always echo it back.\n\nThe feature bit thing is trying to say \u201cIf it is in `open_channel` and you understood it and you support it then you should echo it back\u201d.\n\nBut you should always echo it back then?\n\nIf you understand it and you support it.\n\nWe had a few things where if they didn\u2019t send it we assumed that they liked what we had. At least if you send it it is more explicit.\n\nThen it is a question of what\u2019s the behavior if they don\u2019t send it back. But that\u2019s not the part of the spec we\u2019re patching?\n\nThis PR is saying if they don\u2019t send it back you can just bail out.\n\nRemember the history, the history was we did not have the feature bit at all in v1. In v1 of `channel_type` what happened was the initiator included it in `open_channel` and then either the `accept_channel` included the `channel_type` in which case they declared that they accept the channel type or they did not include the `channel_type` in which case you fallback to the classic behavior based on feature bits that exists. Then we added the `channel_type` feature and we said \u201cIf the `channel_type` feature has been negotiated you have to include it in `open_channel`\u201d but we didn\u2019t say anything about whether you had to accept it and include it in `accept_channel`. This is just saying \u201cThe feature bit is there. You definitely have to use the `channel_type` stuff and you can\u2019t ever fallback to the classic pseudo undefined logic of deciding the `channel_type` based on the features that exist.\n\nI don\u2019t think we need to change the language on the top thing. If it is a `channel_type` you must set it to the `channel_type` for `open_channel` and that is a must.\n\nThe point is we want to declare that you have to use `channel_type` negotiation if you declare that you intend to use `channel_type` negotiation.\n\nThat is not what this PR does. This PR changes it from anytime the `channel_type` is set in `open_channel` you have to echo it back to only if the feature type was negotiated you have to echo it back. That seems like a downgrade from the current language.\n\nTo my understanding most of us already do this. It is just a matter of updating the spec to reflect our behavior. If you don\u2019t send it we\u2019ll reject.\n\nI don\u2019t think we have to change it.\n\nWhen the spec was written if both nodes set the `option_channel_type` feature node A sends a `channel_type` in `open_channel` and node B responds with an `accept_channel` without setting `channel_type` that is both completely well defined and is not an inference of acceptance of the `channel_type` that was declared. Instead it falls back to the init message, feature based `channel_type`.\n\nWe are trying to prevent that.\n\nYeah because that is dumb behavior but that is the way it is currently written.\n\nSure, that\u2019s my understanding as well. Right now if you send an `open_channel` with the `channel_type` and the other person sends `accept_channel` without the `channel_type` you are going back to the implicit feature bit.\n\nYou are not allowed to not send an `accept_channel` message without a `channel_type`.\n\nIt says \u201cIf it sets `channel_type`\u201d. It doesn\u2019t say that you must set `channel_type`.\n\nThe \u201cit\u201d here is the `open_channel` message. Maybe that is what is unclear. If the `open_channel` message sets a `channel_type` then you must set the `channel_type` from `open_channel`.\n\nNo \u201cit\u201d is the sender. The sender\u2026. sets `channel_type`.\n\nI think that is weird wording. If it sets `channel_type` and \u201cit\u201d you are saying is the `open_channel` message so this is making it less ambiguous wording wise.  Now it is saying \u201cIf the `channel_type` is negotiated then you must set the `channel_type` from `open_channel.\u201d To me this is making it more explicit.\n\nI see your understanding but I do not see how it refers to `open_channel`. The way that the specs are written is you have the top thing as the sender and then you have some bullet points. \u201cIt\u201d refers to the sender.\n\nThat\u2019s weird though right?\n\nYou just need this one bullet that says \u201cIf the `open_channel` sets the `channel_type` you must echo it back\u201d.\n\nThat is confusing given old nodes don\u2019t even know what these things are.\n\nBut the old node wouldn\u2019t send it back and then you would fail it because it was supposed to set it.\n\nIt wouldn\u2019t fail it. You\u2019d just fallback to the old style of negotiation.\n\nThere is no \u201cif the channel is not set\u201d.\n\nIf it is not set in `accept_channel` the intent is that you fallback to the old style pre `channel_type` negotiation, which is based on the feature flags in the init message.\n\nWe are trying to make it explicit that we don\u2019t want the fallback that you can reject if they try to do the fallback. That would less us delete a line or two from LND.\n\nThis update doesn\u2019t do that.\n\nMy reading is that it does. At the very bottom it says \u201cIf the `channel_type` was negotiated but the message doesn\u2019t include a `channel_type` you may reject the channel.\u201d I think it is referring to the receiver receiving the `accept_channel`. Now we are saying you can bail out so you don\u2019t have to do the weird implicit thing.\n\nThe original thing meant to have text of \u201cIt is a forward compatible change.\u201d That\u2019s part of why I read it that way. The initial wording was \u201cIt is forward compatible so if you don\u2019t set the `channel_type` it is implicitly falling back to the old style.\n\nI re-approved it. I guess t-bast can potentially merge when he gets back.\n\n# Long term updates\n\nI finished [MuSig2 stuff](https://github.com/btcsuite/btcd/pull/1820). Now it is fixing up the API, making it hard to re-use nonces, stuff like that.\n\n\n",
    "body_type": "markdown",
    "created_at": "2022-03-14T00:00:00.000Z",
    "domain": "https://btctranscripts.com/",
    "url": "https://btctranscripts.com/lightning-specification/2022-03-14-specification-call",
    "categories": [
        "meetup"
    ],
    "tags": [
        "lightning"
    ],
    "indexed_at": "2024-03-21T16:33:36.672Z",
    "transcript_by": "Michael Folkson",
    "summary": "In a recent gathering of minds within the Bitcoin and Lightning Network community, members delved deep into the intricacies of protocol enhancements, reflecting their unwavering commitment to bolstering the network's infrastructure. The discussions, marked by technical depth and collaborative spirit, covered a wide range of proposals aimed at refining and securing the Lightning Network, showcasing the dynamic nature of its development.\n\nOne of the focal points was the proposed modifications to BOLT 4, which included phasing out the legacy format in favor of making the var_onion_optin compulsory. This move aligns with the broader objective of modernizing the Lightning Network's protocols, evidenced by implementations like Eclair and c-lightning, which have already discontinued support for legacy payments. The proposal underscores the necessity of uniform adoption across the ecosystem, highlighting potential impacts on less mainstream wallets such as Simple Bitcoin Wallet and demonstrating the importance of inclusivity in these technological advancements.\n\nThe conversation also tackled nuances within cooperative channel closures as outlined in BOLT 2, particularly regarding the handling of the shutdown message in various scenarios. It was clarified that this message should only be dispatched once all pending updates, including fee adjustments, have been settled, ensuring a seamless transition into the shutdown state. This discussion brought to light the complex balance between flexibility and security in channel management protocols, emphasizing the need for clear communication and synchronized understanding between parties to avoid ambiguous states or stuck channels.\n\nAdditionally, the group explored the technicalities surrounding the `closing_signed` message, stressing that it should be sent only when there are no pending commitments. This part of the discussion highlighted the challenges of managing dangling commitments and the conditions under which `update_fee` messages are permissible post-shutdown, calling for clearer specifications to navigate these complexities effectively.\n\nAnother significant agenda item was the introduction of port conventions for different networks as outlined in BOLT 1. The proposal aims to standardize port usage across mainnet, testnet, and other networks, facilitating a more organized network infrastructure. This segment briefly touched upon the status of Litecoin within the Lightning Network, shedding light on the evolving landscape of supported cryptocurrencies and the focus on strengthening the Bitcoin-based ecosystem.\n\nThe discourse extended to Address Manager (AddrMan) support for multiple ports per IP and the distinction from allowing alternative ports besides the conventional 8333 for Bitcoin nodes. This differentiation highlights the importance of precision in protocol upgrades. Furthermore, discussions around onion message support, blinded fees, route blinding, dual-funding mechanisms, and the introduction of offers illustrated the ongoing efforts to enhance privacy, interoperability, and funding flexibility within the network.\n\nNotably, a proposal detailed in pull request #911 seeks to add DNS hostname support as a gossip address descriptor type within BOLT 7, aiming at improving node discovery and interoperation. This addition, along with considerations around `channel_type` in `accept_channel` messages, underscores the community's proactive approach to scalability, accessibility, and consistent implementation across different software.\n\nThese discussions encapsulate the collaborative, meticulous, and forward-thinking ethos of the Bitcoin and Lightning Network development communities. Each proposal and debate not only addresses current challenges but also lays the groundwork for future innovations, ensuring the networks remain secure, efficient, and adaptable to meet the evolving demands of digital currencies and their underlying technologies."
}