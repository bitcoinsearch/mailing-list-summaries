{
    "id": "bitcointranscripts+bitcoin-core-dev-tech+2023-04+2023-04-25-package-relay-primer",
    "title": "Package Relay Primer",
    "body_formatted": "{\"type\":\"paragraph\",\"text\":\"Slides: <https://docs.google.com/presentation/d/12YPlmmaCiNNL83b3FDmYwa7FKHP7yD0krzkEzM-tkTM>\"}, {\"type\":\"heading\",\"text\":\"Problems\"}, {\"type\":\"heading\",\"text\":\"CPFP Doesn\u2019t Work When Mempool Min Feerate Rises\"}, {\"type\":\"paragraph\",\"text\":\"Bad for users who want to use CPFP and L2s, but also a glaring limitation in our ability to assess transaction incentive compatibility\"}, {\"type\":\"heading\",\"text\":\"Pinning\"}, {\"type\":\"list\"}, {\"type\":\"heading\",\"text\":\"Pinning examples\"}, {\"type\":\"list\"}, {\"type\":\"list\"}, {\"type\":\"heading\",\"text\":\"Get rid of txid-based relay\"}, {\"type\":\"list\"}, {\"type\":\"heading\",\"text\":\"Definitions\"}, {\"type\":\"list\"}, {\"type\":\"heading\",\"text\":\"Why is there so much mempool code?\"}, {\"type\":\"list\"}, {\"type\":\"heading\",\"text\":\"Sub-projects and problems they solve\"}, {\"type\":\"list\"}, {\"type\":\"heading\",\"text\":\"Progress so far\"}, {\"type\":\"list\"}, {\"type\":\"heading\",\"text\":\"Open questions exist\"}, {\"type\":\"list\"}, {\"type\":\"heading\",\"text\":\"Walking through the BIP\"}, {\"type\":\"list\"}, {\"type\":\"paragraph\",\"text\":\"Should there be a limit on the number of transactions in getpkgtxns? Should there be a limit on the\\nnumber of transactions in ancpkginfo?\"}, {\"type\":\"list\"}, {\"type\":\"paragraph\",\"text\":\"`pkgtxns` should use the same order as `getpkgtxns`\"}, {\"type\":\"paragraph\",\"text\":\"`ancpkginfo` SHOULD sort topologically and include all unconfirmed ancestors and the tx itself.\\nHowever we cannot enforce this without matching chainstate.\"}, {\"type\":\"paragraph\",\"text\":\"The combined hash is lexicographic, so the same set of transactinos will always have the same identifier\"}, {\"type\":\"paragraph\",\"text\":\"`sendpackages` should perhaps specify how big an ancestor package would get accepted\\nalternatively, it should be left up to the receiver to deal with ancestor packages that are too large.\"}, {\"type\":\"paragraph\",\"text\":\"Looking for a different term for `pchCommand`\"}, {\"type\":\"paragraph\",\"text\":\"Q: How far is the pullrequest?\"}, {\"type\":\"paragraph\",\"text\":\"A: Tracking issue: <https://github.com/bitcoin/bitcoin/issues/27463>\\nsome of the earlier pieces are opened as PRs. persisting ancestor sets over restarts, p2p messages to negotiate package relay, handling orphans more reliably. There are\\nabout 5 more functional milestones to the whole project. One or two milestones per release seems reasonable.\"}, {\"type\":\"paragraph\",\"text\":\"Orphan handling should be made more robust, e.g. we request parent information from any peer that announced an orphan, and prefer outbound peers as the source.\"}, {\"type\":\"paragraph\",\"text\":\"Q: Could the P2P changes maybe all be activated on Signet together for testing?\"}, {\"type\":\"paragraph\",\"text\":\"A: Yes, there is a branch with the whole implementation already.\\nUnclear who needs it for testing, signet has a workaround (pseudo ephemeral anchors uses\\nprioritisetransaction) in the absence of package relay.\"}, {\"type\":\"paragraph\",\"text\":\"Mempool, Validation, Policy could be opened for merging in parallel to Orphan handling since different reviewers would be required.\"}, {\"type\":\"paragraph\",\"text\":\"The activation of the package relay feature would set a config option to default false which only would get set to true at the end of the last milestone.\"}, {\"type\":\"paragraph\",\"text\":\"Q: How does this interact with V3?\"}, {\"type\":\"paragraph\",\"text\":\"A: V3 would follow the activation of package relay.\"}, {\"type\":\"paragraph\",\"text\":\"Going into the Milestones:\"}, {\"type\":\"heading\",\"text\":\"Milestone 1\"}, {\"type\":\"list\"}, {\"type\":\"list\"}, {\"type\":\"list\"}, {\"type\":\"list\"}, {\"type\":\"heading\",\"text\":\"Milestone 2\"}, {\"type\":\"list\"}, {\"type\":\"paragraph\",\"text\":\"Idea 1: only protect one package per peer, or have a huge potential upper limit\"}, {\"type\":\"list\"}, {\"type\":\"paragraph\",\"text\":\"Idea 2: Hard limit globally to a number of bytes, when you go over limit, evict things from peer that has sent more than 2*maxTxSize\"}, {\"type\":\"paragraph\",\"text\":\"Idea 3: Token bucket per peer to limit exposure to bad packages\"}, {\"type\":\"paragraph\",\"text\":\"Idea 2 gets the most positive feedback.\"}, {\"type\":\"heading\",\"text\":\"Milestone 3\"}, {\"type\":\"paragraph\",\"text\":\"Add TxPackageTracker\"}, {\"type\":\"paragraph\",\"text\":\"Interface vision. This will be more interesting to discuss when looking at the code.\"}, {\"type\":\"paragraph\",\"text\":\"Rejection Caching\"}, {\"type\":\"paragraph\",\"text\":\"We need to continue downloading ancestor package information because someone could give you invalid information that could be superseded by correct information.\\nHowever, by keeping track of what we have gotten before, we would notice when we are offered the same invalid package or something that depends on something that was relayed previously.\"}",
    "body": "\nSlides: <https://docs.google.com/presentation/d/12YPlmmaCiNNL83b3FDmYwa7FKHP7yD0krzkEzM-tkTM>\n\n## Problems\n\n## CPFP Doesn\u2019t Work When Mempool Min Feerate Rises\n\nBad for users who want to use CPFP and L2s, but also a glaring limitation in our ability to assess transaction incentive compatibility\n\n## Pinning\n\n- being able to feebump transaction is a pinning concern\n- counterpart can intentionally censor your transactions, and in L2 that can mean stealing your money because you didn\u2019t meet the timelock\n\n### Pinning examples\n\n1. ANYONECANPAY -> anyonecanpin: add input that comes from huge unconfirmed low-fee rate tx -> absolute feerate needs to increase, so you're paying more fees for the tx to confirm slower\n2. shared descendant limit can be monopolized\n   1. descendant limit is 25 txs, so someone else can fill up that limit\n   1. we have a carve-out for CPFP already to try and mitigate that\n3. RBF Rule 3 is gameable\n   1. replacement fees must > all descendants, and they may be large, low feerate -> expensive\n\n- most L2s have pinning problems, so we need to fix that\n\n## Get rid of txid-based relay\n\n- we want to avoid txid based relay\n  - can't deduplicate txid and wtxid that correspond to the same tx\n  - can't deduplicate txs that only differ in witness\n- we still require txid-based relay for orphans, because txs specify prevouts by txid -> so we don't know which wtxid to request\n\n## Definitions\n\n- pinning attack: a censorship attack on relay/mempool level, abusing policy\n  - avoid getting into mempools\n  - staying in mempool but never getting mined\n  - a pinning attack is NOT paying more to get mined (even though it might be an attacker doing it, that's just a fee-based market)\n\n- package: any list of transactions that can be represented as a connected DAG\n- ancestor package: a package of 1 tx and its (unconfirmed) ancestors\n- Descendant package: (fill in from slides)\n- Package relay: relaying and validating packages together\n- Sender-initiated: a node proactively announces packages they think their peers should download and validate together\n  - in initial proposal: suggested announcing a child with all of its parents if assumed that peer does not have parents yet (e.g. becausee parents are toow low fee)\n- Receiver-initiated: nodes can request packages when they recognize they're missing something\n\n## Why is there so much mempool code?\n\n- Peers are not trusted to provide correct information.\n\n## Sub-projects and problems they solve\n\n- Package CPFP: mempool logic to allow descendants to allow for ancestors. Accept packages, allow a child to bump a parent past mempool min feerate. Solves \"CPFP doesn't work when mempools are full problem\"\n- P2P Package Relay: additional protocol msgs to request, provide, download package information on p2p network.\n- Package RBF: also allow a child to pay for parent's conflicts (treat as 1 aggregated tx). However, painful pinning attacks still exist.\n- v3 policy: for things that want robust RBF\n  - make it feasible for them to be 0-fee without introducing dos vectors\n- ephemeral anchors (built on top of v3) which allows anchors to be 0-value, which allows us to remove need for CPFP carve-out\n\n## Progress so far\n\n- we have:\n  - package cpfp\n- open:\n  - v3\n  - [#29633](https://github.com/bitcoin/bitcoin/pulls/29633) (looking for review)\n  - [#27463](https://github.com/bitcoin/bitcoin/issues/27463): overview of package relay\n    - also have a full branch for package relay\n\n## Open questions exist\n\n- how to make orphanage robust enough, currently 3 different approaches\n- make a new mempool.dat file?\n- do we want splice in/out to be covered by package relay/v3?\n  - yes, but need to look into whether current approach is sufficient\n\n## Walking through the BIP\n\n- `ancpkginfo` provides a transaction's ancestors\n- `getpkgtxns` allows the receiver to request any subset of the announced txs\n- shows how Package Relay fixes CPFP. does not rely on feefilters as long as you don't reject a\n  package because it contains a low fee tx.\n\nShould there be a limit on the number of transactions in getpkgtxns? Should there be a limit on the\nnumber of transactions in ancpkginfo?\n\n- we already bound the network message size (to 4M bytes of payload)\n- Could we ever generate a message that exceeds the limit?\n\n`pkgtxns` should use the same order as `getpkgtxns`\n\n`ancpkginfo` SHOULD sort topologically and include all unconfirmed ancestors and the tx itself.\nHowever we cannot enforce this without matching chainstate.\n\nThe combined hash is lexicographic, so the same set of transactinos will always have the same identifier\n\n`sendpackages` should perhaps specify how big an ancestor package would get accepted\nalternatively, it should be left up to the receiver to deal with ancestor packages that are too large.\n\nLooking for a different term for `pchCommand`\n\nQ: How far is the pullrequest?\n\nA: Tracking issue: <https://github.com/bitcoin/bitcoin/issues/27463>\nsome of the earlier pieces are opened as PRs. persisting ancestor sets over restarts, p2p messages to negotiate package relay, handling orphans more reliably. There are\nabout 5 more functional milestones to the whole project. One or two milestones per release seems reasonable.\n\nOrphan handling should be made more robust, e.g. we request parent information from any peer that announced an orphan, and prefer outbound peers as the source.\n\nQ: Could the P2P changes maybe all be activated on Signet together for testing?\n\nA: Yes, there is a branch with the whole implementation already.\nUnclear who needs it for testing, signet has a workaround (pseudo ephemeral anchors uses\nprioritisetransaction) in the absence of package relay.\n\nMempool, Validation, Policy could be opened for merging in parallel to Orphan handling since different reviewers would be required.\n\nThe activation of the package relay feature would set a config option to default false which only would get set to true at the end of the last milestone.\n\nQ: How does this interact with V3?\n\nA: V3 would follow the activation of package relay.\n\nGoing into the Milestones:\n\n## Milestone 1\n\n1. \"Don\u2019t allow anything below min relay feerate (#26933)\" was merged today. We generally don\u2019t allow transactions with an individual feerate below minRelayTxFee, but V3 will permit 0-fee txs as the parent, and CPFP can be used to get past the dynamic mempool minimum feerate.\n\n2. \"Persist CPFP\u2019d transactinos across restarts (#27476)\" Loading mempool.dat does not enforce minimum feerate on loading, but afterwards trims the mempool to the permitted size.\n\n- lots of discussion on importance and viability of the approach, PR to be deprioritized in the stack of work.\n- possibly just amend the mempool.dat format that can store package relationships\n- Just don\u2019t modify `TrimToSize()`\n\n3. validate package transactions with their in-package ancestor sets (#26711)\n\n- want to be able to handle something more complicated than single-parent-single-child\n- Allow any ancestor package\n- Be lenient on what you\u2019re provided with, e.g. take valid subsets of the package instead of rejecting the whole package if a part is inacceptable.\n- find largest permitted subset\n  \u2013 We defer Package RBF for the moment\n\n## Milestone 2\n\n- Orphanage is currently limited to 100 txs, up to 400 kB each\n- Problem: Peer can churn orphanage by sending a ton of orphans\n- Problem: does not effectively protect memory\n- We randomly evict when orphanage overflows, but we might not be anywhere close to the theoretical max\n\nIdea 1: only protect one package per peer, or have a huge potential upper limit\n\n- terrible performance, tons of packages are gonna be dropped\n\nIdea 2: Hard limit globally to a number of bytes, when you go over limit, evict things from peer that has sent more than 2*maxTxSize\n\nIdea 3: Token bucket per peer to limit exposure to bad packages\n\nIdea 2 gets the most positive feedback.\n\n## Milestone 3\n\nAdd TxPackageTracker\n\nInterface vision. This will be more interesting to discuss when looking at the code.\n\nRejection Caching\n\nWe need to continue downloading ancestor package information because someone could give you invalid information that could be superseded by correct information.\nHowever, by keeping track of what we have gotten before, we would notice when we are offered the same invalid package or something that depends on something that was relayed previously.\n\n",
    "body_type": "markdown",
    "created_at": "2023-04-25T00:00:00.000Z",
    "domain": "https://btctranscripts.com/",
    "url": "https://btctranscripts.com/bitcoin-core-dev-tech/2023-04/2023-04-25-package-relay-primer",
    "categories": [
        "core-dev-tech"
    ],
    "tags": [
        "bitcoin core",
        "package relay",
        "p2p"
    ],
    "authors": [
        "Gloria Zhao"
    ],
    "indexed_at": "2024-03-21T16:33:36.013Z",
    "summary": "In a recent exploration of the intricacies of Bitcoin's transaction mechanisms, Gloria Zhao delved into several pressing issues affecting user experience and network reliability. Central to her discussion was the challenge posed by Child Pays for Parent (CPFP) strategies during periods when the mempool's minimum fee rate escalates, highlighting a critical limitation in our capacity to evaluate transaction incentive compatibility. This problem not only impacts users desiring to leverage CPFP and Layer 2 solutions but also underscores a significant gap in understanding transaction dynamics under varying network conditions.\n\nPinning attacks emerged as another focal point, representing a form of censorship at the relay or mempool level that exploits policy to either prevent transactions from entering mempools or ensure they remain unmined. Such attacks pose serious risks, especially within Layer 2 frameworks, where they can lead to financial losses by exploiting transaction malleability to circumvent timelocks. Zhao provided examples illustrating how adversaries could manipulate transactions to increase fees or monopolize shared descendant limits, thereby hindering transaction confirmation and enabling potential theft.\n\nAddressing these vulnerabilities, Zhao advocated for transitioning away from txid-based relay systems, which suffer from inefficiencies like the inability to deduplicate transactions with identical txids or those differing only in witness data. Despite the necessity of txid-based relay for handling orphans\u2014transactions specifying previous outputs by txid\u2014the proposal signifies a move towards more secure and efficient transaction processing methods.\n\nThe introduction of package relay, encompassing both sender-initiated and receiver-initiated models, offers a promising solution to these challenges. By validating and relaying connected groups of transactions as packages, this approach aims to enhance the robustness of transaction handling, particularly in mitigating pinning risks and improving CPFP functionalities. Sender-initiated package announcements and receiver-initiated requests for missing information mark a significant shift towards a more interconnected and cooperative transaction validation process.\n\nZhao's presentation further outlined ongoing sub-projects aimed at refining Bitcoin's transaction ecosystem. Notably, these include enhancements to CPFP mechanisms to support package acceptance in full mempools, P2P package relay protocols for efficient information exchange, and revisions to replace-by-fee (RBF) policies to accommodate complex transaction scenarios without introducing denial-of-service vulnerabilities. Additionally, ephemeral anchors and a proposed v3 policy underscore efforts to enable zero-fee transactions in specific contexts, eliminating the need for CPFP carve-outs and potentially reducing the risk of pinning attacks.\n\nProgress on these initiatives is underway, with certain components already implemented and others, such as comprehensive package relay mechanisms and robust orphan handling strategies, in active development. As these projects advance through planned milestones\u2014including refining mempool policies, enhancing orphan management, and establishing effective rejection caching\u2014they promise to address longstanding issues within Bitcoin's transaction processing framework, laying the groundwork for a more resilient, efficient, and user-friendly network."
}