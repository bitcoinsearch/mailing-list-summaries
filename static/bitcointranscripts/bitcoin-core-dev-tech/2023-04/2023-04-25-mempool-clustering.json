{
    "id": "bitcointranscripts+bitcoin-core-dev-tech+2023-04+2023-04-25-mempool-clustering",
    "title": "Mempool Clustering",
    "body_formatted": "{\"type\":\"heading\",\"text\":\"Current Problems\"}, {\"type\":\"paragraph\",\"text\":\"lot of problems in the mempool\"}, {\"type\":\"list\"}, {\"type\":\"heading\",\"text\":\"Eviction\"}, {\"type\":\"list\"}, {\"type\":\"heading\",\"text\":\"Mining algorithm has problems\"}, {\"type\":\"list\"}, {\"type\":\"heading\",\"text\":\"RBF\"}, {\"type\":\"list\"}, {\"type\":\"paragraph\",\"text\":\"\\\"so let's do that\\\"\"}, {\"type\":\"heading\",\"text\":\"TOTAL ORDERING\"}, {\"type\":\"list\"}, {\"type\":\"heading\",\"text\":\"Definitions\"}, {\"type\":\"list\"}, {\"type\":\"heading\",\"text\":\"Steps:\"}, {\"type\":\"list\"}, {\"type\":\"list\"}, {\"type\":\"heading\",\"text\":\"chunks\"}, {\"type\":\"paragraph\",\"text\":\"Given a linearization, we can calculate where the chunk breaks are, where we pick txs into the block. We always start at beginning, but only go in as far as you want to go to maximize fee rate. Look at all the prefixes to pick highest fee rate, everything is safe to cut off, but where is the most optimal cut point\u2026 always start on the left.\"}, {\"type\":\"heading\",\"text\":\"Chunk Example\"}, {\"type\":\"list\"}, {\"type\":\"heading\",\"text\":\"How do we calculate the chunks\"}, {\"type\":\"paragraph\",\"text\":\"Starting at the left, calculate fee rate as you go in to the block (moving to the right) fee rates go up, then down (stop at the peak point). For every prefix, you compute fee rate for each prefix\\nthen see which prefix has the highest fee rate.\\n(It\u2019s n values, not 2^n values because we respect the linearization sort)\"}, {\"type\":\"paragraph\",\"text\":\"1st chunk has been selected, now we look at fee rates for txs after the first chunk.\\n\u201cexample looks quadratic, but it is actually a linear algorithm\u201d\"}, {\"type\":\"heading\",\"text\":\"Back to Mining\"}, {\"type\":\"list\"}, {\"type\":\"heading\",\"text\":\"RBF policy\"}, {\"type\":\"list\"}, {\"type\":\"heading\",\"text\":\"\\\"What about RBF carve out?\\\"\"}, {\"type\":\"list\"}, {\"type\":\"heading\",\"text\":\"Revisiting Our Problems\"}, {\"type\":\"list\"}, {\"type\":\"heading\",\"text\":\"Open Questions I\"}, {\"type\":\"list\"}, {\"type\":\"heading\",\"text\":\"Open Questions II\"}, {\"type\":\"list\"}, {\"type\":\"paragraph\",\"text\":\"\\\"next block fee rate\\\" can be confusing now too, and coin selection gets harder if you're spending unconfirmed coins:\"}, {\"type\":\"list\"}, {\"type\":\"paragraph\",\"text\":\"3rd parties cant make your tx score worse, only better\"}, {\"type\":\"list\"}, {\"type\":\"paragraph\",\"text\":\"Optimal Sort vs Ancestor Sort\"}, {\"type\":\"list\"}, {\"type\":\"paragraph\",\"text\":\"Could there be a problem introducing non-determinism to the network?\"}, {\"type\":\"list\"}, {\"type\":\"paragraph\",\"text\":\"We had a hard time coming up with examples in which our mining algorithms don't do the right thing.\"}, {\"type\":\"paragraph\",\"text\":\"Maybe we can even relay sorted clusters, maybe someone has a better sort than you, let\u2019s share it\"}, {\"type\":\"paragraph\",\"text\":\"A new tx comes in, we could just throw it on the end of its cluster and then re-linearize later. i.e. have multiple linearizations for same cluster, then merge them together.\"}, {\"type\":\"heading\",\"text\":\"Open Questions III\"}, {\"type\":\"list\"}, {\"type\":\"heading\",\"text\":\"Future Work\"}, {\"type\":\"list\"}, {\"type\":\"heading\",\"text\":\"DEMO time\"}, {\"type\":\"paragraph\",\"text\":\"y axis: total cumulative fee\\nx axis: total vBytes\\n\\\"lol someones paying huge fees right now, messing up the chart!\\\"\\\"\"}, {\"type\":\"paragraph\",\"text\":\"`getblocktemplate` is much faster with this\"}",
    "body": "## Current Problems\n\nlot of problems in the mempool\n\n1. eviction is broken\n2. mining algorithm is part of the problem, it\u2019s not perfect\n3. RBF is like totally broken we complain all the time, sometimes we do/don't RBF when we should/shouldn't\n\n## Eviction\n\n- Eviction is when mempool is full, and we want to throw away the worst tx.\n- Example, we think a tx is worst in mempool but it\u2019s a descendant of a \"good\" tx.\n- Mempool eviction is kinda the opposite of the mining algorithm.\n- For example the first thing you'd evict may be the first tx you'd mine\n- The first thing you'd evict is the small fee parent, but its descendant fee rate is desirable for mining.\n\n## Mining algorithm has problems\n\n- Mining algorithm is something we can't run in reverse\n- What you wanna do is run mining algorithm on whole mempool - look at top for block, bottom for eviction, but this won\u2019t work because of processing time.\n\n- We don't know what fee rate tx will be included in blocks.\n- The current mining algorithm is quadratic - infeasible for mempool eviction\n\n## RBF\n\n- Compare incoming fee rate tx with conflicting tx\n- We do NOT look at the child tx fee rates\n  - PR [#26451](https://github.com/bitcoin/bitcoin/pull/26451) starts to fix this\n- BIP125 rules are a bit silly (e.g. no new unconfirmed parents)\n- None of the fee rates we talk about in mempool tell us where a tx will end up in a block\n\n\"so let's do that\"\n\n## TOTAL ORDERING\n\n- These are improvements to block mining will also then improve mempool eviction, etc\n- This should make RBF much much better\n- Eliminate the uncertainty about how good a tx is\n- We can compare 2 txs and decide which is better\n- It won\u2019t totally solve pinning, total fee rate rule is still an issue, v3 relay addresses that\n\n- \"obvious\" solution - at all points in time, sort mempool\n- ancestor fee rate solution is already n^2, optimal algorithm is clearly exponential, so that wouldn't work to run on whole mempool\n\n- why don't we just limit size of connected components of mempool?\n- Imagine the mempool is a graph, edges between parent/child txs\n- Sort each connected component separately, then do something simple to merge all those together\n\n- Clusters can\u2019t affect each other because they are not connected\n\n- Run quadratic algorithm on every connected component of the mempool\n\n- This introduces a new policy rule\n- Today there is no cluster limit, entire mempool could just be one huge cluster\n\n- \u201cIntroducing\u201d: cluster size limit. Is this something users can deal with?\n- It could mean unrelated people have txs related by cluster\n\n- Right now there is max 25 ancestor count\n- We would probably still need an ancestor limit, but maybe not need a descendant limit anymore\n- We might need some kind of carve out like CPFP too\n\n## Definitions\n\n- cluster: set of txs connected in graph\n- linearization: any topologically valid sort of txs in mempool\n\n- normally we talk about it within a cluster\n- block building is linearization as well\n- lots of ways to do this (ancestor feerate-based algorithm is what we use today)\n\n- f(cluster) -> linearization\n- This tells you in what order to include things\n\n## Steps:\n\n1. Identify clusters in mempool\n2. linearize each cluster\n3. ?\n\n- hard part is done, we figured out the best strategy for all the dependencies\n- block template - use that information to pull off the best fee rate parts of each cluster until block is full\n\n## chunks\n\nGiven a linearization, we can calculate where the chunk breaks are, where we pick txs into the block. We always start at beginning, but only go in as far as you want to go to maximize fee rate. Look at all the prefixes to pick highest fee rate, everything is safe to cut off, but where is the most optimal cut point\u2026 always start on the left.\n\n## Chunk Example\n\n- where could this linearization have come from?\n- Once you have the linearization, the original graph doesn't matter any more\n- The linearization function adds redundant dependencies\n\n## How do we calculate the chunks\n\nStarting at the left, calculate fee rate as you go in to the block (moving to the right) fee rates go up, then down (stop at the peak point). For every prefix, you compute fee rate for each prefix\nthen see which prefix has the highest fee rate.\n(It\u2019s n values, not 2^n values because we respect the linearization sort)\n\n1st chunk has been selected, now we look at fee rates for txs after the first chunk.\n\u201cexample looks quadratic, but it is actually a linear algorithm\u201d\n\n## Back to Mining\n\n- We get our clusters, we linearize the clusters\n- (what do you do when you violate sigops limit ?!) we need a heuristic to prevent that from happening, i.e. use a modifier to multiply * tx size if we think the tx has more sigops than we think it should have. It\u2019s significantly harder to include sigops because then you're optimizing for two values not just one.\n\n- The problem still gets knapsack-y towards the end, maybe use packages that are small relative to the block\n\n- Anyway, eviction is now the EXACT opposite of the mining algorithm.\n\n- Chunks are usually descending in fee rate, because if they weren't - you would have merged those in to one chunk. Top chunk will be highest fee rate in the cluster. So for eviction, look at the last chunk in each cluster, therefore we evict the last things we would mine.\n\n- The mempool always organizes chunks, mining picks top chunks, eviction picks bottom chunks.\nWithin a cluster, chunks are always decreasing fee rate. We can think of the mempool as just one giant list of chunks. We maintainthe data structure in mempool all the time, as new txs come in.\n\n## RBF policy\n\n- We ensure that chunk feerate of new thing is better than chunk fee rate of everything that would be evicted. By talking about chunk fee rate, we are using same score the mining algorithm uses. For a new tx, you look if it has parents and grab all the clusters. A new tx can merge clusters together. Throw new tx into the cluster, sort it, figure out which chunk new tx would be in, then you already have the mining scores of everything about to be evicted.\n\n- So we can create a new mini mempool (just a fake virtual cluster) for each new incoming tx to test its cluster properties.\n\n## \"What about RBF carve out?\"\n\n- Virtual cluster is affected by cluster size limit as well. Each new incoming tx might merge clusters into a too-big cluster.\n\n- Higher fee rate, higher total fee, we still need these rules for network DoS\n- When you evict something, you need to re-linearize the cluster. We still need some kind of limit so we don't have to re-sort the whole mempool when RBF happens. The clusters don't have an ordering with respect to each other. We only sort the clusters during mining or eviction, but maybe we can optimize the tracking best chunk of each cluster.\n\n- Each tx has its own chunk fee rate based on which chunk it appears in based on the cluster its in. This is its individual score, used for RBF.\n\n## Revisiting Our Problems\n\n- We no longer have asymmetry between mining & eviction\n- If we limit cluster size enough maybe we could run the mining algorithm on the cluster\n\n- \"if you want to get your tx mined, don't make a cluster\" ?\n- It\u2019s no longer simple to RBF your txs anymore. It doesn't matter though, people follow simple rules: \"if you're paying more it'll get picked.\u201d So\u2026 linearization algorithms should allow what people typically will do, maybe they CPFP with a few children. After that, it\u2019s just about attack prevention. Can an attacker create a cluster that triggers not-incentive-compatible behavior?\nAn attacker can throw your tx into a large cluster.\n\n## Open Questions I\n\n- BIP 125 was rules and terms that users could understand, that produce deterministic results. You could tell ahead of time what will work, but yes you need a mempool to do so. This new approach is more opaque, running an expensive algorithm on the cluster, sorting, etc - turns the algorithm into a black box. We could have an RPC that returns the scores\u2026 BIP125 is already too hard to model, and it\u2019s not incentive compatible. The thing that people do: \u201cbumpfee, bumpfee, bumpfee\u201d until it relays.\n\n- \"What is the cost of memory usage for this algorithm?\"\n  - We don't know, probably negligible.\n\n- Just because we see large clusters doesn't mean anyone really needs them. Its probably OK to split up clusters between blocks. A cluster limit is worse than a descendant limit, but if you risk running in to one, you risk running in to the other.\n\n- Maybe a user wants to fee-bump two separate txs but by bumping them, it joins two clusters together which now violates the limit. (open question)\n\n- Maybe cluster limit is like 50 or 100, replacing descendant limit of 25\n\n## Open Questions II\n\n- sibling limit\n- simple: reject anything that would bust cluster limit\n- We\u2019re punting on sibling eviction for now - could be another pinning attack where attacker can evict your tx by merging clusters, and we still have to manage total relay fee.\n\n\"next block fee rate\" can be confusing now too, and coin selection gets harder if you're spending unconfirmed coins:\n\n- Wallet need to figure out what cluster each coin is in\n- Choosing coin A might re-score coin B that I might also want to use\n- \"That cluster is full so you can\u2019t spend from it at all\", etc\n\n3rd parties cant make your tx score worse, only better\n\n- When attaching more children, the parent tx can only get better score (until cluster limit is reached)\n\nOptimal Sort vs Ancestor Sort\n\n- maybe differently sized clusters get handed differently\n- maybe miners optimize how they sort clusters better than relay nodes\n\nCould there be a problem introducing non-determinism to the network?\n\n- Are we going to break more stuff?\n- The non-determinism doesn't matter, what matters is the baseline of what we guarantee:\n- For example, we run the ancestor algorithm always, and then sometimes we do more\n- Then no real use case can rely on anything higher than that bar\n\nWe had a hard time coming up with examples in which our mining algorithms don't do the right thing.\n\nMaybe we can even relay sorted clusters, maybe someone has a better sort than you, let\u2019s share it\n\nA new tx comes in, we could just throw it on the end of its cluster and then re-linearize later. i.e. have multiple linearizations for same cluster, then merge them together.\n\n## Open Questions III\n\n- We take the worst chunk across all clusters and evict that chunk.\n- \"free relay problem\" - if you can evict a chunk using only one new incoming tx, that\u2019s bad.\n- Maybe we need a chunk size limit and a cluster size limit\n- We still need ancestor size limit currently its 101 kvb?\n\n## Future Work\n\n- Solve cluster size limits\n- Downstream effects: positive impact on package relay and package validation\n- Maybe we need to reconsider fee estimation overall (fee estimation is broken because of CPFP)\n\n## DEMO time\n\ny axis: total cumulative fee\nx axis: total vBytes\n\"lol someones paying huge fees right now, messing up the chart!\"\"\n\n`getblocktemplate` is much faster with this\n\n",
    "body_type": "markdown",
    "created_at": "2023-04-25T00:00:00.000Z",
    "domain": "https://btctranscripts.com/",
    "url": "https://btctranscripts.com/bitcoin-core-dev-tech/2023-04/2023-04-25-mempool-clustering",
    "categories": [
        "core-dev-tech"
    ],
    "tags": [
        "cluster-mempool"
    ],
    "authors": [
        "Suhas Daftuar",
        "Pieter Wuille"
    ],
    "indexed_at": "2024-03-21T16:33:36.011Z",
    "summary": "In a recent discussion, Suhas Daftuar and Pieter Wuille delved into the intricacies of Bitcoin's mempool management, focusing on the challenges of eviction, mining algorithms, and Replace-By-Fee (RBF) mechanics. They outlined the current problems plaguing the system, such as the inefficient process of transaction eviction when the mempool is full, the imperfections in the mining algorithm, and the flawed execution of RBF.\n\nThe conversation began with an examination of eviction, highlighting its critical role in managing the mempool by discarding the least desirable transactions. However, the speakers noted the paradoxical nature of this process, where the criteria for eviction often contradict what would be ideal for mining. This issue stems from the difficulty in reversing the mining algorithm to apply it effectively for eviction purposes, given the computational intensity and the quadratic complexity involved.\n\nTurning their attention to the mining algorithm itself, Daftuar and Wuille discussed its limitations, particularly its inability to efficiently predict transaction fee rates for block inclusion due to its quadratic nature. This complexity makes it impractical to run the algorithm in reverse for mempool eviction, leading to inefficiencies and uncertainties in transaction handling.\n\nThe dialogue then shifted to the flaws within the RBF mechanism, specifically the oversight of not considering child transaction fee rates during conflict resolution. They referenced a proposed improvement (PR #26451) aimed at addressing this shortfall. The speakers also critiqued the rigidity of BIP125 rules, which add to the confusion regarding transaction prioritization in the mempool.\n\nA significant portion of the discussion was dedicated to proposing a new approach called \"Total Ordering,\" aimed at resolving these issues by enhancing block mining and, consequently, improving mempool eviction and RBF functionality. This method involves sorting the mempool at all times and introducing a cluster size limit to manage the connected components of the mempool more effectively. By organizing each cluster separately and merging them through a simplified process, the approach aims to mitigate the impact of large transaction clusters on the mempool\u2019s efficiency.\n\nDaftuar and Wuille elaborated on the technical aspects of implementing this strategy, including identifying clusters within the mempool, linearizing each cluster, and optimizing chunk selection for block construction. They emphasized the potential benefits of this approach, such as the precise identification of optimal transaction subsets for inclusion in a block and the simplification of the eviction process by targeting the lowest priority chunks within each cluster.\n\nFurthermore, the speakers discussed the implications of this new policy on RBF, suggesting improvements that could make the mechanism more predictable and equitable. By evaluating transactions based on their chunk fee rate within their respective clusters, the updated RBF policy could offer a more transparent and fair assessment for transaction replacement.\n\nAddressing potential concerns and open questions, Daftuar and Wuille acknowledged the complexities and possible trade-offs involved in implementing the Total Ordering strategy. These include the challenge of managing cluster sizes, the impact on sibling transactions, and the broader effects on network dynamics and fee estimation practices.\n\nIn conclusion, the discussion between Suhas Daftuar and Pieter Wuille presented a comprehensive analysis of the current challenges in Bitcoin's mempool management and proposed a novel solution to enhance efficiency and fairness in transaction processing. Through the Total Ordering approach and its emphasis on organized mempool structure and improved RBF policies, they offered a promising avenue for addressing longstanding issues and optimizing Bitcoin's transaction handling mechanisms."
}