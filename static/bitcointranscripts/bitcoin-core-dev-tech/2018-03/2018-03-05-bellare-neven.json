{
    "id": "bitcointranscripts+bitcoin-core-dev-tech+2018-03+2018-03-05-bellare-neven",
    "title": "Bellare-Neven",
    "body_formatted": "{\"type\":\"paragraph\",\"text\":\"See also <http://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2017-09-06-signature-aggregation/>\"}, {\"type\":\"paragraph\",\"text\":\"It's been published, it's been around for a decade, and it's widely cited. In Bellare-Neven, it's itself, it's a multi-signature scheme which means multiple pubkeys and one message. You should treat the individual authorizations to spend inputs, as individual messages. What we need is an interactive aggregate signature scheme. Bellare-Neven's paper suggests a trivial way of building an aggregate signature scheme out of a multisig scheme where interactively everyone signs everyone's message. We found a vulnerability in this scheme, it's very subtle.\"}, {\"type\":\"paragraph\",\"text\":\"Russell O'Connor came up with this attack. Say you have two outputs with the same key, already a problem, but we can't prevent that. You want to participate in the coinjoin with me where you're just trying to spend one of them and not the other. So we have three UTXOs, and we'll also talk about the messages for each of those UTXOs, messages that authorize the spending of those outputs. Assume these are single input things. And we're trying to do a coinjoin for two of the messages, and I'm trying to steal this output from you. It's explained in the musig paper actually. In short, I am going to participate in the multisignature protocol, so the Bellare-neven lifted to an interactive aggregate signature protocol where I prented my key, where I pretend to have your key and your message, and I will eat the nonce you come up with. I just repeat this, act as a mirror, you say your key is this, and I say my key says this, and you say your nonce and I say a nonce; ther'es a more advanced version where I can hide it actually. I assume you don't validate the message I am trying to sign- that's the key point. In aggregate signature scheme, everyone has their own message, and you should not care which message someone is trying to sign; it should be impossible for anyone to sign with the other key..... the messages will be the same, the two hashes will be the same, between what you think I am going to sign and what I'm actually signing-- I am not saying which of the two we are. With the index, it's secure. Without the index, it's insecure. Bellare-neven has iactually specified this way- in the hash is the list of all the keys, and then your key yourself, but it doesn't say hwat index in that it list it is. The problem is that if those keys are the same, I can use your hash for the first one, and repeat it, and if p1 and p2 are the same, if these two things are the same, while if I'm signing p1 and p2, and ... this doesn't work. We're going to sign a multisignature with 2 times the key value.. if I'm not using the index, then the two things are exactly the same hash, and as a result your partial signature and double it, and it's now a valid signature for both. So the solution is to use an index, and not the public keys. You have to force people to put the indexes.\"}, {\"type\":\"paragraph\",\"text\":\"The advantage of not having indices is that, you're ordering, your local ordering. You just say, this, you do a lexicographic sort on the pubkeys, but you see this as the serialization of your keys, you don't need to have an idea of the ordering of the keys, and in Bellare-Neven paper... all the indices are local indices that don't have to correspond to the other parties indices, and this results in Russell's attacks. It's a very theoretical advantage to have only local indices anyway... I would very much like to see a proof that this construction actually solves this problem. This aspect of converting a multisig scheme into an interactive aggregate signature scheme does not come with a proof in the paper.\"}, {\"type\":\"paragraph\",\"text\":\"You could also fix it by saying never permit reusing a partial signature if any of the other participants claim to have your pubkey. This is also a sufficient fix I think. But I don't trust implementations to do that correctly.\"}, {\"type\":\"paragraph\",\"text\":\"Say you have tuples of the keys and messages. You lexicographically sort those tuples. And then say L is the hash of that whole thing. And then you use the Bellare-Neven equation becomes... and now you don't even need to .... this ever separate the message from the pubkey. It's a signature scheme, only list of pubkey message pairs rather than sets of pubkey message pairs. Sets are much harder than lists.\"}, {\"type\":\"paragraph\",\"text\":\"I am looking for someone who can prove this, because I can't.\"}",
    "body": "See also <http://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2017-09-06-signature-aggregation/>\n\nIt's been published, it's been around for a decade, and it's widely cited. In Bellare-Neven, it's itself, it's a multi-signature scheme which means multiple pubkeys and one message. You should treat the individual authorizations to spend inputs, as individual messages. What we need is an interactive aggregate signature scheme. Bellare-Neven's paper suggests a trivial way of building an aggregate signature scheme out of a multisig scheme where interactively everyone signs everyone's message. We found a vulnerability in this scheme, it's very subtle.\n\nRussell O'Connor came up with this attack. Say you have two outputs with the same key, already a problem, but we can't prevent that. You want to participate in the coinjoin with me where you're just trying to spend one of them and not the other. So we have three UTXOs, and we'll also talk about the messages for each of those UTXOs, messages that authorize the spending of those outputs. Assume these are single input things. And we're trying to do a coinjoin for two of the messages, and I'm trying to steal this output from you. It's explained in the musig paper actually. In short, I am going to participate in the multisignature protocol, so the Bellare-neven lifted to an interactive aggregate signature protocol where I prented my key, where I pretend to have your key and your message, and I will eat the nonce you come up with. I just repeat this, act as a mirror, you say your key is this, and I say my key says this, and you say your nonce and I say a nonce; ther'es a more advanced version where I can hide it actually. I assume you don't validate the message I am trying to sign- that's the key point. In aggregate signature scheme, everyone has their own message, and you should not care which message someone is trying to sign; it should be impossible for anyone to sign with the other key..... the messages will be the same, the two hashes will be the same, between what you think I am going to sign and what I'm actually signing-- I am not saying which of the two we are. With the index, it's secure. Without the index, it's insecure. Bellare-neven has iactually specified this way- in the hash is the list of all the keys, and then your key yourself, but it doesn't say hwat index in that it list it is. The problem is that if those keys are the same, I can use your hash for the first one, and repeat it, and if p1 and p2 are the same, if these two things are the same, while if I'm signing p1 and p2, and ... this doesn't work. We're going to sign a multisignature with 2 times the key value.. if I'm not using the index, then the two things are exactly the same hash, and as a result your partial signature and double it, and it's now a valid signature for both. So the solution is to use an index, and not the public keys. You have to force people to put the indexes.\n\nThe advantage of not having indices is that, you're ordering, your local ordering. You just say, this, you do a lexicographic sort on the pubkeys, but you see this as the serialization of your keys, you don't need to have an idea of the ordering of the keys, and in Bellare-Neven paper... all the indices are local indices that don't have to correspond to the other parties indices, and this results in Russell's attacks. It's a very theoretical advantage to have only local indices anyway... I would very much like to see a proof that this construction actually solves this problem. This aspect of converting a multisig scheme into an interactive aggregate signature scheme does not come with a proof in the paper.\n\nYou could also fix it by saying never permit reusing a partial signature if any of the other participants claim to have your pubkey. This is also a sufficient fix I think. But I don't trust implementations to do that correctly.\n\nSay you have tuples of the keys and messages. You lexicographically sort those tuples. And then say L is the hash of that whole thing. And then you use the Bellare-Neven equation becomes... and now you don't even need to .... this ever separate the message from the pubkey. It's a signature scheme, only list of pubkey message pairs rather than sets of pubkey message pairs. Sets are much harder than lists.\n\nI am looking for someone who can prove this, because I can't.\n\n",
    "body_type": "markdown",
    "created_at": "2018-03-05T00:00:00.000Z",
    "domain": "https://btctranscripts.com/",
    "url": "https://btctranscripts.com/bitcoin-core-dev-tech/2018-03/2018-03-05-bellare-neven",
    "categories": [
        "core-dev-tech"
    ],
    "tags": [
        "signature-aggregation"
    ],
    "indexed_at": "2024-03-21T16:33:35.958Z",
    "transcript_by": "Bryan Bishop",
    "summary": "In the realm of digital security and cryptocurrency, the development and refinement of signature schemes are crucial for ensuring the integrity and safety of transactions. Within this context, the work by Mihir Bellare and Gregory Neven on multi-signature schemes has emerged as a significant contribution, offering a framework where multiple public keys can authorize a single message. However, as with any pioneering technology, vulnerabilities and areas for improvement have been identified over time.\n\nOne such vulnerability was spotlighted by Russell O'Connor, who uncovered a subtle yet critical flaw in the transition from a multi-signature scheme to an interactive aggregate signature scheme\u2014a process suggested as seemingly straightforward by Bellare and Neven. The issue arises when two outputs share the same key, creating a scenario ripe for exploitation during a transaction process known as coinjoin, aimed at enhancing privacy by combining multiple payments into a single transaction.\n\nO'Connor's attack hinges on the attacker's ability to mimic the victim's actions within the multisignature protocol, effectively allowing the attacker to authorize transactions fraudulently. This is facilitated by the attacker pretending to possess the victim's key and message, and then mirroring the victim's nonce\u2014a temporary number used in cryptographic communications. The core of the problem lies in the aggregation of signatures without proper validation of the messages being signed, leading to a situation where the attacker can manipulate the system to authorize transactions with the victim's key without detection.\n\nTo address this vulnerability, it was proposed that incorporating an index, rather than relying solely on public keys, could prevent such attacks. The original Bellare-Neven scheme lacked specificity regarding the position of a key within a list, making it possible for an attacker to reuse a hash across different transactions. By enforcing the use of indices, each participant's signature becomes uniquely tied to their position in the transaction, mitigating the risk of fraudulent signature reuse.\n\nDespite these solutions, the debate continues regarding the optimal approach to securing aggregate signature schemes. Some suggest further modifications, such as prohibiting the reuse of partial signatures if other participants claim possession of the same public key, while others advocate for a comprehensive proof to validate the effectiveness of these proposed solutions. The discussion also extends to the practicality of using local indices versus a global ordering system for public keys, highlighting the nuanced challenges in balancing theoretical advantages with real-world application security.\n\nIn conclusion, the exploration of vulnerabilities within the Bellare-Neven multi-signature scheme underscores the ongoing need for rigorous scrutiny and innovation in the field of digital security. As researchers and developers grapple with these complex issues, the ultimate goal remains clear: to devise robust, secure, and efficient signature schemes that can safeguard the integrity of transactions in the ever-evolving landscape of cryptocurrency and beyond."
}