{
    "id": "bitcointranscripts+bitcoin-core-dev-tech+2022-10+2022-10-11-package-relay",
    "title": "Package Relay BIP, implementation, V3, and package RBF proposals",
    "body_formatted": "{\"type\":\"paragraph\",\"text\":\"Notes on Package Relay BIP, implementation, V3, and package RBF proposals from Core Dev in Atlanta.\"}, {\"type\":\"paragraph\",\"text\":\"Also at <https://gist.github.com/glozow/8469dc9c3a003c7046033a92dd504329>.\"}, {\"type\":\"heading\",\"text\":\"Ancestor Package Relay BIP\"}, {\"type\":\"list\"}, {\"type\":\"heading\",\"text\":\"P2P Implementation\"}, {\"type\":\"list\"}, {\"type\":\"heading\",\"text\":\"V3 transactions and package RBF\"}, {\"type\":\"list\"}",
    "body": "\nNotes on Package Relay BIP, implementation, V3, and package RBF proposals from Core Dev in Atlanta.\n\nAlso at <https://gist.github.com/glozow/8469dc9c3a003c7046033a92dd504329>.\n\n# Ancestor Package Relay BIP\n\n* BIP updated to be receiver-initiated ancestor packages only.\n* Sender-initiated vs receiver-initiated package relay.\n    * Receiver-intiated package relay enables a node to ask for more information when they suspect they are missing something (i.e. to resolve orphans). Sender-initiated package relay should, theoretically, save a round trip by notifying the receiver ahead of time that \"hey, this is going to be a package, so make sure you download and submit these transactions together.\" As with any proactive communication, there is a chance that the node already knows this information, so this network bandwidth was wasted.\n    * The logic used to decide _when_ to announce a package proactively determines whether it is a net increase or decrease for overall bandwidth usage. However, it's difficult to design anything to save bandwidth without any idea of what its bandwidth usage actually looks like in practice. We'll want to design the sender-initiated protocol carefully, and inform the design decisions using data collected from the mainnet p2p network. However, there is no historical transaction data to use because the goal is to enable currently-rejected transactions to propagate. For now, hold off on sender-initiated, deploy receiver-initiated package relay, observe its usage and figure out where we can save a round trip, and then introduce a well-researched sender-initiated package relay protocol.\n* Reliance on BIP133 and p2p communication about fees/feerates.\n    * We've updated our mempool acceptance policy's idea of minimum feerate, but not the way we send BIP133 fee filters. What if our fee filter is 1sat/vB and there's a CPFP of a 0sat/vB parent with a 1sat/vB child? That's not incentive-compatible to accept, but the peer will still send us the child. Can't easily fix this; we can't just send ancestor feerate or something.\n    * Should BIP133 support be part of the negotiation? It isn't a strict requirement as the package would still propagate even if the receiver wasn't sending fee filters. The only issue is potentially downloading the child twice if the receiver isn't sending fee filters; the onus is then on the receiver to not send a \"sendpackages\" message. Bitcoin Core already supports BIP133.\n    * Another discussion about including fee information in package information. The information cannot be trusted - the package should still be downloaded and verified. To get full feerate, you also need to know topology, individual size, and individual fees for all the transactions. Same conclusion that it's unnecessary.\n    * General brainstorming about differences in node policies: would it make sense to have peers provide feedback on which transactions they rejected/accepted and use that information to allocate bandwidth / decide whether to relay?\n* The use of partial blocks for package relay.\n    * Partial blocks refers to a potential protocol message from miners to announce just-below-difficulty-threshold compact blocks (similar to mining pool shares but much less frequent), providing a sketch what transactions they are including in their blocks. Nodes can use this to pre-download and accept these transactions, ignoring policy rules since they are extremely likely to confirm and already have work on them.\n    * Discussion was active but deferred*. This can be considered orthogonal to the package relay proposal, since it did not address the main motivations of the BIP (propagating packages to miners in the first place, orphan fetching, and reducing txid-based relay).\n* Will polish the updated BIP and post.\n\n# P2P Implementation\n* Deduplication of rejected transactions to ensure we don't re-download invalid transactions but also don't accidentally censor things.\n    * Splits our rejections cache (m_recent_rejects bloom filter) into fee-related rejection and non-fee-related rejection filters. Anything that fails for fee reasons (including mempool min fee and fee-related RBF) goes into the fee-related rejection filter, and everything else into the other one.\n    * For packages and sub-packages that fail, add the transaction group by hashing the wtxids of each of the transactions, sorted lexicographically. Ensure that each group is itself an ancestor package. When a package is partially submitted, exclude the transactions that ended up in the mempool.\n    * Upon receiving ancpkginfo, if an exact match is found in the fee-related rejections filter, don't request tx data. If any of the wtxids are found in the non-fee-related rejections filter, don't request tx data.\n* Tradeoffs between bandwidth and memory requirements when downloading transaction data from peers.\n    * Intuitively, it doesn't make sense to re-download transactions we already have in the orphan pool (currently bounded to 100 transactions to avoid an oom vulnerability), but that is a cross-peer data structure and currently makes no per-peer allowances. It is trivial for somebody to churn the orphan pool by sending lots of orphans, so an attack could render package relay useless.\n    * What would it look like to guarantee that we store 1 package per peer? Implementation shouldn't be difficult, but this means a memory requirement of up to 101KvB (400KB serialized) per peer. With 125 peers, that's a 50MB requirement. This is acceptable because the per-peer memory requirement is small and everyone understands that resource usage scales with the number of connections.\n    * Preserve at least 1 package of transaction data per peer, and limit to 1 in-flight package relay per peer. Similarly throttle package information requests.\n    * Even with de-duplication, it possible to get O(n^2) download if a transaction chain is tx_1 ... tx_25 (tx_i spends tx_i-1), where tx_1 is 0-fee, tx_2-tx_24 are 1sat/vB (just above the node's fee filter), and tx25 pays for all of them? Each one will be rejected, then downloaded again when grouped with another \"ancpkginfo.\" Solution: when announcing transactions to a package relay peer, only announce ones that don't have unconfirmed descendants.\n\n# V3 transactions and package RBF\n* Extremely simple, seems to work for LN. Makes mempool people happy because it also might let us get rid of carve-out and limits the size of connected components in mempool.\n* Standardness of a transaction changes depending on chainstate. In the event of a reorg where transactions are re-added to the mempool, it's possible to need to evict V3 transactions in order to enforce its rules. Is this okay? Yes. We have other policies that necessitate the same thing, e.g. descendant limits.\n* Package RBF only allowed for V3 transactions. Is it to ensure the ancestor feerate rule is incentive-compatible? The current rule is not 100% guaranteed so.\n    * Imagine the original transaction, A, has a child B and co-parent C (i.e. B spends from A and C). C also has another child, D. B is one of the original transactions and thus its ancestor feerate must be lower than the package's. However, this may be an underestimation because D can bump C without B's help.\n    * This is resolved if V3 transactions can only have V3 ancestors.\n    * Is there ever a need to use a V3 descendant for both V3 *and* non-V3 transactions? Seems like no. There isn't any benefit to use a V3 transaction to bump a non-V3 LN Penalty commitment tx, since the pinning protections are not available. Ok then we can add this rule.\n* So the new rules would be:\n    * If a V3 transaction spends unconfirmed inputs, those transactions must also be V3.\n    * When the directly-conflicting transactions are V3 (which means all original transactions are V3), apply the ancestor feerate rule.\n    * Package RBF is only allowed when replacement transactions are V3.\n    * Ancestor feerate rule is incentive-compatible when original and replacements are V3.\n\n",
    "body_type": "markdown",
    "created_at": "2022-10-11T00:00:00.000Z",
    "domain": "https://btctranscripts.com/",
    "url": "https://btctranscripts.com/bitcoin-core-dev-tech/2022-10/2022-10-11-package-relay",
    "categories": [
        "core-dev-tech"
    ],
    "tags": [
        "package relay",
        "bitcoin core"
    ],
    "indexed_at": "2024-03-21T16:33:36.002Z",
    "transcript_by": "Gloria Zhao",
    "summary": "In a recent Core Dev meeting in Atlanta, significant advancements were made concerning the Bitcoin Improvement Proposal (BIP) for Ancestor Package Relay, alongside discussions on the implementation of Version 3 (V3) transactions and package Replace-by-Fee (RBF) proposals. The updated BIP now focuses solely on receiver-initiated ancestor packages, marking a pivotal shift in how transaction packages are relayed within the network. This alteration aims to streamline the process by allowing nodes to request additional information only when necessary, thereby potentially reducing redundant data transmission and optimizing bandwidth usage.\n\nThe conversation delved into the nuances of sender versus receiver-initiated package relay mechanisms. While sender-initiated relays could preemptively inform nodes of incoming packages, thereby theoretically saving communication time, this approach risks unnecessary bandwidth consumption if the receiving node is already aware of the relevant transactions. The consensus leaned towards initially deploying the receiver-initiated protocol to monitor its efficacy and gather data that could inform the eventual introduction of a sender-oriented approach.\n\nCritical to the discussion was the role of BIP133 and peer-to-peer communications regarding fee rates within these package transactions. A notable issue identified was the potential misalignment between current mempool acceptance policies and the way fee filters are communicated, which could lead to inefficient transaction propagation under certain conditions. Despite these challenges, there was agreement that further refinement of these protocols could enhance transaction efficiency without necessitating extensive changes to existing support for BIP133 in Bitcoin Core.\n\nA particularly innovative concept discussed was the use of partial blocks for package relay\u2014an idea that, while not immediately related to the primary goals of the BIP, presents an intriguing possibility for future optimization. This would involve miners broadcasting compact blocks that fall just below the difficulty threshold, allowing nodes to pre-emptively validate and accept transactions likely to be included in the next block, regardless of standard policy rules.\n\nImplementational aspects of P2P package relay were also scrutinized, with a focus on improving the handling of rejected transactions to avoid unnecessary re-downloads while preventing inadvertent censorship. This entails sophisticated management of rejection caches and the selective downloading of transaction data based on prior rejections. Additionally, strategies for balancing bandwidth and memory requirements were explored, emphasizing the need to maintain efficient data transfer without overwhelming node resources.\n\nThe discussions extended to the implications of introducing V3 transactions and specific rules for package RBF, highlighting the potential benefits for the Lightning Network and overall mempool management. A key consideration was ensuring that V3 transactions adhere to stricter rules regarding unconfirmed inputs and ancestor feerates, thereby maintaining incentive compatibility and network integrity during transaction replacement scenarios.\n\nOverall, the Core Dev meeting in Atlanta shed light on several critical areas for development and optimization within the Bitcoin network's transaction handling protocols. By focusing on receiver-initiated package relay, refining P2P implementation strategies, and setting clear guidelines for V3 transactions and package RBF, the community moves closer to enhancing the efficiency, reliability, and scalability of Bitcoin transaction processing."
}