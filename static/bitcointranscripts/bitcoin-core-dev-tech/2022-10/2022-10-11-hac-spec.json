{
    "id": "bitcointranscripts+bitcoin-core-dev-tech+2022-10+2022-10-11-hac-spec",
    "title": "High-assurance cryptography specifications (hac-spec)",
    "body_formatted": "{\"type\":\"paragraph\",\"text\":\"See <https://btctranscripts.com/tabconf/2022/2022-10-14-hac-spec/> instead for a full transcript of a similar talk.\"}, {\"type\":\"heading\",\"text\":\"Far far future\"}, {\"type\":\"paragraph\",\"text\":\"In the far far future, we could get rid of this weird paper notation scheme and do a security proof directly for the specification. Presumably that is much harder than anything else in my slides. But this would rule out a lot of bugs.\"}, {\"type\":\"paragraph\",\"text\":\"Q: But the security proof itself is written in a paper?\"}, {\"type\":\"paragraph\",\"text\":\"A: The security proof itself would be written in hac-spec. And your simulators. The compiler will prove that your proof is correct according to your definitions. That's already Coq for C code. You define a proof, you write the proof in Haskell, then it will verify that the C code matches it. Coq is written in Coq actually. It's a proving language.\"}, {\"type\":\"paragraph\",\"text\":\"Q: That's so cool.\"}, {\"type\":\"paragraph\",\"text\":\"A: It's probably hard to do. Also the question is, security proof, it's just a term. But the security proof might cover certain things and not other things. So then the problem is security definitions. But that's what people in formal verification have been trying to push for 20 years: get rid of papers and write all the proofs in Coq instead. I agree. It's hard to do that.\"}, {\"type\":\"paragraph\",\"text\":\"From my impression of this workshop, I was impressed with this. A lot of stuff is happening. The ecosystem has lots of tool and bad documentation but hac-spec is a sweet spot. Just write your specs in hac-spec and then you can translate it to other languages that allow you to prove things about the specification. Or you can translate into Coq.\"}, {\"type\":\"paragraph\",\"text\":\"You can choose what you want to prove about it. You can incrementally improve the proofs as you go along if you want. In a Coq example, there's lots of variables in there that are from codegen, but maybe if you change the specification then you get new variable names and now you have to adjust your proofs for this new Coq output which is unfortunate. You could write a lemma like this: no integer overflow, no buffer overflow here, and then you produce a proof from that. This requires very specialized skills and a lot of work. I should probably add that.\"}, {\"type\":\"paragraph\",\"text\":\"Q: Is there a proof language in hac-spec?\"}, {\"type\":\"paragraph\",\"text\":\"A: So hac-spec is just for formal definitions for specifications. But it doesn't contain a proof compiler or verifier. So you have to go to Coq or something like that. Yes. You get formalized semantics. It's fully formalized. The semantics of the conversion to Coq is fully formalized. The semantics of hac-spec are formal. But the translation into Coq.... perhaps we should run the tests for Coq as well and see if that works.\"}, {\"type\":\"heading\",\"text\":\"Conclusion\"}, {\"type\":\"paragraph\",\"text\":\"Would you run the Coq code against your test vectors? It's just an idea I had to make sure the Coq code is right.\"}, {\"type\":\"paragraph\",\"text\":\"Q: If I want to write a BIP and prove its correct, I need to write a specification in hac-spec and also write a proof in Coq?\"}, {\"type\":\"paragraph\",\"text\":\"A: Yes. You write your specification in hac-spec and not in Coq so that other people can read it too.\"}, {\"type\":\"paragraph\",\"text\":\"Q: Hopefully you can also write the proofs in hac-spec. No?\"}, {\"type\":\"paragraph\",\"text\":\"A: That doesn't really make sense.\"}, {\"type\":\"paragraph\",\"text\":\"Q: I'm not saying the same language but it should be in the same framework without moving to another framework.\"}, {\"type\":\"paragraph\",\"text\":\"A: Well, there's a reason why people use Coq. It's because there's a large ecosystem.\"}, {\"type\":\"paragraph\",\"text\":\"Q: I tried learning Coq. Never got there.\"}, {\"type\":\"paragraph\",\"text\":\"A: All these things are hard, but if you replace them with something else it's just harder.\"}, {\"type\":\"paragraph\",\"text\":\"If you are an author of crypto-BIPs, then you might want to consider writing your specifications in half-spec instead of pseudocode and completely get rid of the python stuff from your BIPs. In the half-aggregation BIP, I added comments for people who have trouble reading rust. This hac-spec subset is also hard to read for example the question mark operator, this is my best example. No other language has this. It is easy to miss, but it's super important. This really trips me up. Hac-spec forces you to use the question mark operator because you can't return only. You'll probably miss seeing the question mark. They probably formalized the question mark. Previously you could only return errors early, but never OKs.\"}, {\"type\":\"paragraph\",\"text\":\"One question would be, do we actually need pseudocode? Does this help anyone? It also introduces potential for mistakes like either translating between a specification and pseudocode or someone reading pseudocode and misinterpreting it. It might still hurt to understand it. I would rather strip out pseudocode because that's less work.\"}, {\"type\":\"paragraph\",\"text\":\"In the integer overflow check, for that do you also need to write a Coq proof? You need to write a proof for that. If all I'm doing in half-spec is get formal definitions but that's it.. if I assume the python has a formal definition, then it's equivalent. There's no free lunch.\"}, {\"type\":\"paragraph\",\"text\":\"Perhaps there's also a way to do formal verification or formal methods. It's an established research field with little practical relevance outside of some specialized areas. Maybe bitcoin would be a research area where this has application. I've heard banks use this for mainframes. No, they aren't doing that.\"}, {\"type\":\"paragraph\",\"text\":\"Are there applications outside of cryptographic BIPs? Hac-spec is just a subset of rust and you can do many things, the standard library is a bit limited but perhaps there are other applications.\"}, {\"type\":\"paragraph\",\"text\":\"Q: Can you open sockets? I assume no.\"}, {\"type\":\"paragraph\",\"text\":\"Fstar is another interactive theorem prover, similar to Coq. You can also translate it into easy-crypt which is a little bit different because it's a specialized language for doing computer crypto proofs. Hac-spec does not include code generation as part of its goal, the goal is not to generate fast code that matches the spec. With hac-spec, you don't need to be a formal theorem expert to read the specification.\"}, {\"type\":\"paragraph\",\"text\":\"Maybe proof engineering gets easier in the future. Maybe GPT-3/Codex gives you suggestions about how to do the proofs like giving you hints and helping you. Like Coq Copilot. Until then hopefully we get people who do formal analysis on our specs because we can't do it all on our own. \\\"Render me this proof in the style of a Schnorr paper, trending on Art Station.\\\"\"}",
    "body": "\nSee <https://btctranscripts.com/tabconf/2022/2022-10-14-hac-spec/> instead for a full transcript of a similar talk.\n\n# Far far future\n\nIn the far far future, we could get rid of this weird paper notation scheme and do a security proof directly for the specification. Presumably that is much harder than anything else in my slides. But this would rule out a lot of bugs.\n\nQ: But the security proof itself is written in a paper?\n\nA: The security proof itself would be written in hac-spec. And your simulators. The compiler will prove that your proof is correct according to your definitions. That's already Coq for C code. You define a proof, you write the proof in Haskell, then it will verify that the C code matches it. Coq is written in Coq actually. It's a proving language.\n\nQ: That's so cool.\n\nA: It's probably hard to do. Also the question is, security proof, it's just a term. But the security proof might cover certain things and not other things. So then the problem is security definitions. But that's what people in formal verification have been trying to push for 20 years: get rid of papers and write all the proofs in Coq instead. I agree. It's hard to do that.\n\nFrom my impression of this workshop, I was impressed with this. A lot of stuff is happening. The ecosystem has lots of tool and bad documentation but hac-spec is a sweet spot. Just write your specs in hac-spec and then you can translate it to other languages that allow you to prove things about the specification. Or you can translate into Coq.\n\nYou can choose what you want to prove about it. You can incrementally improve the proofs as you go along if you want. In a Coq example, there's lots of variables in there that are from codegen, but maybe if you change the specification then you get new variable names and now you have to adjust your proofs for this new Coq output which is unfortunate. You could write a lemma like this: no integer overflow, no buffer overflow here, and then you produce a proof from that. This requires very specialized skills and a lot of work. I should probably add that.\n\nQ: Is there a proof language in hac-spec?\n\nA: So hac-spec is just for formal definitions for specifications. But it doesn't contain a proof compiler or verifier. So you have to go to Coq or something like that. Yes. You get formalized semantics. It's fully formalized. The semantics of the conversion to Coq is fully formalized. The semantics of hac-spec are formal. But the translation into Coq.... perhaps we should run the tests for Coq as well and see if that works.\n\n# Conclusion\n\nWould you run the Coq code against your test vectors? It's just an idea I had to make sure the Coq code is right.\n\nQ: If I want to write a BIP and prove its correct, I need to write a specification in hac-spec and also write a proof in Coq?\n\nA: Yes. You write your specification in hac-spec and not in Coq so that other people can read it too.\n\nQ: Hopefully you can also write the proofs in hac-spec. No?\n\nA: That doesn't really make sense.\n\nQ: I'm not saying the same language but it should be in the same framework without moving to another framework.\n\nA: Well, there's a reason why people use Coq. It's because there's a large ecosystem.\n\nQ: I tried learning Coq. Never got there.\n\nA: All these things are hard, but if you replace them with something else it's just harder.\n\nIf you are an author of crypto-BIPs, then you might want to consider writing your specifications in half-spec instead of pseudocode and completely get rid of the python stuff from your BIPs. In the half-aggregation BIP, I added comments for people who have trouble reading rust. This hac-spec subset is also hard to read for example the question mark operator, this is my best example. No other language has this. It is easy to miss, but it's super important. This really trips me up. Hac-spec forces you to use the question mark operator because you can't return only. You'll probably miss seeing the question mark. They probably formalized the question mark. Previously you could only return errors early, but never OKs.\n\nOne question would be, do we actually need pseudocode? Does this help anyone? It also introduces potential for mistakes like either translating between a specification and pseudocode or someone reading pseudocode and misinterpreting it. It might still hurt to understand it. I would rather strip out pseudocode because that's less work.\n\nIn the integer overflow check, for that do you also need to write a Coq proof? You need to write a proof for that. If all I'm doing in half-spec is get formal definitions but that's it.. if I assume the python has a formal definition, then it's equivalent. There's no free lunch.\n\nPerhaps there's also a way to do formal verification or formal methods. It's an established research field with little practical relevance outside of some specialized areas. Maybe bitcoin would be a research area where this has application. I've heard banks use this for mainframes. No, they aren't doing that.\n\nAre there applications outside of cryptographic BIPs? Hac-spec is just a subset of rust and you can do many things, the standard library is a bit limited but perhaps there are other applications.\n\nQ: Can you open sockets? I assume no.\n\nFstar is another interactive theorem prover, similar to Coq. You can also translate it into easy-crypt which is a little bit different because it's a specialized language for doing computer crypto proofs. Hac-spec does not include code generation as part of its goal, the goal is not to generate fast code that matches the spec. With hac-spec, you don't need to be a formal theorem expert to read the specification.\n\nMaybe proof engineering gets easier in the future. Maybe GPT-3/Codex gives you suggestions about how to do the proofs like giving you hints and helping you. Like Coq Copilot. Until then hopefully we get people who do formal analysis on our specs because we can't do it all on our own. \"Render me this proof in the style of a Schnorr paper, trending on Art Station.\"\n\n\n",
    "body_type": "markdown",
    "created_at": "2022-10-11T00:00:00.000Z",
    "domain": "https://btctranscripts.com/",
    "url": "https://btctranscripts.com/bitcoin-core-dev-tech/2022-10/2022-10-11-hac-spec",
    "categories": [
        "core-dev-tech"
    ],
    "tags": [
        "cryptography"
    ],
    "indexed_at": "2024-03-21T16:33:36.001Z",
    "transcript_by": "Bryan Bishop",
    "summary": "In a fascinating discussion on the future of cryptographic proofs and specifications, the conversation delved into the realm of formal verification and the potential to revolutionize how security proofs are conceptualized and implemented. The notion of transcending traditional paper-based notation for security proofs in favor of a direct specification-based approach was explored, highlighting the complexity yet undeniable benefits of such an evolution. This method, though more challenging than current practices, promises to significantly reduce bugs by leveraging the hac-spec language for writing proofs, thereby ensuring a higher level of precision and reliability in security protocols.\n\nThe dialogue further illuminated the intricacies of using formal languages like Coq, a proving language that allows for the verification of proofs against definitions. It was mentioned that Coq, which is utilized for verifying C code among others, exemplifies the theoretical possibility of validating the correctness of security proofs directly from their specifications. This approach underscores a broader ambition within the field of formal verification: to shift away from traditional paper-based methods towards fully formalized proofs written in languages designed for precise specification and verification, such as hac-spec.\n\nAmidst these technical discussions, the workshop also shed light on the practical aspects of implementing such advanced verification methodologies. The speakers discussed the current landscape, marked by a plethora of tools with suboptimal documentation. Yet, they identified hac-spec as a notably accessible point, offering a balance between specification clarity and the capability to translate specs into other languages for proof verification. This flexibility allows for incremental improvement of proofs, albeit with the caveat that changes in specification could necessitate substantial adjustments in the corresponding proofs.\n\nA significant portion of the conversation revolved around the application of hac-spec in writing Bitcoin Improvement Proposals (BIPs) and the inherent challenges in learning and applying Coq for proof verification. The discussants advocated for hac-spec as a superior alternative to pseudocode for BIPs, arguing that it offers clearer, formally defined specifications which could potentially obviate the need for pseudocode, thus reducing the risk of errors in translation or interpretation.\n\nFurthermore, the discussion touched upon broader applications of formal verification beyond cryptographic BIPs, suggesting that despite its niche status, formal verification possesses untapped potential in various research areas, including banking systems and beyond. The limitations of hac-spec, such as its inability to open sockets, were acknowledged alongside mentions of similar tools like Fstar and easy-crypt, which cater to specific use cases within formal verification.\n\nThe conversation concluded with speculative insights into the future of proof engineering, hinting at the role of artificial intelligence, specifically GPT-3/Codex, in simplifying the process of proof creation. This prospect, while still theoretical, suggests an exciting direction for the field where automation and AI assistance could democratize access to formal analysis and verification, making it more accessible to a wider array of developers and researchers.\n\nOverall, the workshop not only highlighted the current state and challenges of formal verification in cryptographic specifications but also charted a visionary course towards a future where such methods become integral to the development and certification of secure, bug-free cryptographic protocols."
}