{
    "id": "bitcointranscripts+bitcoin-explained+what-is-utreexo",
    "title": "What Is Utreexo?",
    "body_formatted": "{\"type\":\"heading\",\"text\":\"Introduction\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum:\"}, {\"type\":\"paragraph\",\"text\":\"And the proposal we're discussing this week is Utreexo.\"}, {\"type\":\"paragraph\",\"text\":\"Ruben Somsen:\"}, {\"type\":\"paragraph\",\"text\":\"That is correct.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost:\"}, {\"type\":\"paragraph\",\"text\":\"Utreexo, and the tree is for tree.\\nThe thing that grows in the forest.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum:\"}, {\"type\":\"paragraph\",\"text\":\"Did you know that was the pun, Ruben? I didn't realize...\"}, {\"type\":\"paragraph\",\"text\":\"Ruben Somsen:\"}, {\"type\":\"paragraph\",\"text\":\"Well, I heard Tadge say that so I was aware of that, but there is a very specific reason why I was enthusiastic to talk about it.\\nWell, one, I've used it in one of the things I've been working on so I like Utreexo a lot conceptually.\\nBut there's also a close friend of mine, Calvin Kim, who was a regular attendee of the Seoul Bitcoin meetup who is now actively working on Utreexo together with Tadge and I told him I would shout out the other guys that are working on the project.\\nJannis Trulsen, which is apparently not a Dutch person.\\nI think he's German or something.\\nAnd Niklas G\u00f6gge.\\nHopefully I pronounce it correctly, but those are the four guys that are currently working on Utreexo.\\nHopefully it will eventually get to a point where this can be useful for Bitcoin.\\nBut we should obviously start explaining what Utreexo is, because we're just talking about the conceptual-\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost:\"}, {\"type\":\"paragraph\",\"text\":\"Oh, we've got to keep it exciting.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum:\"}, {\"type\":\"paragraph\",\"text\":\"Well, really quick.\\nAre you guys with DG Lab?\"}, {\"type\":\"paragraph\",\"text\":\"Ruben Somsen:\"}, {\"type\":\"paragraph\",\"text\":\"No, no, that's completely separate, yeah.\\nI'm not super familiar with this, but Tadge is with MIT, and then the other three guys are just working on this separately.\\nSo they're not involved with MIT or DG Labs.\\nDG Labs mainly works on DLC.\\nThat's one of their main projects.\"}, {\"type\":\"heading\",\"text\":\"The UTXO Set and Its Challenges\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum:\"}, {\"type\":\"paragraph\",\"text\":\"So Sjors, what problem are we solving?\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost:\"}, {\"type\":\"paragraph\",\"text\":\"Problem, problem.\\nChallenge.\\nNo, so one of the constraints when you're syncing a new Bitcoin node, we talked about sync a couple times, is the amount of RAM memory you have.\\nNow, it's not a hard constraint.\\nYou don't need a lot of RAM, but if you want to sync it fast, you do.\\nAnd the reason is this thing called the UTXO set.\\nThe UTXO set is a list of coins that you own, and we talked about that last time, I guess.\\nBut every time the new block comes in, what you do is, for every transaction in the block, you check if it's spending something that exists, namely, one UTXO.\\nAnd so in order to check if something exists, well, it has to be somewhere.\\nIt has to be in a database of sorts.\\nAnd where is that database? Well, if that database is sitting in your RAM memory, that's extremely fast.\\nIf on the other hand, that database is sitting on your hard disk, if it's an SSD drive, it's meh.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum:\"}, {\"type\":\"paragraph\",\"text\":\"What you mean is, it's much faster to look up if it's in there.\\nIf it's in your RAM, then your computer will be able to look it up within...\\nWell, I don't know how fast, but faster than if it's on your drive, at least.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost:\"}, {\"type\":\"paragraph\",\"text\":\"It's probably at least 10 times faster than if it's on your SSD drive, and if you're using a magnetic drive, it's even worse.\\nAnd then the other side of it is, once you create this new coin, which the transaction does on the output side, it has to store that.\\nSo it has to write it somewhere on the disc, which is also slow.\\nAnd if you have a magnetic spin disc, then it has to move to read somewhere and it has to move somewhere else to write again and these are gigabytes apart, so that's horrible.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum:\"}, {\"type\":\"paragraph\",\"text\":\"So to make it very concrete, I guess the biggest difference you would notice when you're syncing a new node, and if you would somehow be able to keep the UTXO set in RAM, it will only take, I don't know, couple hours?\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost:\"}, {\"type\":\"paragraph\",\"text\":\"But it depends on your computer.\\nI have a somewhat recent MacBook Pro and I think I can sync the whole chain in five hours-\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum:\"}, {\"type\":\"paragraph\",\"text\":\"If you keep it in RAM.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost:\"}, {\"type\":\"paragraph\",\"text\":\"But that takes about 11 gigabytes of RAM.\\nBut if you do it on, say, a typical Raspberry Pi, you might have two gigabytes these days, maybe four.\\nSo that means you're going to sync the chain and you're going to keep as much as possible in RAM, but at some point it overflows, the UTXO set, and then usually what it does is it writes everything to disk, clears everything, and then it starts caching again, and this takes a long time.\\nIt can take days on these machines.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum:\"}, {\"type\":\"paragraph\",\"text\":\"So the point being, as you can keep more of the UTXO set in RAM, you'll sync faster, or your node will just work faster, operate faster in general.\\nSo it would be good if we could somehow decrease the size of the UTXO set.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost:\"}, {\"type\":\"paragraph\",\"text\":\"Well, we can't decrease the size of the UTXO set.\\nThat's the problem.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum:\"}, {\"type\":\"paragraph\",\"text\":\"That's a bummer.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost:\"}, {\"type\":\"paragraph\",\"text\":\"There is a limit on the size of blocks.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum:\"}, {\"type\":\"paragraph\",\"text\":\"Well, it can decrease-\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost:\"}, {\"type\":\"paragraph\",\"text\":\"For megabytes.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum:\"}, {\"type\":\"paragraph\",\"text\":\"It can decrease, it's just not something we can do.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost:\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, it decreases when people spend-\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum:\"}, {\"type\":\"paragraph\",\"text\":\"I don't know how much UTXOs you own, Sjors.\\nI bet a lot, so maybe you could play a part in decreasing the UTXO.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost:\"}, {\"type\":\"paragraph\",\"text\":\"I have millions of UTXOs on testnet.\\nNo, so the idea is that if you're spending more coins than you're creating, then obviously the number of UTXOs goes down and the RAM usage goes down.\\nBut there's a lot of junk in the UTXO set, because there were people in the old days that created transactions to multi-sig addresses that were fake just in order to put pictures of Obama in the blockchain.\\nAnd those are all sitting in your RAM because you node has no idea that they're nonsense.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost:\"}, {\"type\":\"paragraph\",\"text\":\"But the other thing is, if we expect everybody in the world eventually to use Bitcoin and everybody to have at least one or two UTXOs, well, that's a lot of RAM.\\nThat's like seven billion people.\\nAnd there's really no limit to how big that can get, there's no constraint.\\nIt might take a while because it takes a lot of fees to create all these transactions, but eventually it could take as much RAM as...\\nThere's no limit, and we don't like things that don't have a limit.\\nUnbounded stuff, it's a bit bad.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum:\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, you mean the UTXO set can get as big as it will get until the point where not everyone can use it and sync it from RAM?\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost:\"}, {\"type\":\"paragraph\",\"text\":\"Fewer and fewer people will have enough RAM to sync it quickly and that could become a problem.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum:\"}, {\"type\":\"paragraph\",\"text\":\"Okay, so you agree, it's a problem.\\nNot just a challenge.\\nIt a problem, Sjors.\\nNow how do we solve it?\"}, {\"type\":\"heading\",\"text\":\"What is Utreexo\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost:\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, it's a challenge.\\nWell, one way to solve it is Tadge Dryja's proposal, the Utreexo.\"}, {\"type\":\"paragraph\",\"text\":\"Ruben Somsen:\"}, {\"type\":\"paragraph\",\"text\":\"That's right, yep.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost:\"}, {\"type\":\"paragraph\",\"text\":\"And the idea there, I guess that's what we'll need to explain, right? How that works.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum:\"}, {\"type\":\"paragraph\",\"text\":\"Well, Ruben wanted to explain it to us, so let's hear it.\"}, {\"type\":\"paragraph\",\"text\":\"Ruben Somsen:\"}, {\"type\":\"paragraph\",\"text\":\"Well, I first wanted to say that I thought, Aaron, your analogy with basically saying that it's pruning for the UTXO set, I thought that was a very good analogy, where currently we have pruning in Bitcoin-\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum:\"}, {\"type\":\"paragraph\",\"text\":\"This was an off-record analogy.\\nBut now it's an on-record analogy.\"}, {\"type\":\"paragraph\",\"text\":\"Ruben Somsen:\"}, {\"type\":\"paragraph\",\"text\":\"Now's it's on record, yes.\\nI'm repeating something that you had told me before the show.\\nSo with Bitcoin, currently you have pruning in the sense that you take a block, you process it, you extract the UTXO set out, basically from all the blocks, and then that's all that you keep.\\nYou only keep the UTXO set and then you can throw everything else away and that's called pruning.\"}, {\"type\":\"paragraph\",\"text\":\"Ruben Somsen:\"}, {\"type\":\"paragraph\",\"text\":\"There is a downside, which is that then you don't have the blocks.\\nSo if you want to prove to another person that the UTXO set is valid, you can't actually give them the blocks, but the assumption is that somebody else will have the block so it's fine.\"}, {\"type\":\"paragraph\",\"text\":\"Ruben Somsen:\"}, {\"type\":\"paragraph\",\"text\":\"And here, what you're pruning is something else.\\nYou're pruning UTXO sets and your essentially throwing away all the transactions and you're just keeping a Merkle roots.\\nAnd inside of that Merkle roots is basically a commitment.\\nEvery single UTXO is committed in there and you only keep the Merkle proofs of the UTXOs that you care about, that you own.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum:\"}, {\"type\":\"paragraph\",\"text\":\"What is a Merkle root?\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost:\"}, {\"type\":\"paragraph\",\"text\":\"Maybe to put it another way, normally when somebody sends you a transaction, the transaction says, 'I'm spending this input and you, as the person running a node, has the responsibility to check whether that input exists in your own database.' And you're flipping this around and you're telling the other node, 'I have no idea which coins exist, because I don't have RAM.\\nYou prove to me that this coin actually existed.' And that's what you use this Merkle proof for.\\nSo the burden of evidence is reversed here.\\nYou need to prove that a transaction exists.\\nAnd then the question is how are we going to do that?\"}, {\"type\":\"heading\",\"text\":\"Technical Mechanisms of Utreexo\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum:\"}, {\"type\":\"paragraph\",\"text\":\"Okay, so we're reversing the burden of proof.\\nUsually when you're sending a transaction...\\nWhen I send a transaction to you, Sjors, then you check inside your node and the database with your UTXO set, whether the transaction is spending valid UTXOs.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost:\"}, {\"type\":\"paragraph\",\"text\":\"Yes.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum:\"}, {\"type\":\"paragraph\",\"text\":\"Now I'm actually going to have to provide you with the proof that my transaction is spending existing UTXOs.\\nHowever, you still need something in order to make sure that my proof is valid, and that's this Utreexo, which is a hash tree.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost:\"}, {\"type\":\"paragraph\",\"text\":\"Yes, a Merkel tree of hashes.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum:\"}, {\"type\":\"paragraph\",\"text\":\"A Merkel tree, right.\\nSo what is this and how does it work?\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost:\"}, {\"type\":\"paragraph\",\"text\":\"It's kind of nice.\\nAll the UTXOs that are in existence would be put into this tree and everybody can construct this tree if you replay the whole blockchain.\\nBut the question is-\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum:\"}, {\"type\":\"paragraph\",\"text\":\"It's not an actual tree though, is it, Sjors?\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost:\"}, {\"type\":\"paragraph\",\"text\":\"It is not an actual tree.\"}, {\"type\":\"paragraph\",\"text\":\"Ruben Somsen:\"}, {\"type\":\"paragraph\",\"text\":\"Do you give it water?\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost:\"}, {\"type\":\"paragraph\",\"text\":\"No, basically what the tree would look like is you have the first UTXO, and then the second UTXO right next to each other, and then you take the hash of those two, basically combined, and that is one new hash.\\nSo, you see this little pyramid shape and you can do that again for another two UTXOs that exist.\\nThey have their own little mini tree, but now you see, oh, there's two trees.\\nLet me just combine those two trees.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum:\"}, {\"type\":\"paragraph\",\"text\":\"Two hashes, and you're combining these two hashes, yes.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost:\"}, {\"type\":\"paragraph\",\"text\":\"So now you have four UTXOs.\\nTwo of them are shared and then those two are shared again.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum:\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, so you end up with one hash?\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost:\"}, {\"type\":\"paragraph\",\"text\":\"You end up with one hash.\\nNow, the key here is that these things are so called, I believe, perfect trees, which means that they are always a multiple of two.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum:\"}, {\"type\":\"paragraph\",\"text\":\"And so now the challenge is that for every new block, this tree needs to be updated, right? Because we have one big tree for all of the UTXOs.\\nNow a new block is found, it includes all sorts of new transactions, so new UTXOs exist and old UTXOs are destroyed, so now we need a new tree.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost:\"}, {\"type\":\"paragraph\",\"text\":\"Yeah.\\nWell, it's even more than one tree, right? It is a forest.\\nEvery tree has to be a multiple of two, so there can be four things at the bottom or eight things at the bottom or 16 things at the bottom.\\nWhen you have a number of transactions that doesn't fit that way, you'll have multiple trees that look like that.\\nSo you have a collection of trees for which you really only need to remember the top hashes.\\nAnd now the question is, how do you add something to that tree?\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum:\"}, {\"type\":\"paragraph\",\"text\":\"So you might have one tree with 16 at the bottom, one tree with eight at the bottom, one tree with two UTXOs at the bottom.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost:\"}, {\"type\":\"paragraph\",\"text\":\"One at the bottom.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum:\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, exactly.\\nSo you have multiple trees.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost:\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, right.\\nAnd now in order to prove that something is in this tree and also to replace it with, say, the output...\\nBecause basically you destroy one UTXO so that you're spending and you create a new UTXO you're creating.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost:\"}, {\"type\":\"paragraph\",\"text\":\"So you can actually take the UTXO that you're spending out of the tree and then put the new one into the tree.\\nAnd in order to do that, you need to recalculate the tree and you do that by knowing its neighbors.\\nSo, the way you prove that something is inside a Merkle tree is to say, well, at the bottom of the tree, there's these two pairs and I'm going to give you the other side.\\nAnd then at the next level, again, there's a pair and I'm going to give you the other side.\\nAnd again and again and again, and that proves that something is actually in the tree.\\nAnd that's exactly the same information that you need to put something else at the bottom of the tree, and then provide the new hash.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum:\"}, {\"type\":\"paragraph\",\"text\":\"So by putting something else at the bottom of the tree, to be clear, the entire tree changes, or at least the one hash you end up with changes.\\nYou're just computing a whole new tree, but you're able to do that because you have all the data you need.\\nSo you can add things to the forest and you can remove things from the forest.\\nIt's actually possible.\\nIt's actually easier than I thought it would be when I saw Tadge explain it.\\nI don't know if it's going to be easy when people hear us explain this.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost:\"}, {\"type\":\"paragraph\",\"text\":\"I recommend looking at Tadge explain it after you hear us explain it, because you need to see it-\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum:\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, visuals really help.\"}, {\"type\":\"paragraph\",\"text\":\"Ruben Somsen:\"}, {\"type\":\"paragraph\",\"text\":\"Exactly.\\nI think his presentations are great.\\nHe's very good at explaining it and he has slides so that's a lot easier than what we are doing.\\nWe're trying to explain it in words.\\nEspecially in Merkle trees, I think, it's great if you have an actual picture there.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost:\"}, {\"type\":\"paragraph\",\"text\":\"But now the idea is that you're not tracking everything.\\nSo you could, when you're syncing the blockchain, keep track of the entire tree, but then you need a lot of RAM, just like in the original scenario.\\nBut what you'll actually do is you're going to remember the top of every tree and there might be 10 or 20 or whatever trees, and that's all you're going to remember, and when somebody has a new transaction that you want to verify, they need to give you the Merkle proofs for all the inputs that they're spending, so they prove that they exist.\\nAnd then they also tell you which outputs are there, which are going to be swapped in at the same places where those inputs were.\\nPlus new trees if it's making more.\"}, {\"type\":\"paragraph\",\"text\":\"Ruben Somsen:\"}, {\"type\":\"paragraph\",\"text\":\"The outputs are under blocks, right?\"}, {\"type\":\"paragraph\",\"text\":\"Ruben Somsen:\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, so that's really, I think, the very elegant side of Utreexo, where the same proofs that are proving that these UTXOs are in the UTXO set, are also exactly what you need to remove them from the set, update your root hash and add the new UTXOs from the latest block, so that works out quite elegantly.\"}, {\"type\":\"heading\",\"text\":\"Implementation and Practical Considerations\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum:\"}, {\"type\":\"paragraph\",\"text\":\"Okay, so in an ideal scenario...\\nWhat we've been explaining so far is the ultimate version of Utreexo, so let's stick with that for a minute.\\nSo I wanted to send a transaction to the network and you, Sjors, you had a node and you wanted to validate the transaction.\\nYou have this tree in your RAM apparently.\\nThat's what's nice about it.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost:\"}, {\"type\":\"paragraph\",\"text\":\"I have the top of the trees in my RAM.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum:\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, exactly.\\nSo now I want to send this transaction, so now it's my responsibility to send to you the transaction, as well as the proof that the transaction is valid, which also includes information for you so you know where to find it in the forest, right?\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost:\"}, {\"type\":\"paragraph\",\"text\":\"Exactly.\\nYou need to prove to me that the things you are spending are in the forest, because I forgot what the forest looked like.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum:\"}, {\"type\":\"paragraph\",\"text\":\"All right, so that's me sending the transaction with the proof.\\nNow, the other way you could get a transaction is if it's already in the block.\\nSo if a miner mines a block and the transaction is in there, you still have your Utreexo thing on your node.\\nBut how do you now get the proof?\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost:\"}, {\"type\":\"paragraph\",\"text\":\"Right, because if you spend the transaction, you're not going to talk to every node that ever downloaded a block to send that proof around.\\nSo how does that proof get to the node?\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum:\"}, {\"type\":\"paragraph\",\"text\":\"That wouldn't scale very well, at least.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost:\"}, {\"type\":\"paragraph\",\"text\":\"No.\\nWell, what you would probably want to have is something called a bridge node.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum:\"}, {\"type\":\"paragraph\",\"text\":\"A bridge node.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost:\"}, {\"type\":\"paragraph\",\"text\":\"A bridge node would be a node that has the actual UTXO set, the old-fashioned way, so it has lots of RAM or it's just slow.\\nAnd it produces all these proofs and it sends them around to whoever wants them.\"}, {\"type\":\"paragraph\",\"text\":\"Ruben Somsen:\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, so what essentially happens is that when this bridge node receives a transaction and this transaction does not have a Merkle proof, proving the inclusion in the Utreexo root, this bridge node basically just takes the proof that they have and they attach it to the transaction and now they send it on to other Utreexo nodes.\\nIt's a bridge between Utreexo nodes and non-Utreexo nodes.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum:\"}, {\"type\":\"paragraph\",\"text\":\"But they could also construct the proof themselves, right? If they see a certain transaction is included in a block, they can just figure-\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost:\"}, {\"type\":\"paragraph\",\"text\":\"That's right, there's nothing secret here.\\nSo if you have the original UTXO set in memory somewhere, you can construct the proof for any transaction.\"}, {\"type\":\"paragraph\",\"text\":\"Ruben Somsen:\"}, {\"type\":\"paragraph\",\"text\":\"And they have the entire tree, essentially.\\nSo the entire UTXO tree that you create and then prune, they just don't prune it essentially.\\nSo they just have the full UTXO set.\\nBasically, the UTXO set with all the Merkle proofs connecting to it, so then they can just take any UTXO in there and create a proof from it and just send it on, or for an entire block or whatever.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum:\"}, {\"type\":\"paragraph\",\"text\":\"Right, so what would happen in practice? Sjors, your node would see a transaction in a block and it would wonder, 'Hmm, is there actually proof for that? I never saw the transaction before.' And you would request it from a bridge node.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost:\"}, {\"type\":\"paragraph\",\"text\":\"My guess is, when you get the whole block, you're going to call a bridge node and say, 'Give me the proofs for that entire block.'\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum:\"}, {\"type\":\"paragraph\",\"text\":\"Just all of them?\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost:\"}, {\"type\":\"paragraph\",\"text\":\"Yeah.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum:\"}, {\"type\":\"paragraph\",\"text\":\"Why not just the ones you need, the ones you haven't seen before?\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost:\"}, {\"type\":\"paragraph\",\"text\":\"My guess is that's too much back and forth because if you have to call a node for every single individual transaction, and that's a lot of overhead, whereas just downloading a couple hundred kilobytes is easier.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum:\"}, {\"type\":\"paragraph\",\"text\":\"Anyways, that's an implementation detail.\"}, {\"type\":\"paragraph\",\"text\":\"Ruben Somsen:\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, but I think this is just an automated process, where you just connect to the network.\\nBut the problem is, when you're the first Utreexo node, and you're pruning all the data and then everybody else on the network is an old-fashioned node, like the way we run it today, nobody's going to give you the proofs, right?\"}, {\"type\":\"paragraph\",\"text\":\"Ruben Somsen:\"}, {\"type\":\"paragraph\",\"text\":\"So what you need is at least a single bridge node, so at least you can connect to that one.\\nAnd then other people are connecting to the bridge node because the bridge node basically speaks both languages.\\nThey speak the Utreexo language and they speak the old-fashioned language.\\nSo they translate for you, and as long as one bridge node exists, it can bootstrap the network essentially, but they don't have to have special rules.\\nFrom the perspective of the Utreexo node, the bridge node is just also Utreexo node, and from the perspective of the old-fashioned nodes, it's just an old-fashioned node.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost:\"}, {\"type\":\"paragraph\",\"text\":\"Right, that's another point.\\nSo, you don't need everybody to do this translation, only one person needs to do it or a couple.\\nThe other nodes know how to relay that information even if they can't produce it, so that's good news.\\nBut of course-\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum:\"}, {\"type\":\"paragraph\",\"text\":\"Can we have a future without bridge nodes?\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost:\"}, {\"type\":\"paragraph\",\"text\":\"Well, we should point out what the problem is with these bridge nodes, because they are nice people.\\nWe don't want to rely on nice people.\\nThat's not how we roll, because nice people can stop being nice.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum:\"}, {\"type\":\"paragraph\",\"text\":\"Or they can be forced to stop being nice.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost:\"}, {\"type\":\"paragraph\",\"text\":\"Or they can just disappear or run out of battery.\\nThen you can look at the longer-term picture, if people like this given the advantages, or even if they don't like it, if the UTXO set just becomes insane and it just takes too long to sync on any normal computer, then you could basically make a soft fork which contains the proofs.\\nSo the proofs become part of the blockchain, just like SegWit added the whole bunch of data to blocks.\\nYou could then add these proofs to the blocks, making the blocks even bigger.\\nBut the trade-off there is, you have more bandwidth, but you have less RAM need.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum:\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, the reason this could be done as a soft fork, same with SegWit, is because you'd include the hash of the proofs somewhere in the coinbase transaction or something like that.\\nOld nodes just won't notice anything interesting, but upgraded nodes will see a whole tree, which they share with each other, which does make the blocks a bit bigger for them.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost:\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, so old nodes keep doing what they're doing.\\nThey get blocks, they can verify those blocks, because nothing changes about the transactions in the blocks.\\nNew nodes will save some RAM memory.\\nThey'll use that extra data.\\nThey'll download that extra data and they'll use it.\\nThat's generally the idea.\"}, {\"type\":\"paragraph\",\"text\":\"Ruben Somsen:\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, so personally at least, I think this is not likely to happen until we really get a UTXO set bloating issue where the UTXO set becomes so big that people start liking this trade-off to the point where it's preferable.\\nI think as long as we're not at that point, I don't think we'll see this as a soft fork, but that's my personal view.\"}, {\"type\":\"heading\",\"text\":\"Potential Benefits of Utreexo\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost:\"}, {\"type\":\"paragraph\",\"text\":\"I do want to point out some cool things you can do with it.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum:\"}, {\"type\":\"paragraph\",\"text\":\"Yes, tell us the bullish part, Sjors.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost:\"}, {\"type\":\"paragraph\",\"text\":\"I'm all just copy pasting from what Tadge said, we like to do that.\\nBasically because you don't need a lot of RAM, you can start doing things in specialized hardware like in ASIC, because one of the things that's hard to do in an ASIC is lots of memory.\\nAnd having specialized hardware, maybe it's a part of your chip, so maybe Bitcoin becomes the standard and every phone that you buy has a CPU, has a little mini processor right next to it that just checks all the Bitcoin validation rules.\\nAnd because it's custom silicon, it might be able to validate the entire blockchain at the speed that it can download it, which is pretty cool.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum:\"}, {\"type\":\"paragraph\",\"text\":\"An ASIC for regular nodes?\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost:\"}, {\"type\":\"paragraph\",\"text\":\"Exactly, yeah.\\nSo not to mine coins, but to verify coins, which would be cool.\\nAnd then you have the protocol literally set in stone or at least set in silicon.\\nAnd of course soft forks can still happen under that circumstance, but if somebody wants to do a hard fork, you'd have to break all the node hardware, and not just all the mining hardware.\\nSo, that's a nice extra barrier to not do hard forks.\"}, {\"type\":\"paragraph\",\"text\":\"Ruben Somsen:\"}, {\"type\":\"paragraph\",\"text\":\"It's ossification-\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum:\"}, {\"type\":\"paragraph\",\"text\":\"It's also not perfect for soft fork.\\nIs that what you just said, Ruben?\"}, {\"type\":\"paragraph\",\"text\":\"Ruben Somsen:\"}, {\"type\":\"paragraph\",\"text\":\"No, no.\\nThat's what Sjors just said.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost:\"}, {\"type\":\"paragraph\",\"text\":\"I think its hard to verify soft forks.\\nYou don't have to verify the soft fork, but you can't verify the soft fork, at least not with the accelerated hardware, so your computer would have to slow down to check all the new rules whenever it encounters it.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum:\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, or you would have to buy a new phone because the soft fork happened.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost:\"}, {\"type\":\"paragraph\",\"text\":\"Exactly.\"}, {\"type\":\"paragraph\",\"text\":\"Ruben Somsen:\"}, {\"type\":\"paragraph\",\"text\":\"Your phone is too old, maybe it's possible, right? That's that's what happens now.\\nPeople buy new phones every couple of years, so maybe it's not too much to ask.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum:\"}, {\"type\":\"paragraph\",\"text\":\"True.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost:\"}, {\"type\":\"paragraph\",\"text\":\"The other thing we talked last week about is Assume UTXO thing, where one of the problems is, now when you start, you still need to get that three gigabyte thing from somewhere.\\nAnd if this thing becomes a hundred gigabytes, you have to get that from somewhere.\\nBut now, with this proposal, we just have a kilobyte.\\nSo you can put the entire UTXO set, you can represent it in a kilobyte which can just be inside the source code.\\nSo, you don't need a hash and then go and fetch something, you just put the thing itself in there and know it's going to start instantly at that height and then do the same thing that we described last week.\\nSo, sync all the way to the tip and then start the genesis and make sure everything is what it should be.\"}, {\"type\":\"paragraph\",\"text\":\"Ruben Somsen:\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, that's a really nice feature that you have the entire UTXO set in essentially a single hash or a forest.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost:\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, a small little forest-\"}, {\"type\":\"paragraph\",\"text\":\"Ruben Somsen:\"}, {\"type\":\"paragraph\",\"text\":\"One kilobyte, yeah.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum:\"}, {\"type\":\"paragraph\",\"text\":\"Are there more benefits?\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost:\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, so the last one would be, you could sync with a phone node.\\nSo right now, if you have a node on your phone, it might be very slow.\\nMaybe with this proposal, it wouldn't be slow, but let's say it's still slow.\\nWhat you would do is you sync your node on your desktop or whatever it is, you scan a QR code which can be pretty long, and now your little phone has the recent UTXO set and that doesn't even require any kind of commitments, because your phone trusts your laptop.\\nSo that's a feature you could use right now.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum:\"}, {\"type\":\"paragraph\",\"text\":\"Are there any downsides or risks? Ruben, you thought about this?\"}, {\"type\":\"paragraph\",\"text\":\"Ruben Somsen:\"}, {\"type\":\"paragraph\",\"text\":\"Sure, but I want to add one more interesting feature that we haven't discussed yet.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost:\"}, {\"type\":\"paragraph\",\"text\":\"Before we burn it all down.\"}, {\"type\":\"paragraph\",\"text\":\"Ruben Somsen:\"}, {\"type\":\"paragraph\",\"text\":\"Before we burn it down, yeah.\\nIt's a good question though.\\nAnd that's parallel validation.\\nSo what you can do is, you can theoretically take two computers and just take a Utreexo hash off the middle state of the blockchain.\\nSo, if we're at block 2000, you just take block 1000 and you take the Utreexo hash from that moment in time, and then you start validating 1000 to 2000.\\nAnd on the other computer, you start validating 0 to 1000.\\nAnd if they match up after you validated both, then you validate the entire blockchain while splitting up the work.\\nAnd that's interesting and can be very useful, I think, maybe in the future also when you have more and more CPUs on a single chip.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost:\"}, {\"type\":\"paragraph\",\"text\":\"Right, so it wouldn't be necessarily multiple computers doing this, but just multiple chips doing it, because we see that clock speed is not going up much.\\nBut you get more and more parallel stuff, and the problem with the Bitcoin chain is, you can verify signatures in parallel and a Bitcoin node does that, but some things are intrinsically serial, so you cannot verify block 10 before you've verified block 9, and it's nice if you can get rid of that.\"}, {\"type\":\"paragraph\",\"text\":\"Ruben Somsen:\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, so now you can essentially.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost:\"}, {\"type\":\"paragraph\",\"text\":\"You can too with the Assume UTXO but you need multiple, very large snapshots.\"}, {\"type\":\"paragraph\",\"text\":\"Ruben Somsen:\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, exactly.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost:\"}, {\"type\":\"paragraph\",\"text\":\"So, very cool stuff.\\nSo let's burn it down.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum:\"}, {\"type\":\"paragraph\",\"text\":\"Go for the kill, Ruben.\"}, {\"type\":\"paragraph\",\"text\":\"Ruben Somsen:\"}, {\"type\":\"paragraph\",\"text\":\"One more thing to add is apparently you can also do a backwards validation.\\nI'm not sure exactly how it works, but apparently you can go from block 1000 to 999, so that's possible too.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost:\"}, {\"type\":\"paragraph\",\"text\":\"Well, you need to, because you need to be able to roll back.\"}, {\"type\":\"paragraph\",\"text\":\"Ruben Somsen:\"}, {\"type\":\"paragraph\",\"text\":\"That too, yeah.\\nI just haven't looked into that sufficiently to fully grasp it-\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost:\"}, {\"type\":\"paragraph\",\"text\":\"You just explained that in order to prove that something is in a Merkle tree, that's the same thing you can do to change something in a Merkle tree.\\nSo you can change the old thing with the new thing that way, or you can change the new thing with the old thing.\"}, {\"type\":\"paragraph\",\"text\":\"Ruben Somsen:\"}, {\"type\":\"paragraph\",\"text\":\"Right, so it makes sense.\\nI agree with that, I just haven't sat down and just gone through it.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost:\"}, {\"type\":\"paragraph\",\"text\":\"One other thing we can also mention is that this tree that we just described, the general name for it is an accumulator.\\nIt's something that you can use to add stuff to, and in this case also remove stuff from.\\nBut there are all sorts of mathematical tricks you can deploy to do this.\\nThis is just something that's conceptually simple.\\nIf other people than us explain it and you see it in front of you, it's very simple with the Merkle trees, but there's been other proposals, like an RSA accumulator.\\nThere's all sorts of cool cryptographic math you can do to just add things to a set and remove them from a set, essentially.\\nPerhaps another mechanism would be used eventually.\"}, {\"type\":\"heading\",\"text\":\"Challenges and Downsides of Utreexo\"}, {\"type\":\"paragraph\",\"text\":\"Ruben Somsen:\"}, {\"type\":\"paragraph\",\"text\":\"Right, and that's maybe also one of the downsides that we can talk about now, where if you start using this and then later somebody finds a better accumulator, then you have to, yet again, switch to that next proposal, which is okay as long as you don't commit it into a block.\\nBut once you make this an actual soft fork and then you find, 'Oh, there is this even better accumulator that we should have been using,' now you're stuck because you can't undo a soft fork, at least not unless you put in some kind of sunset date or something.\\nBut that's generally not really done, at least hasn't been done so far.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost:\"}, {\"type\":\"paragraph\",\"text\":\"No, so that's another reason why you wouldn't expect this to be a soft fork, unless the world is burning or it's been used for so and so long that people think, 'Okay, this is mature.' But we're nowhere near that.\\nIt's pretty experimental, as many of the things we discuss here.\"}, {\"type\":\"paragraph\",\"text\":\"Ruben Somsen:\"}, {\"type\":\"paragraph\",\"text\":\"And I guess the second thing that I consider a downside is that bandwidth seems to be pretty much the bottleneck right now for Bitcoin.\\nAnd this is something that makes that bottleneck worse.\\nSo for that reason, I personally see this as more of an option that people can opt into if, in their case, bandwidth isn't a problem, but they're CPU, or Disk I/O restricted or RAM restricted, or maybe they want to use an ASIC or something like that.\\nSo from that perspective, I don't expect everybody to use this, but I also think Sjors pointed out correctly that if the UTXO set grows to a significant degree where it does become a burden and it slows down validation, then maybe this becomes more appealing.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost:\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, so keep an eye on it.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum:\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, and I guess the increased block size in one of the variants could be considered a downside.\\nAlthough I think that-\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost:\"}, {\"type\":\"paragraph\",\"text\":\"Well, that's what we meant, with more bandwidth basically.\"}, {\"type\":\"paragraph\",\"text\":\"Ruben Somsen:\"}, {\"type\":\"paragraph\",\"text\":\"Exactly\"}",
    "body": "## Introduction\n\nAaron van Wirdum:\n\nAnd the proposal we're discussing this week is Utreexo.\n\nRuben Somsen:\n\nThat is correct.\n\nSjors Provoost:\n\nUtreexo, and the tree is for tree.\nThe thing that grows in the forest.\n\nAaron van Wirdum:\n\nDid you know that was the pun, Ruben? I didn't realize...\n\nRuben Somsen:\n\nWell, I heard Tadge say that so I was aware of that, but there is a very specific reason why I was enthusiastic to talk about it.\nWell, one, I've used it in one of the things I've been working on so I like Utreexo a lot conceptually.\nBut there's also a close friend of mine, Calvin Kim, who was a regular attendee of the Seoul Bitcoin meetup who is now actively working on Utreexo together with Tadge and I told him I would shout out the other guys that are working on the project.\nJannis Trulsen, which is apparently not a Dutch person.\nI think he's German or something.\nAnd Niklas G\u00f6gge.\nHopefully I pronounce it correctly, but those are the four guys that are currently working on Utreexo.\nHopefully it will eventually get to a point where this can be useful for Bitcoin.\nBut we should obviously start explaining what Utreexo is, because we're just talking about the conceptual-\n\nSjors Provoost:\n\nOh, we've got to keep it exciting.\n\nAaron van Wirdum:\n\nWell, really quick.\nAre you guys with DG Lab?\n\nRuben Somsen:\n\nNo, no, that's completely separate, yeah.\nI'm not super familiar with this, but Tadge is with MIT, and then the other three guys are just working on this separately.\nSo they're not involved with MIT or DG Labs.\nDG Labs mainly works on DLC.\nThat's one of their main projects.\n\n## The UTXO Set and Its Challenges\n\nAaron van Wirdum:\n\nSo Sjors, what problem are we solving?\n\nSjors Provoost:\n\nProblem, problem.\nChallenge.\nNo, so one of the constraints when you're syncing a new Bitcoin node, we talked about sync a couple times, is the amount of RAM memory you have.\nNow, it's not a hard constraint.\nYou don't need a lot of RAM, but if you want to sync it fast, you do.\nAnd the reason is this thing called the UTXO set.\nThe UTXO set is a list of coins that you own, and we talked about that last time, I guess.\nBut every time the new block comes in, what you do is, for every transaction in the block, you check if it's spending something that exists, namely, one UTXO.\nAnd so in order to check if something exists, well, it has to be somewhere.\nIt has to be in a database of sorts.\nAnd where is that database? Well, if that database is sitting in your RAM memory, that's extremely fast.\nIf on the other hand, that database is sitting on your hard disk, if it's an SSD drive, it's meh.\n\nAaron van Wirdum:\n\nWhat you mean is, it's much faster to look up if it's in there.\nIf it's in your RAM, then your computer will be able to look it up within...\nWell, I don't know how fast, but faster than if it's on your drive, at least.\n\nSjors Provoost:\n\nIt's probably at least 10 times faster than if it's on your SSD drive, and if you're using a magnetic drive, it's even worse.\nAnd then the other side of it is, once you create this new coin, which the transaction does on the output side, it has to store that.\nSo it has to write it somewhere on the disc, which is also slow.\nAnd if you have a magnetic spin disc, then it has to move to read somewhere and it has to move somewhere else to write again and these are gigabytes apart, so that's horrible.\n\nAaron van Wirdum:\n\nSo to make it very concrete, I guess the biggest difference you would notice when you're syncing a new node, and if you would somehow be able to keep the UTXO set in RAM, it will only take, I don't know, couple hours?\n\nSjors Provoost:\n\nBut it depends on your computer.\nI have a somewhat recent MacBook Pro and I think I can sync the whole chain in five hours-\n\nAaron van Wirdum:\n\nIf you keep it in RAM.\n\nSjors Provoost:\n\nBut that takes about 11 gigabytes of RAM.\nBut if you do it on, say, a typical Raspberry Pi, you might have two gigabytes these days, maybe four.\nSo that means you're going to sync the chain and you're going to keep as much as possible in RAM, but at some point it overflows, the UTXO set, and then usually what it does is it writes everything to disk, clears everything, and then it starts caching again, and this takes a long time.\nIt can take days on these machines.\n\nAaron van Wirdum:\n\nSo the point being, as you can keep more of the UTXO set in RAM, you'll sync faster, or your node will just work faster, operate faster in general.\nSo it would be good if we could somehow decrease the size of the UTXO set.\n\nSjors Provoost:\n\nWell, we can't decrease the size of the UTXO set.\nThat's the problem.\n\nAaron van Wirdum:\n\nThat's a bummer.\n\nSjors Provoost:\n\nThere is a limit on the size of blocks.\n\nAaron van Wirdum:\n\nWell, it can decrease-\n\nSjors Provoost:\n\nFor megabytes.\n\nAaron van Wirdum:\n\nIt can decrease, it's just not something we can do.\n\nSjors Provoost:\n\nYeah, it decreases when people spend-\n\nAaron van Wirdum:\n\nI don't know how much UTXOs you own, Sjors.\nI bet a lot, so maybe you could play a part in decreasing the UTXO.\n\nSjors Provoost:\n\nI have millions of UTXOs on testnet.\nNo, so the idea is that if you're spending more coins than you're creating, then obviously the number of UTXOs goes down and the RAM usage goes down.\nBut there's a lot of junk in the UTXO set, because there were people in the old days that created transactions to multi-sig addresses that were fake just in order to put pictures of Obama in the blockchain.\nAnd those are all sitting in your RAM because you node has no idea that they're nonsense.\n\nSjors Provoost:\n\nBut the other thing is, if we expect everybody in the world eventually to use Bitcoin and everybody to have at least one or two UTXOs, well, that's a lot of RAM.\nThat's like seven billion people.\nAnd there's really no limit to how big that can get, there's no constraint.\nIt might take a while because it takes a lot of fees to create all these transactions, but eventually it could take as much RAM as...\nThere's no limit, and we don't like things that don't have a limit.\nUnbounded stuff, it's a bit bad.\n\nAaron van Wirdum:\n\nYeah, you mean the UTXO set can get as big as it will get until the point where not everyone can use it and sync it from RAM?\n\nSjors Provoost:\n\nFewer and fewer people will have enough RAM to sync it quickly and that could become a problem.\n\nAaron van Wirdum:\n\nOkay, so you agree, it's a problem.\nNot just a challenge.\nIt a problem, Sjors.\nNow how do we solve it?\n\n## What is Utreexo\n\nSjors Provoost:\n\nYeah, it's a challenge.\nWell, one way to solve it is Tadge Dryja's proposal, the Utreexo.\n\nRuben Somsen:\n\nThat's right, yep.\n\nSjors Provoost:\n\nAnd the idea there, I guess that's what we'll need to explain, right? How that works.\n\nAaron van Wirdum:\n\nWell, Ruben wanted to explain it to us, so let's hear it.\n\nRuben Somsen:\n\nWell, I first wanted to say that I thought, Aaron, your analogy with basically saying that it's pruning for the UTXO set, I thought that was a very good analogy, where currently we have pruning in Bitcoin-\n\nAaron van Wirdum:\n\nThis was an off-record analogy.\nBut now it's an on-record analogy.\n\nRuben Somsen:\n\nNow's it's on record, yes.\nI'm repeating something that you had told me before the show.\nSo with Bitcoin, currently you have pruning in the sense that you take a block, you process it, you extract the UTXO set out, basically from all the blocks, and then that's all that you keep.\nYou only keep the UTXO set and then you can throw everything else away and that's called pruning.\n\nRuben Somsen:\n\nThere is a downside, which is that then you don't have the blocks.\nSo if you want to prove to another person that the UTXO set is valid, you can't actually give them the blocks, but the assumption is that somebody else will have the block so it's fine.\n\nRuben Somsen:\n\nAnd here, what you're pruning is something else.\nYou're pruning UTXO sets and your essentially throwing away all the transactions and you're just keeping a Merkle roots.\nAnd inside of that Merkle roots is basically a commitment.\nEvery single UTXO is committed in there and you only keep the Merkle proofs of the UTXOs that you care about, that you own.\n\nAaron van Wirdum:\n\nWhat is a Merkle root?\n\nSjors Provoost:\n\nMaybe to put it another way, normally when somebody sends you a transaction, the transaction says, 'I'm spending this input and you, as the person running a node, has the responsibility to check whether that input exists in your own database.' And you're flipping this around and you're telling the other node, 'I have no idea which coins exist, because I don't have RAM.\nYou prove to me that this coin actually existed.' And that's what you use this Merkle proof for.\nSo the burden of evidence is reversed here.\nYou need to prove that a transaction exists.\nAnd then the question is how are we going to do that?\n\n## Technical Mechanisms of Utreexo\n\nAaron van Wirdum:\n\nOkay, so we're reversing the burden of proof.\nUsually when you're sending a transaction...\nWhen I send a transaction to you, Sjors, then you check inside your node and the database with your UTXO set, whether the transaction is spending valid UTXOs.\n\nSjors Provoost:\n\nYes.\n\nAaron van Wirdum:\n\nNow I'm actually going to have to provide you with the proof that my transaction is spending existing UTXOs.\nHowever, you still need something in order to make sure that my proof is valid, and that's this Utreexo, which is a hash tree.\n\nSjors Provoost:\n\nYes, a Merkel tree of hashes.\n\nAaron van Wirdum:\n\nA Merkel tree, right.\nSo what is this and how does it work?\n\nSjors Provoost:\n\nIt's kind of nice.\nAll the UTXOs that are in existence would be put into this tree and everybody can construct this tree if you replay the whole blockchain.\nBut the question is-\n\nAaron van Wirdum:\n\nIt's not an actual tree though, is it, Sjors?\n\nSjors Provoost:\n\nIt is not an actual tree.\n\nRuben Somsen:\n\nDo you give it water?\n\nSjors Provoost:\n\nNo, basically what the tree would look like is you have the first UTXO, and then the second UTXO right next to each other, and then you take the hash of those two, basically combined, and that is one new hash.\nSo, you see this little pyramid shape and you can do that again for another two UTXOs that exist.\nThey have their own little mini tree, but now you see, oh, there's two trees.\nLet me just combine those two trees.\n\nAaron van Wirdum:\n\nTwo hashes, and you're combining these two hashes, yes.\n\nSjors Provoost:\n\nSo now you have four UTXOs.\nTwo of them are shared and then those two are shared again.\n\nAaron van Wirdum:\n\nYeah, so you end up with one hash?\n\nSjors Provoost:\n\nYou end up with one hash.\nNow, the key here is that these things are so called, I believe, perfect trees, which means that they are always a multiple of two.\n\nAaron van Wirdum:\n\nAnd so now the challenge is that for every new block, this tree needs to be updated, right? Because we have one big tree for all of the UTXOs.\nNow a new block is found, it includes all sorts of new transactions, so new UTXOs exist and old UTXOs are destroyed, so now we need a new tree.\n\nSjors Provoost:\n\nYeah.\nWell, it's even more than one tree, right? It is a forest.\nEvery tree has to be a multiple of two, so there can be four things at the bottom or eight things at the bottom or 16 things at the bottom.\nWhen you have a number of transactions that doesn't fit that way, you'll have multiple trees that look like that.\nSo you have a collection of trees for which you really only need to remember the top hashes.\nAnd now the question is, how do you add something to that tree?\n\nAaron van Wirdum:\n\nSo you might have one tree with 16 at the bottom, one tree with eight at the bottom, one tree with two UTXOs at the bottom.\n\nSjors Provoost:\n\nOne at the bottom.\n\nAaron van Wirdum:\n\nYeah, exactly.\nSo you have multiple trees.\n\nSjors Provoost:\n\nYeah, right.\nAnd now in order to prove that something is in this tree and also to replace it with, say, the output...\nBecause basically you destroy one UTXO so that you're spending and you create a new UTXO you're creating.\n\nSjors Provoost:\n\nSo you can actually take the UTXO that you're spending out of the tree and then put the new one into the tree.\nAnd in order to do that, you need to recalculate the tree and you do that by knowing its neighbors.\nSo, the way you prove that something is inside a Merkle tree is to say, well, at the bottom of the tree, there's these two pairs and I'm going to give you the other side.\nAnd then at the next level, again, there's a pair and I'm going to give you the other side.\nAnd again and again and again, and that proves that something is actually in the tree.\nAnd that's exactly the same information that you need to put something else at the bottom of the tree, and then provide the new hash.\n\nAaron van Wirdum:\n\nSo by putting something else at the bottom of the tree, to be clear, the entire tree changes, or at least the one hash you end up with changes.\nYou're just computing a whole new tree, but you're able to do that because you have all the data you need.\nSo you can add things to the forest and you can remove things from the forest.\nIt's actually possible.\nIt's actually easier than I thought it would be when I saw Tadge explain it.\nI don't know if it's going to be easy when people hear us explain this.\n\nSjors Provoost:\n\nI recommend looking at Tadge explain it after you hear us explain it, because you need to see it-\n\nAaron van Wirdum:\n\nYeah, visuals really help.\n\nRuben Somsen:\n\nExactly.\nI think his presentations are great.\nHe's very good at explaining it and he has slides so that's a lot easier than what we are doing.\nWe're trying to explain it in words.\nEspecially in Merkle trees, I think, it's great if you have an actual picture there.\n\nSjors Provoost:\n\nBut now the idea is that you're not tracking everything.\nSo you could, when you're syncing the blockchain, keep track of the entire tree, but then you need a lot of RAM, just like in the original scenario.\nBut what you'll actually do is you're going to remember the top of every tree and there might be 10 or 20 or whatever trees, and that's all you're going to remember, and when somebody has a new transaction that you want to verify, they need to give you the Merkle proofs for all the inputs that they're spending, so they prove that they exist.\nAnd then they also tell you which outputs are there, which are going to be swapped in at the same places where those inputs were.\nPlus new trees if it's making more.\n\nRuben Somsen:\n\nThe outputs are under blocks, right?\n\nRuben Somsen:\n\nYeah, so that's really, I think, the very elegant side of Utreexo, where the same proofs that are proving that these UTXOs are in the UTXO set, are also exactly what you need to remove them from the set, update your root hash and add the new UTXOs from the latest block, so that works out quite elegantly.\n\n## Implementation and Practical Considerations\n\nAaron van Wirdum:\n\nOkay, so in an ideal scenario...\nWhat we've been explaining so far is the ultimate version of Utreexo, so let's stick with that for a minute.\nSo I wanted to send a transaction to the network and you, Sjors, you had a node and you wanted to validate the transaction.\nYou have this tree in your RAM apparently.\nThat's what's nice about it.\n\nSjors Provoost:\n\nI have the top of the trees in my RAM.\n\nAaron van Wirdum:\n\nYeah, exactly.\nSo now I want to send this transaction, so now it's my responsibility to send to you the transaction, as well as the proof that the transaction is valid, which also includes information for you so you know where to find it in the forest, right?\n\nSjors Provoost:\n\nExactly.\nYou need to prove to me that the things you are spending are in the forest, because I forgot what the forest looked like.\n\nAaron van Wirdum:\n\nAll right, so that's me sending the transaction with the proof.\nNow, the other way you could get a transaction is if it's already in the block.\nSo if a miner mines a block and the transaction is in there, you still have your Utreexo thing on your node.\nBut how do you now get the proof?\n\nSjors Provoost:\n\nRight, because if you spend the transaction, you're not going to talk to every node that ever downloaded a block to send that proof around.\nSo how does that proof get to the node?\n\nAaron van Wirdum:\n\nThat wouldn't scale very well, at least.\n\nSjors Provoost:\n\nNo.\nWell, what you would probably want to have is something called a bridge node.\n\nAaron van Wirdum:\n\nA bridge node.\n\nSjors Provoost:\n\nA bridge node would be a node that has the actual UTXO set, the old-fashioned way, so it has lots of RAM or it's just slow.\nAnd it produces all these proofs and it sends them around to whoever wants them.\n\nRuben Somsen:\n\nYeah, so what essentially happens is that when this bridge node receives a transaction and this transaction does not have a Merkle proof, proving the inclusion in the Utreexo root, this bridge node basically just takes the proof that they have and they attach it to the transaction and now they send it on to other Utreexo nodes.\nIt's a bridge between Utreexo nodes and non-Utreexo nodes.\n\nAaron van Wirdum:\n\nBut they could also construct the proof themselves, right? If they see a certain transaction is included in a block, they can just figure-\n\nSjors Provoost:\n\nThat's right, there's nothing secret here.\nSo if you have the original UTXO set in memory somewhere, you can construct the proof for any transaction.\n\nRuben Somsen:\n\nAnd they have the entire tree, essentially.\nSo the entire UTXO tree that you create and then prune, they just don't prune it essentially.\nSo they just have the full UTXO set.\nBasically, the UTXO set with all the Merkle proofs connecting to it, so then they can just take any UTXO in there and create a proof from it and just send it on, or for an entire block or whatever.\n\nAaron van Wirdum:\n\nRight, so what would happen in practice? Sjors, your node would see a transaction in a block and it would wonder, 'Hmm, is there actually proof for that? I never saw the transaction before.' And you would request it from a bridge node.\n\nSjors Provoost:\n\nMy guess is, when you get the whole block, you're going to call a bridge node and say, 'Give me the proofs for that entire block.'\n\nAaron van Wirdum:\n\nJust all of them?\n\nSjors Provoost:\n\nYeah.\n\nAaron van Wirdum:\n\nWhy not just the ones you need, the ones you haven't seen before?\n\nSjors Provoost:\n\nMy guess is that's too much back and forth because if you have to call a node for every single individual transaction, and that's a lot of overhead, whereas just downloading a couple hundred kilobytes is easier.\n\nAaron van Wirdum:\n\nAnyways, that's an implementation detail.\n\nRuben Somsen:\n\nYeah, but I think this is just an automated process, where you just connect to the network.\nBut the problem is, when you're the first Utreexo node, and you're pruning all the data and then everybody else on the network is an old-fashioned node, like the way we run it today, nobody's going to give you the proofs, right?\n\nRuben Somsen:\n\nSo what you need is at least a single bridge node, so at least you can connect to that one.\nAnd then other people are connecting to the bridge node because the bridge node basically speaks both languages.\nThey speak the Utreexo language and they speak the old-fashioned language.\nSo they translate for you, and as long as one bridge node exists, it can bootstrap the network essentially, but they don't have to have special rules.\nFrom the perspective of the Utreexo node, the bridge node is just also Utreexo node, and from the perspective of the old-fashioned nodes, it's just an old-fashioned node.\n\nSjors Provoost:\n\nRight, that's another point.\nSo, you don't need everybody to do this translation, only one person needs to do it or a couple.\nThe other nodes know how to relay that information even if they can't produce it, so that's good news.\nBut of course-\n\nAaron van Wirdum:\n\nCan we have a future without bridge nodes?\n\nSjors Provoost:\n\nWell, we should point out what the problem is with these bridge nodes, because they are nice people.\nWe don't want to rely on nice people.\nThat's not how we roll, because nice people can stop being nice.\n\nAaron van Wirdum:\n\nOr they can be forced to stop being nice.\n\nSjors Provoost:\n\nOr they can just disappear or run out of battery.\nThen you can look at the longer-term picture, if people like this given the advantages, or even if they don't like it, if the UTXO set just becomes insane and it just takes too long to sync on any normal computer, then you could basically make a soft fork which contains the proofs.\nSo the proofs become part of the blockchain, just like SegWit added the whole bunch of data to blocks.\nYou could then add these proofs to the blocks, making the blocks even bigger.\nBut the trade-off there is, you have more bandwidth, but you have less RAM need.\n\nAaron van Wirdum:\n\nYeah, the reason this could be done as a soft fork, same with SegWit, is because you'd include the hash of the proofs somewhere in the coinbase transaction or something like that.\nOld nodes just won't notice anything interesting, but upgraded nodes will see a whole tree, which they share with each other, which does make the blocks a bit bigger for them.\n\nSjors Provoost:\n\nYeah, so old nodes keep doing what they're doing.\nThey get blocks, they can verify those blocks, because nothing changes about the transactions in the blocks.\nNew nodes will save some RAM memory.\nThey'll use that extra data.\nThey'll download that extra data and they'll use it.\nThat's generally the idea.\n\nRuben Somsen:\n\nYeah, so personally at least, I think this is not likely to happen until we really get a UTXO set bloating issue where the UTXO set becomes so big that people start liking this trade-off to the point where it's preferable.\nI think as long as we're not at that point, I don't think we'll see this as a soft fork, but that's my personal view.\n\n## Potential Benefits of Utreexo\n\nSjors Provoost:\n\nI do want to point out some cool things you can do with it.\n\nAaron van Wirdum:\n\nYes, tell us the bullish part, Sjors.\n\nSjors Provoost:\n\nI'm all just copy pasting from what Tadge said, we like to do that.\nBasically because you don't need a lot of RAM, you can start doing things in specialized hardware like in ASIC, because one of the things that's hard to do in an ASIC is lots of memory.\nAnd having specialized hardware, maybe it's a part of your chip, so maybe Bitcoin becomes the standard and every phone that you buy has a CPU, has a little mini processor right next to it that just checks all the Bitcoin validation rules.\nAnd because it's custom silicon, it might be able to validate the entire blockchain at the speed that it can download it, which is pretty cool.\n\nAaron van Wirdum:\n\nAn ASIC for regular nodes?\n\nSjors Provoost:\n\nExactly, yeah.\nSo not to mine coins, but to verify coins, which would be cool.\nAnd then you have the protocol literally set in stone or at least set in silicon.\nAnd of course soft forks can still happen under that circumstance, but if somebody wants to do a hard fork, you'd have to break all the node hardware, and not just all the mining hardware.\nSo, that's a nice extra barrier to not do hard forks.\n\nRuben Somsen:\n\nIt's ossification-\n\nAaron van Wirdum:\n\nIt's also not perfect for soft fork.\nIs that what you just said, Ruben?\n\nRuben Somsen:\n\nNo, no.\nThat's what Sjors just said.\n\nSjors Provoost:\n\nI think its hard to verify soft forks.\nYou don't have to verify the soft fork, but you can't verify the soft fork, at least not with the accelerated hardware, so your computer would have to slow down to check all the new rules whenever it encounters it.\n\nAaron van Wirdum:\n\nYeah, or you would have to buy a new phone because the soft fork happened.\n\nSjors Provoost:\n\nExactly.\n\nRuben Somsen:\n\nYour phone is too old, maybe it's possible, right? That's that's what happens now.\nPeople buy new phones every couple of years, so maybe it's not too much to ask.\n\nAaron van Wirdum:\n\nTrue.\n\nSjors Provoost:\n\nThe other thing we talked last week about is Assume UTXO thing, where one of the problems is, now when you start, you still need to get that three gigabyte thing from somewhere.\nAnd if this thing becomes a hundred gigabytes, you have to get that from somewhere.\nBut now, with this proposal, we just have a kilobyte.\nSo you can put the entire UTXO set, you can represent it in a kilobyte which can just be inside the source code.\nSo, you don't need a hash and then go and fetch something, you just put the thing itself in there and know it's going to start instantly at that height and then do the same thing that we described last week.\nSo, sync all the way to the tip and then start the genesis and make sure everything is what it should be.\n\nRuben Somsen:\n\nYeah, that's a really nice feature that you have the entire UTXO set in essentially a single hash or a forest.\n\nSjors Provoost:\n\nYeah, a small little forest-\n\nRuben Somsen:\n\nOne kilobyte, yeah.\n\nAaron van Wirdum:\n\nAre there more benefits?\n\nSjors Provoost:\n\nYeah, so the last one would be, you could sync with a phone node.\nSo right now, if you have a node on your phone, it might be very slow.\nMaybe with this proposal, it wouldn't be slow, but let's say it's still slow.\nWhat you would do is you sync your node on your desktop or whatever it is, you scan a QR code which can be pretty long, and now your little phone has the recent UTXO set and that doesn't even require any kind of commitments, because your phone trusts your laptop.\nSo that's a feature you could use right now.\n\nAaron van Wirdum:\n\nAre there any downsides or risks? Ruben, you thought about this?\n\nRuben Somsen:\n\nSure, but I want to add one more interesting feature that we haven't discussed yet.\n\nSjors Provoost:\n\nBefore we burn it all down.\n\nRuben Somsen:\n\nBefore we burn it down, yeah.\nIt's a good question though.\nAnd that's parallel validation.\nSo what you can do is, you can theoretically take two computers and just take a Utreexo hash off the middle state of the blockchain.\nSo, if we're at block 2000, you just take block 1000 and you take the Utreexo hash from that moment in time, and then you start validating 1000 to 2000.\nAnd on the other computer, you start validating 0 to 1000.\nAnd if they match up after you validated both, then you validate the entire blockchain while splitting up the work.\nAnd that's interesting and can be very useful, I think, maybe in the future also when you have more and more CPUs on a single chip.\n\nSjors Provoost:\n\nRight, so it wouldn't be necessarily multiple computers doing this, but just multiple chips doing it, because we see that clock speed is not going up much.\nBut you get more and more parallel stuff, and the problem with the Bitcoin chain is, you can verify signatures in parallel and a Bitcoin node does that, but some things are intrinsically serial, so you cannot verify block 10 before you've verified block 9, and it's nice if you can get rid of that.\n\nRuben Somsen:\n\nYeah, so now you can essentially.\n\nSjors Provoost:\n\nYou can too with the Assume UTXO but you need multiple, very large snapshots.\n\nRuben Somsen:\n\nYeah, exactly.\n\nSjors Provoost:\n\nSo, very cool stuff.\nSo let's burn it down.\n\nAaron van Wirdum:\n\nGo for the kill, Ruben.\n\nRuben Somsen:\n\nOne more thing to add is apparently you can also do a backwards validation.\nI'm not sure exactly how it works, but apparently you can go from block 1000 to 999, so that's possible too.\n\nSjors Provoost:\n\nWell, you need to, because you need to be able to roll back.\n\nRuben Somsen:\n\nThat too, yeah.\nI just haven't looked into that sufficiently to fully grasp it-\n\nSjors Provoost:\n\nYou just explained that in order to prove that something is in a Merkle tree, that's the same thing you can do to change something in a Merkle tree.\nSo you can change the old thing with the new thing that way, or you can change the new thing with the old thing.\n\nRuben Somsen:\n\nRight, so it makes sense.\nI agree with that, I just haven't sat down and just gone through it.\n\nSjors Provoost:\n\nOne other thing we can also mention is that this tree that we just described, the general name for it is an accumulator.\nIt's something that you can use to add stuff to, and in this case also remove stuff from.\nBut there are all sorts of mathematical tricks you can deploy to do this.\nThis is just something that's conceptually simple.\nIf other people than us explain it and you see it in front of you, it's very simple with the Merkle trees, but there's been other proposals, like an RSA accumulator.\nThere's all sorts of cool cryptographic math you can do to just add things to a set and remove them from a set, essentially.\nPerhaps another mechanism would be used eventually.\n\n## Challenges and Downsides of Utreexo\n\nRuben Somsen:\n\nRight, and that's maybe also one of the downsides that we can talk about now, where if you start using this and then later somebody finds a better accumulator, then you have to, yet again, switch to that next proposal, which is okay as long as you don't commit it into a block.\nBut once you make this an actual soft fork and then you find, 'Oh, there is this even better accumulator that we should have been using,' now you're stuck because you can't undo a soft fork, at least not unless you put in some kind of sunset date or something.\nBut that's generally not really done, at least hasn't been done so far.\n\nSjors Provoost:\n\nNo, so that's another reason why you wouldn't expect this to be a soft fork, unless the world is burning or it's been used for so and so long that people think, 'Okay, this is mature.' But we're nowhere near that.\nIt's pretty experimental, as many of the things we discuss here.\n\nRuben Somsen:\n\nAnd I guess the second thing that I consider a downside is that bandwidth seems to be pretty much the bottleneck right now for Bitcoin.\nAnd this is something that makes that bottleneck worse.\nSo for that reason, I personally see this as more of an option that people can opt into if, in their case, bandwidth isn't a problem, but they're CPU, or Disk I/O restricted or RAM restricted, or maybe they want to use an ASIC or something like that.\nSo from that perspective, I don't expect everybody to use this, but I also think Sjors pointed out correctly that if the UTXO set grows to a significant degree where it does become a burden and it slows down validation, then maybe this becomes more appealing.\n\nSjors Provoost:\n\nYeah, so keep an eye on it.\n\nAaron van Wirdum:\n\nYeah, and I guess the increased block size in one of the variants could be considered a downside.\nAlthough I think that-\n\nSjors Provoost:\n\nWell, that's what we meant, with more bandwidth basically.\n\nRuben Somsen:\n\nExactly\n\n\n",
    "body_type": "markdown",
    "created_at": "2020-10-30T00:00:00.000Z",
    "domain": "https://btctranscripts.com/",
    "url": "https://btctranscripts.com/bitcoin-explained/what-is-utreexo",
    "categories": [
        "podcast"
    ],
    "tags": [
        "utreexo"
    ],
    "media": "https://www.youtube.com/watch?v=sWK7aqPjQLI",
    "authors": [
        "Sjors Provoost",
        "Aaron van Wirdum",
        "Ruben Somsen"
    ],
    "indexed_at": "2024-03-21T16:33:36.179Z",
    "transcript_by": "Sjors, edilmedeiros",
    "summary": "In a comprehensive discussion on the future of Bitcoin scalability and efficiency, Sjors Provoost, Aaron van Wirdum, and Ruben Somsen delved into the potential of Utreexo, a novel proposal conceptualized by Tadge Dryja. The dialogue commenced with an exploration of Utreexo's etymology, revealing its clever play on \"tree\" structures, which are central to this proposal's approach to data organization within blockchain networks. Highlighting contributions from Calvin Kim, Jannis Trulsen, and Niklas G\u00f6gge, Somsen shared his connection to the project, setting the stage for a detailed examination of its mechanics and implications.\n\nThe conversation transitioned into an analysis of the Unspent Transaction Output (UTXO) set's impact on Bitcoin\u2019s operational efficiency, particularly regarding node synchronization times. Provoost illuminated how the size of the UTXO set, influenced by global adoption, poses significant challenges due to its ever-expanding nature, necessitating an increasing amount of RAM for efficient data processing and storage. This dynamic underscores the critical need for scalable solutions to accommodate the growing demands on Bitcoin\u2019s infrastructure without compromising security or functionality.\n\nUtreexo emerged in the discussion as a groundbreaking solution aimed at addressing these challenges. By introducing a mechanism that shifts the burden of proof from nodes to transaction initiators, Utreexo leverages Merkle trees to significantly reduce the volume of data nodes are required to store and manage. This approach not only alleviates memory pressure on nodes but also optimizes the verification process, marking a paradigm shift in how transactions are validated within the network.\n\nFurther dissecting Utreexo\u2019s technical framework, the speakers outlined its reliance on a dynamic forest of Merkle trees, enabling efficient updates to the UTXO set with minimal computational overhead. This model promises enhanced performance and scalability by allowing nodes to operate with just top-level information, streamlining the validation process for new transactions. However, integrating Utreexo into existing blockchain systems presents challenges, notably in terms of compatibility and transition strategies, leading to discussions around 'bridge nodes' and potential incorporation through soft forks.\n\nThe discussion also ventured into innovative applications of technology in Bitcoin validation, such as utilizing ASICs for transaction verification and exploring proposals like \"Assume UTXO\" for reducing initial sync times. These developments underscore a broader trend towards embedding Bitcoin\u2019s protocol rules into hardware and enhancing cross-device synchronization, potentially transforming user experiences across various platforms.\n\nMoreover, the conversation touched upon parallel validation techniques using Utreexo hashes, offering a glimpse into future possibilities for overcoming the serial limitations of block validation. Despite the optimism surrounding these advancements, the speakers acknowledged inherent challenges, including bandwidth constraints and the risk of technological obsolescence, emphasizing the importance of ongoing experimentation and innovation.\n\nIn conclusion, the podcast provided a deep dive into the complexities and opportunities associated with improving Bitcoin's scalability and efficiency through Utreexo and related technologies. By reimagining data storage and verification processes, Utreexo and other proposals offer promising paths toward more sustainable growth for Bitcoin, highlighting the critical role of continued innovation in shaping the future of blockchain networks."
}