{
    "id": "bitcointranscripts+bitcoin-explained+bitcoin-core-v24",
    "title": "Bitcoin Core 24.0",
    "body_formatted": "{\"type\":\"heading\",\"text\":\"Intro\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:00:20\"}, {\"type\":\"paragraph\",\"text\":\"Live from Utrecht, this is Bitcoin\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:00:23\"}, {\"type\":\"paragraph\",\"text\":\"Explained.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:00:24\"}, {\"type\":\"paragraph\",\"text\":\"Hey Sjors.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:00:25\"}, {\"type\":\"paragraph\",\"text\":\"What's up?\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:00:26\"}, {\"type\":\"paragraph\",\"text\":\"I'm good.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:00:27\"}, {\"type\":\"paragraph\",\"text\":\"How do you like the weather?\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:00:29\"}, {\"type\":\"paragraph\",\"text\":\"It was too hot all summer and then it was nice for about a week and now we're back to too cold.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:00:36\"}, {\"type\":\"paragraph\",\"text\":\"This is gonna be a great winter.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:00:39\"}, {\"type\":\"paragraph\",\"text\":\"That's winter for you at least for now it's still a little bit light.\\nFor example while we're recording It's still light and it's past six.\\nThat's the really dreadful moment for me when the clock changes.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:00:55\"}, {\"type\":\"paragraph\",\"text\":\"Well, we go to standard time, although some people want to change it and make the summertime the default, which I think is terrible.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:01:03\"}, {\"type\":\"paragraph\",\"text\":\"I would definitely prefer that, just because I don't get up that early anyways so I like to optimize my sun hours\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:01:13\"}, {\"type\":\"paragraph\",\"text\":\"I mean ultimately you can just get up whenever you want to get up right unless you have to be in a physical place.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:01:19\"}, {\"type\":\"paragraph\",\"text\":\"But you are kind of reliant on the rest of society around you, right?\\nStores close at a certain time and people get out of work at a certain time, might be your friends, or you want to record a podcast at a certain time because you want to eat at a certain time.\\nSo I don't have that full flexibility that you suggest because of all these people around me.\"}, {\"type\":\"paragraph\",\"text\":\"Okay, Sjors, I'm going to shill the conference one more time.\\nConference is coming up.\\nYou can get a 10% discount if you know how to spell Sjorsnado, that's your discount code.\\nSjorsnado on I think it's b.tc/amsterdam.\\nI think that's the website for the conference.\\nAll right, Sjors, We're going to discuss the new Bitcoin Core release that's coming up.\\nIt's not here yet.\"}, {\"type\":\"heading\",\"text\":\"What does it mean\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:02:09\"}, {\"type\":\"paragraph\",\"text\":\"It's Bitcoin Core 24.0, that's the upcoming one.\\nReal quick for maybe there are some new listeners, What does it mean that there's a new Bitcoin Core release coming out?\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:02:18\"}, {\"type\":\"paragraph\",\"text\":\"Because Bitcoin Core does not have a roadmap or anything like that, there is just a new release every six months or so.\\nAnd things that are ready go into that new release and things that are not ready may go into another release.\\nSo there's nothing very special about these releases.\\nAnd so it's time for number 24.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:02:37\"}, {\"type\":\"paragraph\",\"text\":\"It's just an update that happens twice a year.\\nGenerally, whatever is done is done.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:02:41\"}, {\"type\":\"paragraph\",\"text\":\"Yes. And then there are some minor updates throughout the rest of the year.\\nThat might be 24.1, 24.2, etc.\\nAnd those typically are just bug fixes, but no major changes.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:02:51\"}, {\"type\":\"paragraph\",\"text\":\"And right now there's a release candidate.\\nAt the time of recording this podcast, there's I think the first release candidate for Bitcoin Core 24.\"}, {\"type\":\"heading\",\"text\":\"Release Candidate\"}, {\"type\":\"paragraph\",\"text\":\"What does a release candidate mean?\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:03:01\"}, {\"type\":\"paragraph\",\"text\":\"Kind of what the word suggests, it's a candidate for the release.\\nSo if all goes well, then the actual release will be made identical to the last candidate.\\nBut the idea is that people who know what they're doing should be downloading that release candidate and or compiling it themselves and playing around with it and making sure that nothing crashes the things they use especially if you run some sort of automated service like you might be running an exchange or maybe you're running BTC pay or something like that you want to make sure nothing breaks in your setup because Bitcoin Core tries to not break things that use it but it happens occasionally.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:03:39\"}, {\"type\":\"paragraph\",\"text\":\"If there's no report of anything breaking then this release candidate will basically be the release right?\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:03:45\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, but I think there are already some things that have been improved so there will definitely be a second release candidate.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:03:51\"}, {\"type\":\"paragraph\",\"text\":\"okay yeah, and I think in previous Bitcoin core releases there were an average of four or so.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:03:56\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, I'd say that's typical.\\nSo usually there's two weeks between them, So you release it and then maybe after a week or so, people start fixing things, and then after two weeks, there is a new one.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:04:06\"}, {\"type\":\"paragraph\",\"text\":\"Right, so realistically well technically the new Bitcoin Core 24 release could be released any day now, but practically speaking will probably be at least a couple more weeks, right?\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:04:17\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, I'd say so.\\nI think there is a release, attempted release schedule on the Bitcoin Core repository, which I think is for mid-October.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:04:28\"}, {\"type\":\"paragraph\",\"text\":\"So, there are a bunch of new features as well as bug fixes and improvements, sorry, performance improvements in this new release.\\nWe're going to discuss a couple of these.\\nThis is kind of just our selection.\\nIf this podcast was made by two other people, by Ors and Sharon, they might make a different selection.\\nBut we, Sjors and Aaron, we made the selection.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:04:59\"}, {\"type\":\"paragraph\",\"text\":\"You can look at all the commits, so all the atomic changes that go into a release, and there could be a thousand of them, but most of them are very boring, or at least they are very boring unless you are really into details of how compilers work or into cleaning up code for the sake of cleaning it up.\\nSo there's a lot of changes that are just not very interesting to discuss, although they are important and they should be, they are being, you know, they always get reviewed because any of those changes could of course be a really scary thing.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:05:29\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, I'm just saying we made a selection of some of the changes that we think are probably the most interesting\\nto you, our dear listener.\"}, {\"type\":\"heading\",\"text\":\"Download headers from peers\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:05:38\"}, {\"type\":\"paragraph\",\"text\":\"That's right.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:05:40\"}, {\"type\":\"paragraph\",\"text\":\"Okay, so let's start.\\nSjors, I think that this one is the first one mentioned in the release notes as well.\\nIt's about the peer-to-peer and network changes.\\nIs that a typo?\\nShould you just say peer-to-peer changes?\\nPeer-to-peer network changes?\\nWhatever.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:05:55\"}, {\"type\":\"paragraph\",\"text\":\"Peer-to-peer networking.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:05:57\"}, {\"type\":\"paragraph\",\"text\":\"Let's move on.\\nSo it says that there's a change and you're gonna explain to me what this is.\\nThat's the format of the podcast in case you forgot.\\nIt says download headers from peers so downloading of headers from peers has been reworked.\\nThat's right somehow.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:06:18\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, this one might be worth a separate episode, but I think we can explain the gist of it now.\\nSo when your node first starts up, it is going to find peers, which we discussed in an earlier episode, and then it's going to download headers from peers, which we've also discussed in earlier episodes.\\nSo it tries to get all the headers first.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:06:36\"}, {\"type\":\"paragraph\",\"text\":\"Hang on, so every block has a header which is essentially the hash of the block itself, right?\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:06:41\"}, {\"type\":\"paragraph\",\"text\":\"Plus a little bit of extra info that, for example, contains the timestamp and the amount of proof of work.\\nWell, the amount of proof of work follows in the hash.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:06:52\"}, {\"type\":\"paragraph\",\"text\":\"It's basically hash plus some extra info.\\nSo it's not the whole block.\\nSo first you start downloading not the whole block, or not all of the blocks, but you start downloading the headers, right?\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:07:04\"}, {\"type\":\"paragraph\",\"text\":\"Yes, and the idea is that you first want to make sure that the chain that you're following has enough proof of work that it's even worth downloading the blocks for.\\nNow that's been improved many years ago.\\nIt used to be that I think it would just download headers and then some blocks and then some headers and then some blocks and that has been changed many years ago to first download all the headers and only then when you know for sure that you have enough proof of work because you can check that based on the headers then you start downloading the blocks.\\nThis prevents you from wasting time chasing and basically chasing dead ends.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:07:32\"}, {\"type\":\"paragraph\",\"text\":\"Okay, that was already the case.\\nSo even in Bitcoin Core 23, you would already start with downloading only the headers and only later the blocks.\\nOkay, so what has changed?\"}, {\"type\":\"heading\",\"text\":\"Download headers twice\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:07:41\"}, {\"type\":\"paragraph\",\"text\":\"So what has changed now is that we're going to download the headers twice.\\nAnd that might take some explanation on why you want to do that.\\nSo there is the potential problem that you're worried about with headers is that you could receive quite a lot of them.\\nBecause you know right now there have been about 700,000 blocks since the Genesis but a miner could manipulate the timestamps and they could create a fake blockchain with blocks that are every second and that would be billions and billions of blocks.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:08:10\"}, {\"type\":\"paragraph\",\"text\":\"I guess anyone can only a miner can do that?\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:08:13\"}, {\"type\":\"paragraph\",\"text\":\"Well anyone who can mine.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:08:15\"}, {\"type\":\"paragraph\",\"text\":\"You do need basically the ASIC hardware to do that.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:08:18\"}, {\"type\":\"paragraph\",\"text\":\"Well, you'd have to do the math on what kind of hardware you would need to do it.\\nI mean, in principle, you don't need an ASIC to mine blocks, right?\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:08:24\"}, {\"type\":\"paragraph\",\"text\":\"You need the proof of work, is what I'm saying.\\nYou need the actual proof of work,\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:08:27\"}, {\"type\":\"paragraph\",\"text\":\"Yeah. But I mean, you know, the proof of work in the beginning was quite low, so you can do that with a CPU, but maybe if you wanna do some damage, maybe you need more power.\\nAnyway, so the worry is that you get a billion headers from a chain and it's not the real chain, but it's a lot of low-work nonsense.\\nAnd the problem with that is that not just do you have to download it because that's kind of hard to avoid But you also tend to store it on your disk because maybe you receive half a billion headers But and those don't go anywhere, but you don't know maybe there's another half a billion headers on top of that that do take you to the real tip.\\nSo you can't really throw those headers away that easily.\\nAnd so the attack would be that lots of headers are sent to you.\\nAnd that attack has been known for a long time.\\nAnd the solution to that so far has been checkpoints.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:09:16\"}, {\"type\":\"paragraph\",\"text\":\"Okay, hang on, let's summarize this.\\nSo first the problem was solved...\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:09:24\\nThe first problem was just getting lots of spam blocks.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:09:26\"}, {\"type\":\"paragraph\",\"text\":\"Yes, so that problem was solved by only checking the headers.\\nBut now basically a new problem is introduced, namely someone could just send you a boatload of fake headers, essentially.\\nAnd then while downloading all these headers, you also have to store it.\\nThis is resource-intensive.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:09:43\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, so it's basically the general category of problem is called a resource exhaustion attack.\\nSo I'm trying to exhaust one of your resources.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:09:51\"}, {\"type\":\"paragraph\",\"text\":\"And then you mentioned this was solved with checkpoints.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:09:54\"}, {\"type\":\"paragraph\",\"text\":\"This has been solved very early on.\\nThat's kind of what the checkpoints are for.\\nFortunately, Checkpoints have not been added since 2013 because they are not a very nice way to do it.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:10:05\"}, {\"type\":\"paragraph\",\"text\":\"Just to be very clear, what is a checkpoint?\"}, {\"type\":\"heading\",\"text\":\"Checkpoints\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:10:07\"}, {\"type\":\"paragraph\",\"text\":\"What a checkpoint does is it says this specific block with this hash must exist in the chain.\\nRight.\\nSo it's not optional.\\nRight.\\nAnd that has always been done retroactively, like a long time after.\\nSo a way to abuse checkpoints is to say, well, somebody stole my coins.\\nI'm going to now introduce a checkpoint that happened before somebody stole my coins for a new block that I've created.\\nThat does not steal my coins.\\nAnd then, you know, we start history again.\\nThat's the worst case.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:10:34\"}, {\"type\":\"paragraph\",\"text\":\"Well, that should be after some of, well\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:10:37\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, so somebody steals my coins.\\nLet's say that happens today.\\nThen I call up a miner and say, could you make a couple of new blocks that don't steal my coins?\\nHere's the double-spend version that I want to include in that block.\\nThey mine it for me and then I release a new version of Bitcoin Core that says here's a checkpoint.\\nYou must ignore like the real big chain that has built on top of the hack and actually go for this other chain.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:10:59\"}, {\"type\":\"paragraph\",\"text\":\"Yeah so with the checkpoint you can sort of overrule the longest chain rule.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:11:04\"}, {\"type\":\"paragraph\",\"text\":\"That's right and that has been done in many altcoins.\\nSo the concern is that we don't want that to happen in Bitcoin.\\nSo one way to prevent that has, I think, has been from the beginning to introduce the checkpoints only much after they've already happened.\\nSo you already know they're part of the longest chain, everybody can verify that, and the checkpoint is buried quite deeply.\\nBut it's still not a very pretty solution, and so people stopped doing it.\\nSo it'd be nice, but it'd be very nice...\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:11:29\"}, {\"type\":\"paragraph\",\"text\":\"Did you mention when the last checkpoint was?\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:11:31\"}, {\"type\":\"paragraph\",\"text\":\"I think it was 2013.\\nIt's quite a long time ago.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:11:33\"}, {\"type\":\"paragraph\",\"text\":\"It's a while.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:11:35\"}, {\"type\":\"paragraph\",\"text\":\"And so it'd be nice to get rid of those things entirely because, you know, they are confusing and, you know, we probably don't want to add new ones.\\nSo In order to get rid of them, you still need to fix this resource exhaustion attack that we just talked about.\\nSo then how do you do that?\\nWell, the trick is to download headers twice, as I said.\\nSo what you do is you download them once, and when you're downloading them once, you don't save them.\\nYou just look at them, check if they're correct, and you throw them away.\\nThis means it does not use any of your disk space.\\nThen if you see enough work at the end, if you checked all the headers and you see the proof of work is enough, it's the longest chain, Then you ask the peer, hey, can you send them again, please?\\nAnd you download them again.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:12:21\"}, {\"type\":\"paragraph\",\"text\":\"I think I mentioned yesterday when we went over this in our preparation, this is kind of how my attention span usually works.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:12:28\"}, {\"type\":\"paragraph\",\"text\":\"Exactly.\\nYou first let me ramble on a bit, and then you think, this might actually be interesting.\\nAnd then you say, what did you say again?\\nPlease repeat.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:12:35\"}, {\"type\":\"paragraph\",\"text\":\"Can you repeat that for me?\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:12:37\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, so this is how Bitcoin nodes now actually work.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:12:39\"}, {\"type\":\"paragraph\",\"text\":\"That's right.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:12:40\"}, {\"type\":\"paragraph\",\"text\":\"They first listen, they don't store anything, but then if it sounds actually interesting, if they see the proof of work, they just ask again and they get all the blocks.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:12:47\"}, {\"type\":\"paragraph\",\"text\":\"They're like, wow, that's cool.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:12:48\"}, {\"type\":\"paragraph\",\"text\":\"But they get all the headers again, I guess.\\nOr do they now also get the blocks?\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:12:51\"}, {\"type\":\"paragraph\",\"text\":\"Well, then once those headers have been downloaded the second time, things continue as always.\\nYou just start fetching blocks for the headers.\\nNow there's, of course, a little gotcha there because, well, who says that the second time you're getting the same headers as the first time?\\nYou don't know that, because you didn't store them.\\nSo what you do instead is you store one checksum, which is a one-bit checksum, every 50,000 blocks or so.\\nSo every 50,000 headers you store a zero or a one depending on the contents of those headers and you do that every 50,000 headers.\\nThat is very little information but it turns out that it's actually quite difficult for anybody to fake that information.\\nSo it's for anybody to create fake headers that do match your checksum, even though it's a very small checksum.\"}, {\"type\":\"heading\",\"text\":\"checksums\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:13:36\"}, {\"type\":\"paragraph\",\"text\":\"Right, yeah, a checksum is essentially you add up all kinds of numbers and you get a very short number which doesn't in itself prove anything, but I guess if you do it a bunch of times then.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:13:46\"}, {\"type\":\"paragraph\",\"text\":\"If you add up the same numbers you're gonna get the same checksum.\\nSo if you have 50,000 headers, you add all those up together, then you get either a one or a zero.\\nIf you change any of the headers, well, you'll either get a one or a zero, but it might be a different one.\\nNow that, of course, is a 50-50 chance.\\nYeah.\\nSo that's pretty easy for a hacker to go after, but there are many blocks.\\nSo it turns out that if for long enough, I might be wrong on the exact number, it might be less than 50,000, but if you have enough of those one-bit checks, basically, then it becomes quite hard for an attacker to create a fake chain that has enough proof of work but that is different from the last one they sent you.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:14:23\"}, {\"type\":\"paragraph\",\"text\":\"Yep okay, that makes sense.\\nSo there's still a small part of the problem left which is you do still need to download it the first time.\\nYes.\\nBut it solves another part of the problem essentially.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:14:37\"}, {\"type\":\"paragraph\",\"text\":\"Yes, so the downside is you're downloading headers twice so that might be another 100 megabytes or so in the ideal case.\\nHowever, compared to the size of the blockchain, it's not too bad.\\nAnd compared to the worst-case attack, it's definitely not bad.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:14:53\"}, {\"type\":\"paragraph\",\"text\":\"And of course, even if an attacker would want to try this for some reason, it's also costing the attacker resources because he has to upload all the same data you have to download.\\nIt doesn't really do much, this attack, right?\\nIt can't allow you to steal coins or anything like that.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:15:10\"}, {\"type\":\"paragraph\",\"text\":\"Well, with this defense, no, because all they can do is waste your bandwidth.\\nAnd there are many ways to waste your bandwidth, right?\\nAn attack can just send you a gigabyte block and it would or just complete gibberish in general so that's not a new problem\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:15:24\"}, {\"type\":\"paragraph\",\"text\":\"okay so this was included in Bitcoin Core 24 and will be\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:15:28\"}, {\"type\":\"paragraph\",\"text\":\"And the checkpoints are still there But the idea would be to remove them eventually.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:15:32\"}, {\"type\":\"paragraph\",\"text\":\"Okay, so that would be removed in a future release?\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:15:36\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, and of course, you know, there has to be some additional discussion to make sure that that was really the last thing we needed, that the checkpoints are not also protecting against something else that we forgot about.\"}, {\"type\":\"heading\",\"text\":\"Full-RBF\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:15:44\"}, {\"type\":\"paragraph\",\"text\":\"Okay, well, that's the peer-to-peer part of Bitcoin 24.\\nThen the next point is Mempool uses full-RBF now or can use full RBF?\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:15:57\"}, {\"type\":\"paragraph\",\"text\":\"Can use full-RBF.\\nSo it used to be that if you wanted, I think we've done an episode about replace by fee, RBF.\\nSo I think the listeners should listen to that.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:16:06\"}, {\"type\":\"paragraph\",\"text\":\"You can summarize it in two sentences.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:16:08\"}, {\"type\":\"paragraph\",\"text\":\"So basically the Bitcoin protocol itself, when you have one transaction and then you want to double spend it, there's nothing stopping you from doing that before it's in a block.\\nNow, from an incentive point of view, miners are most likely to include the block with the highest fee, but they don't necessarily have to.\"}, {\"type\":\"paragraph\",\"text\":\"And so there was a proposal by Peter Todd many, many years ago to say, well, normally the nodes, well, let's go one step back.\\nSo what miners do is ultimately up to miners.\\nYou have no control over that.\\nAnd Bitcoin Core can change things in the software, but miners will do whatever they do, because what the mempool does is not consensus.\"}, {\"type\":\"paragraph\",\"text\":\"However, the nodes will relay transactions.\\nAnd so you can change the nodes to say, well, I'm gonna broadcast some transactions and not gonna rebroadcast other transactions.\\nAnd so this new rule, opt-in replaced by fee, opt-in RBF, basically said that normally we only broadcast the first version of the transaction we see, regardless of the second one.\\nDoesn't matter if the second one pays more fees.\\nBut if you put a flag in a transaction that says, I want to opt-in to replace by fee, then nodes will refer, will relay transactions that pay a higher fee only and a bunch of other constraints.\\nAnd so this gives the recipient some assurance, not much, but some assurance that if this flag is present, this transaction could be replaced anytime.\\nYou really have to wait for it to confirm.\\nIf it doesn't have this flag, it might still disappear.\\nIt's just a little bit less likely.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:17:35\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, I want to clarify one thing because you mentioned double spending in this context.\\nAnd you are of course right that this can be used to double spend until it's included in a block, as you said.\\nBut the main purpose or the main idea for using a flag, for example, is to increase the fee on your own transaction, right?\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:17:54\"}, {\"type\":\"paragraph\",\"text\":\"I don't know how long that idea has been around because the idea of being stuck in a mempool, that concept didn't even exist until 2015 or 2016.\\nThat was never a problem.\"}, {\"type\":\"heading\",\"text\":\"RBF summary\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:18:04\"}, {\"type\":\"paragraph\",\"text\":\"But it was the flag was introduced around that time and definitely in the context of that, that was the debate.\\nYeah, I'm sure about that.\\nSo to summarize that, At least the idea for the flag was you send a transaction, but the mempool was full, and therefore your transaction is not confirming.\\nNow with the RBF flag, you can basically resend the same transaction with a higher fee, and therefore, because the flag is included, nodes will actually forward it to miners and it can be included in a block.\"}, {\"type\":\"paragraph\",\"text\":\"Now you don't actually need to include the flag anymore.\\nIf this setting is turned on?\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:18:44\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, I think that if you turn this setting on, then the flag does no longer have to be in there, it'll relate anyway so then I'm guessing there are other rules though because I assume the fee has to go up but I'm not sure about that\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:18:56\"}, {\"type\":\"paragraph\",\"text\":\"So in my case, if so far I was running Bitcoin Core 23, my node would not forward a transaction even if it had a higher fee and it conflicted with the previous transaction.\\nIt would not do that.\\nBut now with Bitcoin 24 I can switch the setting and now it will actually forward that transaction.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:19:22\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, I think that's it and it basically means that if you're relying on this opt-in RBF system to prevent double spends, basically to prevent double spends, you should now rely on that less so, because there's going to be more nodes that will relay this thing regardless.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:19:37\"}, {\"type\":\"paragraph\",\"text\":\"I don't know about almost certainly, but there's definitely a much bigger chance that a conflict in a transaction will make it to a miner now, right?\\nBecause I think there only needs to be a relatively small amount of notes on the network that actually do it for a transaction to just find its way over the entire network.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:19:54\"}, {\"type\":\"paragraph\",\"text\":\"But there were already ways to do it, right?\\nThere was a patch by Peter Todd which was pretty small and you could use that to modify your nodes.\\nSo there's already some nodes doing it.\\nNow there's more, presumably.\"}, {\"type\":\"heading\",\"text\":\"Merchants\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:21:06\"}, {\"type\":\"paragraph\",\"text\":\"So does this mean that some merchants are going to be unhappy?\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:21:12\"}, {\"type\":\"paragraph\",\"text\":\"Well, they might be for that reason.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:21:13\"}, {\"type\":\"paragraph\",\"text\":\"There are still some merchants that rely on zero-conf.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:21:15\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, there are definitely merchants that do that.\\nBut the flip side is that there are also merchants that use Lightning and Lightning is generally bothered a lot by this, by the existing RBF rules because they make it much more complicated to deal with penalty transactions.\\nSo they may get, in the long run, they may get a better lightning experience out of this.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:21:36\"}, {\"type\":\"paragraph\",\"text\":\"I mean, my personal opinion is that this should just be the general rule.\\nTransactions should always be broadcast and forwarded, especially if they have a higher fee.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:21:48\"}, {\"type\":\"paragraph\",\"text\":\"I mean, maybe, we've already had this discussion during that episode, I guess, but I would also say that if you just turn on the RBF flag by default, it shouldn't bother you either.\\nBut I think the bigger problem is that this RBF flag has very specific rules.\\nIt's not just that you set the flag, you also have to do a few other things and those other things cause complications.\\nSo that could be a reason to say, you know what, let's forget about this opt-in RBF completely and relay everything that is reasonable.\\nBut there are trade-offs.\\nOne is just bandwidth because if my node relays everything that you sent to it, I could send you one transaction and then increase it by one satoshi per byte or increase it by.\\nDon't even increase the fee, but just change the destinations a bit, and I could send you millions and millions of variations of the same transaction, basically wasting everybody's bandwidth.\\nSo it's not entirely without trade-offs.\"}, {\"type\":\"heading\",\"text\":\"Descriptor Wallet Migration\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:22:39\"}, {\"type\":\"paragraph\",\"text\":\"All right, let's move on to the third point.\\nSo we mentioned the change on the peer-to-peer network, the block header thing, and we just mentioned RBF.\\nAnd then the third point is this related to descriptor wallets and migration to the descriptor wallets?\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:22:52\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, I'm not sure how much we covered the descriptor wallets so far but the gist of it is that the Bitcoin Core wallet is quite old.\"}, {\"type\":\"paragraph\",\"text\":\"It used to be just a bag of keys and then given a private key, the wallet would have to pay attention to certain scripts.\\nI think in one of the first episodes we explained what scripts are.\"}, {\"type\":\"paragraph\",\"text\":\"But the simplest scripts is just that anybody with the public key can spend this coin.\\nThe second simplest script is that anybody with the hash of the public key can spend the coin or anybody with the public key for which the hash is blah, blah, blah.\\nAnd then there was, but then later on came SegWit and that created another two variations of how you could spend the coins.\\nBecause you had the address of BC1, and you had the address that looked like a P2SH address with SegWit wrapped in it.\\nSo the wallet just became a giant mess.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:23:42\"}, {\"type\":\"paragraph\",\"text\":\"Because you have multi-sig writes and stuff like that.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:23:45\"}, {\"type\":\"paragraph\",\"text\":\"Well, yeah, that makes it even more complicated.\\nBut basically the Bitcoin Core wallet became a bit unwieldy.\\nAnd so one of the improvements that was introduced was to create a new way to store data and basically saying, well, here's keys, but more importantly, here's exactly what scripts you want to watch for.\\nSo you can specifically say, I only want to check for Taproot transactions for this private key, and not also for legacy transactions for this private key.\\nNow your wallet handles all this.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:24:14\"}, {\"type\":\"paragraph\",\"text\":\"What are the practical benefits of that?\\nJust less resources?\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:24:17\"}, {\"type\":\"paragraph\",\"text\":\"For the end user, this doesn't matter.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:24:19\"}, {\"type\":\"paragraph\",\"text\":\"It just means that their wallet software is better maintained.\\nBecause it's less of a headache for the wallet developers to deal with this.\\nSo it basically involved the giant rewrite, mostly done by Andrew Chow.\\nAnd one of the challenges there is we have this old wallet and we want to move people over to the new wallet.\\nAnd so the first step for that is this new RPC call called `migratewallet`, which does what it says it does.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:24:43\"}, {\"type\":\"paragraph\",\"text\":\"It will migrate your wallet?\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:24:45\"}, {\"type\":\"paragraph\",\"text\":\"And for the simplest cases, you know, if you created a wallet in the last couple years and you didn't do anything super fancy, very complicated, multi-sig setups, whatever, this will work.\\nIf you did do something complicated, then please test it.\\nIt'll make a backup, but maybe make your own backup too.\\nAnd we'd like to see bug reports basically, because maybe you have some super complicated wallet setup that does not migrate properly.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:25:09\"}, {\"type\":\"paragraph\",\"text\":\"So basically what this does is your wallet software will just go over all of the UTXOs and say, what, this is a paid to public key?\\nThis is a multisig.\\nAnd throw them into different buckets\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:25:19\"}, {\"type\":\"paragraph\",\"text\":\"No, it will not go over the UTXOs.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:25:22\"}, {\"type\":\"paragraph\",\"text\":\"No, it will go over the keys inside the wallet.\\nThe transaction list you have is kind of the same.\\nIt'll look through what keys you have in the wallet and it will restructure those as descriptors.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:25:31\"}, {\"type\":\"paragraph\",\"text\":\"It will throw these in the different buckets?\\nOkay, instead of one big bucket.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:25:36\"}, {\"type\":\"paragraph\",\"text\":\"That's right.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:25:37\"}, {\"type\":\"paragraph\",\"text\":\"Okay, I think that's clear enough then.\\nAnd as mentioned, this is mostly to benefit just the developers, not so much users.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:25:46\"}, {\"type\":\"paragraph\",\"text\":\"I mean yeah, the users benefit indirectly, but yeah, it does.\\nI mean, descriptors have already been used to allow taproot.\\nSo if you wanted to use Taproot, you either need to create a whole new wallet or you need to migrate to a descriptor wallet and then add Taproot to it.\\nSo there is that too.\"}, {\"type\":\"heading\",\"text\":\"Miniscript Support\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:26:04\"}, {\"type\":\"paragraph\",\"text\":\"Okay, there's been moving on to the fourth point, Miniscript support.\\nHas Miniscript support been added to Bitcoin Core?\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:26:11\"}, {\"type\":\"paragraph\",\"text\":\"Yes, in very limited fashion.\\nI think we have done a whole episode about Miniscript, but it basically lets you do very advanced scripting systems.\\nSo something like I want to spend with two keys or I want two signatures or after five years I want one signature Or if somebody has the pre-image of this SHA-256 hash, then they only need one signature plus whatever.\\nMiniscript allows you to do fairly arbitrarily complicated things.\\nAnd Bitcoin Core can now, if you have a piece of Miniscript, it can now watch that.\\nYou cannot spend from it yet.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:26:48\"}, {\"type\":\"paragraph\",\"text\":\"I mean, the other way to put it, the simple way to put it maybe is miniscript allows for smart contracting type of stuff, right?\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:26:59\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, I guess.\\nI mean that might be overselling it a bit, but yeah.\\nTo the degree that Bitcoin can support smart contracts, the Bitcoin script language is very complicated.\\nYou don't want to write Bitcoin script by hand, you will make mistakes.\\nLike even Andrew Poelstra and people like that will make mistakes.\\nSo, Miniscript is designed to get the most out of the existing Bitcoin script system in a safe way.\\nThat's, I think, the most fair way to put it.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:27:26\"}, {\"type\":\"paragraph\",\"text\":\"Right, sorry, and what does it mean that it's been added now?\\nIn what way has it been added?\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:27:31\"}, {\"type\":\"paragraph\",\"text\":\"It means you can create a wallet.\\nSo if you create a new wallet, you can put a piece of miniscript inside of that wallet and it will basically let you create addresses for that miniscript and you can send coins to those addresses.\\nBut you can't spend them.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:27:44\"}, {\"type\":\"paragraph\",\"text\":\"I see.\\nSo, you can't spend them.\\nNot yet.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:27:48\"}, {\"type\":\"paragraph\",\"text\":\"So you shouldn't do that.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:27:49\"}, {\"type\":\"paragraph\",\"text\":\"Okay, yeah, don't do it yet.\\nAnd this sounds like you might need to run a separate wallet or a separate piece of software that you connect to your Bitcoin Core node.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:28:00\"}, {\"type\":\"paragraph\",\"text\":\"No, well, yeah, in order to create the miniscript itself, you will need separate software.\\nThere is a miniscript compiler, but you can write miniscript by hand too if you want to.\\nSo, in principle, you don't need a second piece of software.\\nNow, the idea is that a future version of Bitcoin Core will also be able to sign for it.\\nBut you shouldn't count on that, you shouldn't use it until it does.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:28:21\"}, {\"type\":\"paragraph\",\"text\":\"Okay, well this sounds like a pretty big step then, doesn't it?\\nIt sounds to me like it's a pretty big step.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:28:26\"}, {\"type\":\"paragraph\",\"text\":\"I think it is pretty big, yeah.\\nAnd the other constraint is that it only works for the first version of SegWit.\\nSo those are addresses with BC1Q.\\nSo it does not work for Taproot yet.\\nAnd because there's a lot of work that needs to be done, or at least there is work that needs to be done in order to have Miniscript work with Taproot at all.\\nAnd then once it does that in general, so the specification of the manuscript can handle it, then the next challenge is to actually get that into Bitcoin Core and to really use Taproot and Miniscript well, you probably want musig to the signature aggregation stuff.\\nThat also needs to be added to Bitcoin Core.\\nSo there is a ton of work still left to do.\\nBut this is one step.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:29:06\"}, {\"type\":\"paragraph\",\"text\":\"Is there currently, so we're right now talking about Bitcoin Core, obviously.\\nIs there currently other Bitcoin software that already allows you to create and use Miniscript?\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:29:17\"}, {\"type\":\"paragraph\",\"text\":\"No, as far as I know, there is there's basically a library called Rust Miniscript and a library written by CPython that does Miniscript and C++ Those libraries you can use but they're not fully functional wallets So I don't know if anybody is using Miniscript in the wild, maybe Blockstream is for their what is it?\\nLiquid sidechain stuff, I would know.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:29:36\"}, {\"type\":\"paragraph\",\"text\":\"Okay, well interesting, like I said that sounds like a pretty big step actually.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:29:43\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, and it would also I think This is the longer-term trend of hopefully turning Bitcoin Core from a not a very good wallet, was quite slow, quite weird, to hopefully a very good wallet.\\nAnd at least a very good wallet for power users, right?\\nSo maybe exchanges want to use it more.\\nMy hope is that if this wallet becomes very powerful, then more people will help review the code and more people will help improve it.\\nSo you kind of get this self-amplifying effect.\\nOnce it's useful enough, more people will look at it, but it takes a very long time to become useful enough because it's not useful enough so not enough people are working on it.\\nIt's really I think maybe four people.\"}, {\"type\":\"heading\",\"text\":\"Opt-in RBF\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:30:27\"}, {\"type\":\"paragraph\",\"text\":\"All right moving on to the next point.\\nThe next point on our list is another point about RBF.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:30:36\"}, {\"type\":\"paragraph\",\"text\":\"This is just about opt-in RBF, that the wallet will, the wallet RPC, so the command line wallet will now use it by default.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:30:45\"}, {\"type\":\"paragraph\",\"text\":\"Oh, that's right.\\nOkay, wait, so we're not talking about the GUI, right?\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:30:49\"}, {\"type\":\"paragraph\",\"text\":\"No, the GUI already switched to use RBF by default.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:30:53\"}, {\"type\":\"paragraph\",\"text\":\"And now the command line does as well?\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:30:54\"}, {\"type\":\"paragraph\",\"text\":\"Yeah.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:30:56\"}, {\"type\":\"paragraph\",\"text\":\"Okay, go on.\\nMaybe I should just let you finish.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:30:58\"}, {\"type\":\"paragraph\",\"text\":\"So why didn't it?\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:30:59\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, why didn't it yet?\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:31:00\"}, {\"type\":\"paragraph\",\"text\":\"So one of the reasons is that people are using the Bitcoin Core wallet in some automated systems.\\nSo if you're running a Bitcoin ATM, you may have some really old software that does not know that RBF exists, maybe because it's really old, and it might get confused if it's turned on by default.\\nSo for those kind of systems you don't want to change things too quickly.\\nBut I think it's been five years now so might be a good time to switch to default.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:31:24\"}, {\"type\":\"paragraph\",\"text\":\"That should be enough time.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:31:26\"}, {\"type\":\"paragraph\",\"text\":\"Well hopefully.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:31:28\"}, {\"type\":\"paragraph\",\"text\":\"Okay, so would we expect more RBF transactions on the network now?\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:31:34\"}, {\"type\":\"paragraph\",\"text\":\"We'll have to see.\\nIt depends on when people start using it.\\nMy hope is no because my hope is that anybody who builds this kind of software already decided whether they want RBF on or off because it's just a default value.\\nYou probably should already set that default to what you want it to be so that you're not surprised by this update.\\nSo I hope to see no difference.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:31:55\"}, {\"type\":\"paragraph\",\"text\":\"Because the worst-case scenario would be that some major company that has RBF turned off for some reason now suddenly turns it on and starts producing lots of RBF transactions confusing everybody in their ecosystem.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:32:08\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, it wouldn't really harm them in any way, would it?\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:32:12\"}, {\"type\":\"paragraph\",\"text\":\"I don't know, maybe people are using that service to send coins to some other service that does not like it when transactions are RBF.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:32:20\"}, {\"type\":\"paragraph\",\"text\":\"Yeah that does not accept RBF transactions.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:32:22\"}, {\"type\":\"paragraph\",\"text\":\"Or gets confused by them.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:32:24\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, these are out there.\\nOkay, makes sense.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:32:28\"}, {\"type\":\"paragraph\",\"text\":\"So that's why you want to be a little bit slow with these command line tools to change them.\"}, {\"type\":\"heading\",\"text\":\"Change Output\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:32:33\"}, {\"type\":\"paragraph\",\"text\":\"Right, okay, I think we've covered five points now and we got seven in total, so we got two more to go.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:32:40\"}, {\"type\":\"paragraph\",\"text\":\"All right.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:32:42\"}, {\"type\":\"paragraph\",\"text\":\"Number six.\\nThe change output amounts are randomized.\\nIt says that's what it says.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:32:52\"}, {\"type\":\"paragraph\",\"text\":\"It's very cool.\\nYeah, so basically this has to do I mean I don't know the precise change, but the general problem is that when you're looking at the blockchain, you can kind of guess which address is changed and which address is not changed if you have an assumption about how the wallet picks coins.\\nSo if the wallet is very efficient, it will look for the smallest coin possible to spend and then it will create as little change as possible.\\nBut that means that generally when you see two outputs to a transaction, the biggest one is probably the amount that's being sent and the smallest one is probably the change.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:33:30\"}, {\"type\":\"paragraph\",\"text\":\"Well, is that necessarily true?\\nThat's maybe true if there are several inputs, right?\\nThat logic only holds up if there are several inputs, I think.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:33:41\"}, {\"type\":\"paragraph\",\"text\":\"Or if there's one input.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:33:44\"}, {\"type\":\"paragraph\",\"text\":\"Let's say you, well, if there is, depends on how much there is available, right?\\nBut you're looking at the chain, so you don't know what was available.\\nBut if your wallet is looking at a bag of coins, it might start with the smallest coin saying, nah, it's not big enough.\\nAnd then keep looking and then find one coin that's big enough.\\nAnd then use that to spend it.\\nAnd it doesn't really matter, but if you know what software the person was using based on some other fingerprinting aspects, you can start then.\\nYou know how that software works, you know how that software does its coin selection, you can use that against the user.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:34:17\"}, {\"type\":\"paragraph\",\"text\":\"Okay so do you know what algorithm Bitcoin Core was using up till now?\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:34:22\"}, {\"type\":\"paragraph\",\"text\":\"It's using a bunch of algorithms.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:34:25\"}, {\"type\":\"paragraph\",\"text\":\"Oh several, and do you know which ones or no?\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:34:26\"}, {\"type\":\"paragraph\",\"text\":\"No, I should ask Murch.\\nHe wrote a whole thesis on it and implemented a bunch of things.\\nOne of them is-\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:34:31\"}, {\"type\":\"paragraph\",\"text\":\"But something changed.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:34:33\"}, {\"type\":\"paragraph\",\"text\":\"I think originally the system was called the knapsack.\\nAnd I think the knapsack basically meant you just grabbed coins randomly and then see if it was enough.\\nAnd then if it wasn't, you try it again.\\nAnd then there was a new thing called branch and bound, which was a bit more smarter way to find coins.\\nAnd there's also the trying to find a single coin that is exactly the right value strategy.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:34:57\"}, {\"type\":\"paragraph\",\"text\":\"There's a bunch of things that are happening.\\nIt's a bit complicated.\\nBut what this basically does is make it more difficult to tell which one is the input, sorry, which one is the change and which one is the destination.\\nAnd the way you do that is basically saying, well, rather than looking for the coin of the exact right size to spend, I'm going to look for a coin that is the amount that I need to spend plus two times the, yeah, I'm going to look for a coin that is at least three times, I guess, the amount that I'm trying to spend.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:35:25\"}, {\"type\":\"paragraph\",\"text\":\"Right, so you want to spend one Bitcoin, so you're going to look for UTXO of three Bitcoins.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:35:29\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, except you're not going to do that.\\nYou're going to say, I'm going to pick a number between the amount I want to spend and three times the amount I want to spend between one and three yeah and I'm gonna pick that number randomly right so that means sometimes the biggest sometimes you're gonna pick a very high number and so the change address will actually be the smaller will be the bigger output And sometimes I pick the lower random number and the change output will be the biggest amount.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:35:53\"}, {\"type\":\"paragraph\",\"text\":\"Okay, so we're basically gonna keep using the algorithm that we were using, or at least, I don't know, but that's my assumption.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:35:59\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, I think that doesn't change.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:36:01\"}, {\"type\":\"paragraph\",\"text\":\"However, we're now going to look for coins as if we're looking for one to three times more than what we are actually spending.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:36:09\"}, {\"type\":\"paragraph\",\"text\":\"Exactly.\\nAnd that number is random.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:36:10\"}, {\"type\":\"paragraph\",\"text\":\"That sounds interesting.\\nDoesn't that mean that you sometimes end up using more UTXOs than you would actually require?\\nIn other words, wouldn't you make transactions bigger than they really need to be?\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:36:25\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, I think that might mean that sometimes you are spending more coins than necessary.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:36:31\"}, {\"type\":\"paragraph\",\"text\":\"Okay, so it's not optimizing for fees then or it's not also optimizing.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:36:35\"}, {\"type\":\"paragraph\",\"text\":\"I don't think so but there may be some caveats in that code you'd have to read through it to see what exactly it's doing maybe there's some some protection against spending too much on fees.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:36:44\"}, {\"type\":\"paragraph\",\"text\":\"Right Maybe it only works if this is not the case.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:36:49\"}, {\"type\":\"paragraph\",\"text\":\"I mean, if you're using the GUI, you can also do your coin selection completely manually.\\nThere is a little menu where you can see what your inputs are and just select which ones you want to spend.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:36:58\"}, {\"type\":\"paragraph\",\"text\":\"So there might be trade-offs that we're not completely clear on, but the general idea is you're going to look for more coins than you actually need for privacy purposes.\\nThat's ultimately the benefit, right?\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:37:09\"}, {\"type\":\"paragraph\",\"text\":\"Yeah. I suppose one day we should do an episode about coin selection.\\nThis is also something I haven't specialized in.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:37:14\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, we should maybe.\\nThat does sound like an interesting topic.\\nWe can go over all of this.\\nLast point, Sjors.\"}, {\"type\":\"heading\",\"text\":\"SendAll\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:37:23\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, this one isn't super interesting.\\nIt's a new RPC called `sendall`.\\nAnd so this is a command line tool.\\nAnd the name suggests that you're sending all your money.\\nThat's not actually true.\\nYou can use it to send all your money away to a different wallet, let's say if you're trying to migrate.\\nBut you can also say, take these coins, so these specific input coins, and send them all to a specific destination.\\nThis is stuff that you could already do because there was one command line tool called `sendmany` and `sendtoaddress`.\\nThere basically were already calls to do this.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:37:55\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, also in the GUI this is already possible, right?\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:37:58\"}, {\"type\":\"paragraph\",\"text\":\"Yeah.\\nSo the underlying motivation here is actually that there are different intentions that the user might have.\\nThey might want to send an entire coin to an exchange for privacy reasons or they might want to send an exact amount to an exchange and in retrospect, you don't really know what the user intended so that creates problems when you try to bump the fee.\\nBut also the code that actually implements this is a bit of a mess because it has all these different features.\\nSo you can do all these different things for different use cases.\\nThat means your code is full of if, then, else, if, if, else, else, if.\\nAnd so basically this is the first step to splitting that up to saying okay if you want to do this specific thing use the `sendall` method if you want to do this other thing use the send method and that's the first step to just you know at the command line it's easier to tell users to start using two different commands for two different things and then eventually I guess under the hood there will be some changes to the GUI to also use the separation.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:38:52\"}, {\"type\":\"paragraph\",\"text\":\"I mean, this sounds like something that basically all wallets already do.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:38:58\"}, {\"type\":\"paragraph\",\"text\":\"I don't know.\\nLike I said, it's not a new piece of functionality.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:39:01\"}, {\"type\":\"paragraph\",\"text\":\"The insulting thing though, is that other wallets, the universally accepted term for this is send-max.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:39:07\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, but it's send-max given a set of coins.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:39:12\"}, {\"type\":\"paragraph\",\"text\":\"That's also what send-max is I think or not?\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:39:14\"}, {\"type\":\"paragraph\",\"text\":\"I don't know yeah could be.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:39:15\"}, {\"type\":\"paragraph\",\"text\":\"That's how I use it.\\nThat's how I think about it.\\nNo, but I get your point.\\nOkay, yeah, this was not the most exciting future of the seven, but I'm happy we covered it, Sjors.\\nAre you?\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:39:24\"}, {\"type\":\"paragraph\",\"text\":\"Last but not least.\\nYeah, like I said, there's probably at least probably 500 or maybe a thousand individual changes that could each be worth their own episode if you were truly interested in how compilers work and whatever.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:39:36\"}, {\"type\":\"paragraph\",\"text\":\"Well, we covered the highlights.\\nAt least we covered our highlights.\\nI think so too.\\nAnd I think that makes for another successful episode, Sjors.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:39:45\"}, {\"type\":\"paragraph\",\"text\":\"We'll see thank you for listening to Bitcoin\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:40:45\"}, {\"type\":\"paragraph\",\"text\":\"Explained.\"}",
    "body": "## Intro\n\nAaron van Wirdum: 00:00:20\n\nLive from Utrecht, this is Bitcoin\n\nSjors Provoost: 00:00:23\n\nExplained.\n\nAaron van Wirdum: 00:00:24\n\nHey Sjors.\n\nSjors Provoost: 00:00:25\n\nWhat's up?\n\nAaron van Wirdum: 00:00:26\n\nI'm good.\n\nSjors Provoost: 00:00:27\n\nHow do you like the weather?\n\nAaron van Wirdum: 00:00:29\n\nIt was too hot all summer and then it was nice for about a week and now we're back to too cold.\n\nSjors Provoost: 00:00:36\n\nThis is gonna be a great winter.\n\nAaron van Wirdum: 00:00:39\n\nThat's winter for you at least for now it's still a little bit light.\nFor example while we're recording It's still light and it's past six.\nThat's the really dreadful moment for me when the clock changes.\n\nSjors Provoost: 00:00:55\n\nWell, we go to standard time, although some people want to change it and make the summertime the default, which I think is terrible.\n\nAaron van Wirdum: 00:01:03\n\nI would definitely prefer that, just because I don't get up that early anyways so I like to optimize my sun hours\n\nSjors Provoost: 00:01:13\n\nI mean ultimately you can just get up whenever you want to get up right unless you have to be in a physical place.\n\nAaron van Wirdum: 00:01:19\n\nBut you are kind of reliant on the rest of society around you, right?\nStores close at a certain time and people get out of work at a certain time, might be your friends, or you want to record a podcast at a certain time because you want to eat at a certain time.\nSo I don't have that full flexibility that you suggest because of all these people around me.\n\nOkay, Sjors, I'm going to shill the conference one more time.\nConference is coming up.\nYou can get a 10% discount if you know how to spell Sjorsnado, that's your discount code.\nSjorsnado on I think it's b.tc/amsterdam.\nI think that's the website for the conference.\nAll right, Sjors, We're going to discuss the new Bitcoin Core release that's coming up.\nIt's not here yet.\n\n## What does it mean\n\nAaron van Wirdum: 00:02:09\n\nIt's Bitcoin Core 24.0, that's the upcoming one.\nReal quick for maybe there are some new listeners, What does it mean that there's a new Bitcoin Core release coming out?\n\nSjors Provoost: 00:02:18\n\nBecause Bitcoin Core does not have a roadmap or anything like that, there is just a new release every six months or so.\nAnd things that are ready go into that new release and things that are not ready may go into another release.\nSo there's nothing very special about these releases.\nAnd so it's time for number 24.\n\nAaron van Wirdum: 00:02:37\n\nIt's just an update that happens twice a year.\nGenerally, whatever is done is done.\n\nSjors Provoost: 00:02:41\n\nYes. And then there are some minor updates throughout the rest of the year.\nThat might be 24.1, 24.2, etc.\nAnd those typically are just bug fixes, but no major changes.\n\nAaron van Wirdum: 00:02:51\n\nAnd right now there's a release candidate.\nAt the time of recording this podcast, there's I think the first release candidate for Bitcoin Core 24.\n\n## Release Candidate\n\nWhat does a release candidate mean?\n\nSjors Provoost: 00:03:01\n\nKind of what the word suggests, it's a candidate for the release.\nSo if all goes well, then the actual release will be made identical to the last candidate.\nBut the idea is that people who know what they're doing should be downloading that release candidate and or compiling it themselves and playing around with it and making sure that nothing crashes the things they use especially if you run some sort of automated service like you might be running an exchange or maybe you're running BTC pay or something like that you want to make sure nothing breaks in your setup because Bitcoin Core tries to not break things that use it but it happens occasionally.\n\nAaron van Wirdum: 00:03:39\n\nIf there's no report of anything breaking then this release candidate will basically be the release right?\n\nSjors Provoost: 00:03:45\n\nYeah, but I think there are already some things that have been improved so there will definitely be a second release candidate.\n\nAaron van Wirdum: 00:03:51\n\nokay yeah, and I think in previous Bitcoin core releases there were an average of four or so.\n\nSjors Provoost: 00:03:56\n\nYeah, I'd say that's typical.\nSo usually there's two weeks between them, So you release it and then maybe after a week or so, people start fixing things, and then after two weeks, there is a new one.\n\nAaron van Wirdum: 00:04:06\n\nRight, so realistically well technically the new Bitcoin Core 24 release could be released any day now, but practically speaking will probably be at least a couple more weeks, right?\n\nSjors Provoost: 00:04:17\n\nYeah, I'd say so.\nI think there is a release, attempted release schedule on the Bitcoin Core repository, which I think is for mid-October.\n\nAaron van Wirdum: 00:04:28\n\nSo, there are a bunch of new features as well as bug fixes and improvements, sorry, performance improvements in this new release.\nWe're going to discuss a couple of these.\nThis is kind of just our selection.\nIf this podcast was made by two other people, by Ors and Sharon, they might make a different selection.\nBut we, Sjors and Aaron, we made the selection.\n\nSjors Provoost: 00:04:59\n\nYou can look at all the commits, so all the atomic changes that go into a release, and there could be a thousand of them, but most of them are very boring, or at least they are very boring unless you are really into details of how compilers work or into cleaning up code for the sake of cleaning it up.\nSo there's a lot of changes that are just not very interesting to discuss, although they are important and they should be, they are being, you know, they always get reviewed because any of those changes could of course be a really scary thing.\n\nAaron van Wirdum: 00:05:29\n\nYeah, I'm just saying we made a selection of some of the changes that we think are probably the most interesting\nto you, our dear listener.\n\n## Download headers from peers\n\nSjors Provoost: 00:05:38\n\nThat's right.\n\nAaron van Wirdum: 00:05:40\n\nOkay, so let's start.\nSjors, I think that this one is the first one mentioned in the release notes as well.\nIt's about the peer-to-peer and network changes.\nIs that a typo?\nShould you just say peer-to-peer changes?\nPeer-to-peer network changes?\nWhatever.\n\nSjors Provoost: 00:05:55\n\nPeer-to-peer networking.\n\nAaron van Wirdum: 00:05:57\n\nLet's move on.\nSo it says that there's a change and you're gonna explain to me what this is.\nThat's the format of the podcast in case you forgot.\nIt says download headers from peers so downloading of headers from peers has been reworked.\nThat's right somehow.\n\nSjors Provoost: 00:06:18\n\nYeah, this one might be worth a separate episode, but I think we can explain the gist of it now.\nSo when your node first starts up, it is going to find peers, which we discussed in an earlier episode, and then it's going to download headers from peers, which we've also discussed in earlier episodes.\nSo it tries to get all the headers first.\n\nAaron van Wirdum: 00:06:36\n\nHang on, so every block has a header which is essentially the hash of the block itself, right?\n\nSjors Provoost: 00:06:41\n\nPlus a little bit of extra info that, for example, contains the timestamp and the amount of proof of work.\nWell, the amount of proof of work follows in the hash.\n\nAaron van Wirdum: 00:06:52\n\nIt's basically hash plus some extra info.\nSo it's not the whole block.\nSo first you start downloading not the whole block, or not all of the blocks, but you start downloading the headers, right?\n\nSjors Provoost: 00:07:04\n\nYes, and the idea is that you first want to make sure that the chain that you're following has enough proof of work that it's even worth downloading the blocks for.\nNow that's been improved many years ago.\nIt used to be that I think it would just download headers and then some blocks and then some headers and then some blocks and that has been changed many years ago to first download all the headers and only then when you know for sure that you have enough proof of work because you can check that based on the headers then you start downloading the blocks.\nThis prevents you from wasting time chasing and basically chasing dead ends.\n\nAaron van Wirdum: 00:07:32\n\nOkay, that was already the case.\nSo even in Bitcoin Core 23, you would already start with downloading only the headers and only later the blocks.\nOkay, so what has changed?\n\n### Download headers twice\n\nSjors Provoost: 00:07:41\n\nSo what has changed now is that we're going to download the headers twice.\nAnd that might take some explanation on why you want to do that.\nSo there is the potential problem that you're worried about with headers is that you could receive quite a lot of them.\nBecause you know right now there have been about 700,000 blocks since the Genesis but a miner could manipulate the timestamps and they could create a fake blockchain with blocks that are every second and that would be billions and billions of blocks.\n\nAaron van Wirdum: 00:08:10\n\nI guess anyone can only a miner can do that?\n\nSjors Provoost: 00:08:13\n\nWell anyone who can mine.\n\nAaron van Wirdum: 00:08:15\n\nYou do need basically the ASIC hardware to do that.\n\nSjors Provoost: 00:08:18\n\nWell, you'd have to do the math on what kind of hardware you would need to do it.\nI mean, in principle, you don't need an ASIC to mine blocks, right?\n\nAaron van Wirdum: 00:08:24\n\nYou need the proof of work, is what I'm saying.\nYou need the actual proof of work,\n\nSjors Provoost: 00:08:27\n\nYeah. But I mean, you know, the proof of work in the beginning was quite low, so you can do that with a CPU, but maybe if you wanna do some damage, maybe you need more power.\nAnyway, so the worry is that you get a billion headers from a chain and it's not the real chain, but it's a lot of low-work nonsense.\nAnd the problem with that is that not just do you have to download it because that's kind of hard to avoid But you also tend to store it on your disk because maybe you receive half a billion headers But and those don't go anywhere, but you don't know maybe there's another half a billion headers on top of that that do take you to the real tip.\nSo you can't really throw those headers away that easily.\nAnd so the attack would be that lots of headers are sent to you.\nAnd that attack has been known for a long time.\nAnd the solution to that so far has been checkpoints.\n\nAaron van Wirdum: 00:09:16\n\nOkay, hang on, let's summarize this.\nSo first the problem was solved...\n\nSjors Provoost: 00:09:24\nThe first problem was just getting lots of spam blocks.\n\nAaron van Wirdum: 00:09:26\n\nYes, so that problem was solved by only checking the headers.\nBut now basically a new problem is introduced, namely someone could just send you a boatload of fake headers, essentially.\nAnd then while downloading all these headers, you also have to store it.\nThis is resource-intensive.\n\nSjors Provoost: 00:09:43\n\nYeah, so it's basically the general category of problem is called a resource exhaustion attack.\nSo I'm trying to exhaust one of your resources.\n\nAaron van Wirdum: 00:09:51\n\nAnd then you mentioned this was solved with checkpoints.\n\nSjors Provoost: 00:09:54\n\nThis has been solved very early on.\nThat's kind of what the checkpoints are for.\nFortunately, Checkpoints have not been added since 2013 because they are not a very nice way to do it.\n\nAaron van Wirdum: 00:10:05\n\nJust to be very clear, what is a checkpoint?\n\n### Checkpoints\n\nSjors Provoost: 00:10:07\n\nWhat a checkpoint does is it says this specific block with this hash must exist in the chain.\nRight.\nSo it's not optional.\nRight.\nAnd that has always been done retroactively, like a long time after.\nSo a way to abuse checkpoints is to say, well, somebody stole my coins.\nI'm going to now introduce a checkpoint that happened before somebody stole my coins for a new block that I've created.\nThat does not steal my coins.\nAnd then, you know, we start history again.\nThat's the worst case.\n\nAaron van Wirdum: 00:10:34\n\nWell, that should be after some of, well\n\nSjors Provoost: 00:10:37\n\nYeah, so somebody steals my coins.\nLet's say that happens today.\nThen I call up a miner and say, could you make a couple of new blocks that don't steal my coins?\nHere's the double-spend version that I want to include in that block.\nThey mine it for me and then I release a new version of Bitcoin Core that says here's a checkpoint.\nYou must ignore like the real big chain that has built on top of the hack and actually go for this other chain.\n\nAaron van Wirdum: 00:10:59\n\nYeah so with the checkpoint you can sort of overrule the longest chain rule.\n\nSjors Provoost: 00:11:04\n\nThat's right and that has been done in many altcoins.\nSo the concern is that we don't want that to happen in Bitcoin.\nSo one way to prevent that has, I think, has been from the beginning to introduce the checkpoints only much after they've already happened.\nSo you already know they're part of the longest chain, everybody can verify that, and the checkpoint is buried quite deeply.\nBut it's still not a very pretty solution, and so people stopped doing it.\nSo it'd be nice, but it'd be very nice...\n\nAaron van Wirdum: 00:11:29\n\nDid you mention when the last checkpoint was?\n\nSjors Provoost: 00:11:31\n\nI think it was 2013.\nIt's quite a long time ago.\n\nAaron van Wirdum: 00:11:33\n\nIt's a while.\n\nSjors Provoost: 00:11:35\n\nAnd so it'd be nice to get rid of those things entirely because, you know, they are confusing and, you know, we probably don't want to add new ones.\nSo In order to get rid of them, you still need to fix this resource exhaustion attack that we just talked about.\nSo then how do you do that?\nWell, the trick is to download headers twice, as I said.\nSo what you do is you download them once, and when you're downloading them once, you don't save them.\nYou just look at them, check if they're correct, and you throw them away.\nThis means it does not use any of your disk space.\nThen if you see enough work at the end, if you checked all the headers and you see the proof of work is enough, it's the longest chain, Then you ask the peer, hey, can you send them again, please?\nAnd you download them again.\n\nAaron van Wirdum: 00:12:21\n\nI think I mentioned yesterday when we went over this in our preparation, this is kind of how my attention span usually works.\n\nSjors Provoost: 00:12:28\n\nExactly.\nYou first let me ramble on a bit, and then you think, this might actually be interesting.\nAnd then you say, what did you say again?\nPlease repeat.\n\nAaron van Wirdum: 00:12:35\n\nCan you repeat that for me?\n\nAaron van Wirdum: 00:12:37\n\nYeah, so this is how Bitcoin nodes now actually work.\n\nSjors Provoost: 00:12:39\n\nThat's right.\n\nAaron van Wirdum: 00:12:40\n\nThey first listen, they don't store anything, but then if it sounds actually interesting, if they see the proof of work, they just ask again and they get all the blocks.\n\nSjors Provoost: 00:12:47\n\nThey're like, wow, that's cool.\n\nAaron van Wirdum: 00:12:48\n\nBut they get all the headers again, I guess.\nOr do they now also get the blocks?\n\nSjors Provoost: 00:12:51\n\nWell, then once those headers have been downloaded the second time, things continue as always.\nYou just start fetching blocks for the headers.\nNow there's, of course, a little gotcha there because, well, who says that the second time you're getting the same headers as the first time?\nYou don't know that, because you didn't store them.\nSo what you do instead is you store one checksum, which is a one-bit checksum, every 50,000 blocks or so.\nSo every 50,000 headers you store a zero or a one depending on the contents of those headers and you do that every 50,000 headers.\nThat is very little information but it turns out that it's actually quite difficult for anybody to fake that information.\nSo it's for anybody to create fake headers that do match your checksum, even though it's a very small checksum.\n\n### checksums\n\nAaron van Wirdum: 00:13:36\n\nRight, yeah, a checksum is essentially you add up all kinds of numbers and you get a very short number which doesn't in itself prove anything, but I guess if you do it a bunch of times then.\n\nSjors Provoost: 00:13:46\n\nIf you add up the same numbers you're gonna get the same checksum.\nSo if you have 50,000 headers, you add all those up together, then you get either a one or a zero.\nIf you change any of the headers, well, you'll either get a one or a zero, but it might be a different one.\nNow that, of course, is a 50-50 chance.\nYeah.\nSo that's pretty easy for a hacker to go after, but there are many blocks.\nSo it turns out that if for long enough, I might be wrong on the exact number, it might be less than 50,000, but if you have enough of those one-bit checks, basically, then it becomes quite hard for an attacker to create a fake chain that has enough proof of work but that is different from the last one they sent you.\n\nAaron van Wirdum: 00:14:23\n\nYep okay, that makes sense.\nSo there's still a small part of the problem left which is you do still need to download it the first time.\nYes.\nBut it solves another part of the problem essentially.\n\nSjors Provoost: 00:14:37\n\nYes, so the downside is you're downloading headers twice so that might be another 100 megabytes or so in the ideal case.\nHowever, compared to the size of the blockchain, it's not too bad.\nAnd compared to the worst-case attack, it's definitely not bad.\n\nAaron van Wirdum: 00:14:53\n\nAnd of course, even if an attacker would want to try this for some reason, it's also costing the attacker resources because he has to upload all the same data you have to download.\nIt doesn't really do much, this attack, right?\nIt can't allow you to steal coins or anything like that.\n\nSjors Provoost: 00:15:10\n\nWell, with this defense, no, because all they can do is waste your bandwidth.\nAnd there are many ways to waste your bandwidth, right?\nAn attack can just send you a gigabyte block and it would or just complete gibberish in general so that's not a new problem\n\nAaron van Wirdum: 00:15:24\n\nokay so this was included in Bitcoin Core 24 and will be\n\nSjors Provoost: 00:15:28\n\nAnd the checkpoints are still there But the idea would be to remove them eventually.\n\nAaron van Wirdum: 00:15:32\n\nOkay, so that would be removed in a future release?\n\nSjors Provoost: 00:15:36\n\nYeah, and of course, you know, there has to be some additional discussion to make sure that that was really the last thing we needed, that the checkpoints are not also protecting against something else that we forgot about.\n\n## Full-RBF\n\nAaron van Wirdum: 00:15:44\n\nOkay, well, that's the peer-to-peer part of Bitcoin 24.\nThen the next point is Mempool uses full-RBF now or can use full RBF?\n\nSjors Provoost: 00:15:57\n\nCan use full-RBF.\nSo it used to be that if you wanted, I think we've done an episode about replace by fee, RBF.\nSo I think the listeners should listen to that.\n\nAaron van Wirdum: 00:16:06\n\nYou can summarize it in two sentences.\n\nSjors Provoost: 00:16:08\n\nSo basically the Bitcoin protocol itself, when you have one transaction and then you want to double spend it, there's nothing stopping you from doing that before it's in a block.\nNow, from an incentive point of view, miners are most likely to include the block with the highest fee, but they don't necessarily have to.\n\nAnd so there was a proposal by Peter Todd many, many years ago to say, well, normally the nodes, well, let's go one step back.\nSo what miners do is ultimately up to miners.\nYou have no control over that.\nAnd Bitcoin Core can change things in the software, but miners will do whatever they do, because what the mempool does is not consensus.\n\nHowever, the nodes will relay transactions.\nAnd so you can change the nodes to say, well, I'm gonna broadcast some transactions and not gonna rebroadcast other transactions.\nAnd so this new rule, opt-in replaced by fee, opt-in RBF, basically said that normally we only broadcast the first version of the transaction we see, regardless of the second one.\nDoesn't matter if the second one pays more fees.\nBut if you put a flag in a transaction that says, I want to opt-in to replace by fee, then nodes will refer, will relay transactions that pay a higher fee only and a bunch of other constraints.\nAnd so this gives the recipient some assurance, not much, but some assurance that if this flag is present, this transaction could be replaced anytime.\nYou really have to wait for it to confirm.\nIf it doesn't have this flag, it might still disappear.\nIt's just a little bit less likely.\n\nAaron van Wirdum: 00:17:35\n\nYeah, I want to clarify one thing because you mentioned double spending in this context.\nAnd you are of course right that this can be used to double spend until it's included in a block, as you said.\nBut the main purpose or the main idea for using a flag, for example, is to increase the fee on your own transaction, right?\n\nSjors Provoost: 00:17:54\n\nI don't know how long that idea has been around because the idea of being stuck in a mempool, that concept didn't even exist until 2015 or 2016.\nThat was never a problem.\n\n### RBF summary\n\nAaron van Wirdum: 00:18:04\n\nBut it was the flag was introduced around that time and definitely in the context of that, that was the debate.\nYeah, I'm sure about that.\nSo to summarize that, At least the idea for the flag was you send a transaction, but the mempool was full, and therefore your transaction is not confirming.\nNow with the RBF flag, you can basically resend the same transaction with a higher fee, and therefore, because the flag is included, nodes will actually forward it to miners and it can be included in a block.\n\nNow you don't actually need to include the flag anymore.\nIf this setting is turned on?\n\nSjors Provoost: 00:18:44\n\nYeah, I think that if you turn this setting on, then the flag does no longer have to be in there, it'll relate anyway so then I'm guessing there are other rules though because I assume the fee has to go up but I'm not sure about that\n\nAaron van Wirdum: 00:18:56\n\nSo in my case, if so far I was running Bitcoin Core 23, my node would not forward a transaction even if it had a higher fee and it conflicted with the previous transaction.\nIt would not do that.\nBut now with Bitcoin 24 I can switch the setting and now it will actually forward that transaction.\n\nSjors Provoost: 00:19:22\n\nYeah, I think that's it and it basically means that if you're relying on this opt-in RBF system to prevent double spends, basically to prevent double spends, you should now rely on that less so, because there's going to be more nodes that will relay this thing regardless.\n\nAaron van Wirdum: 00:19:37\n\nI don't know about almost certainly, but there's definitely a much bigger chance that a conflict in a transaction will make it to a miner now, right?\nBecause I think there only needs to be a relatively small amount of notes on the network that actually do it for a transaction to just find its way over the entire network.\n\nSjors Provoost: 00:19:54\n\nBut there were already ways to do it, right?\nThere was a patch by Peter Todd which was pretty small and you could use that to modify your nodes.\nSo there's already some nodes doing it.\nNow there's more, presumably.\n\n### Merchants\n\nAaron van Wirdum: 00:21:06\n\nSo does this mean that some merchants are going to be unhappy?\n\nSjors Provoost: 00:21:12\n\nWell, they might be for that reason.\n\n\nAaron van Wirdum: 00:21:13\n\nThere are still some merchants that rely on zero-conf.\n\nSjors Provoost: 00:21:15\n\nYeah, there are definitely merchants that do that.\nBut the flip side is that there are also merchants that use Lightning and Lightning is generally bothered a lot by this, by the existing RBF rules because they make it much more complicated to deal with penalty transactions.\nSo they may get, in the long run, they may get a better lightning experience out of this.\n\nAaron van Wirdum: 00:21:36\n\nI mean, my personal opinion is that this should just be the general rule.\nTransactions should always be broadcast and forwarded, especially if they have a higher fee.\n\nSjors Provoost: 00:21:48\n\nI mean, maybe, we've already had this discussion during that episode, I guess, but I would also say that if you just turn on the RBF flag by default, it shouldn't bother you either.\nBut I think the bigger problem is that this RBF flag has very specific rules.\nIt's not just that you set the flag, you also have to do a few other things and those other things cause complications.\nSo that could be a reason to say, you know what, let's forget about this opt-in RBF completely and relay everything that is reasonable.\nBut there are trade-offs.\nOne is just bandwidth because if my node relays everything that you sent to it, I could send you one transaction and then increase it by one satoshi per byte or increase it by.\nDon't even increase the fee, but just change the destinations a bit, and I could send you millions and millions of variations of the same transaction, basically wasting everybody's bandwidth.\nSo it's not entirely without trade-offs.\n\n## Descriptor Wallet Migration\n\nAaron van Wirdum: 00:22:39\n\nAll right, let's move on to the third point.\nSo we mentioned the change on the peer-to-peer network, the block header thing, and we just mentioned RBF.\nAnd then the third point is this related to descriptor wallets and migration to the descriptor wallets?\n\nSjors Provoost: 00:22:52\n\nYeah, I'm not sure how much we covered the descriptor wallets so far but the gist of it is that the Bitcoin Core wallet is quite old.\n\nIt used to be just a bag of keys and then given a private key, the wallet would have to pay attention to certain scripts.\nI think in one of the first episodes we explained what scripts are.\n\nBut the simplest scripts is just that anybody with the public key can spend this coin.\nThe second simplest script is that anybody with the hash of the public key can spend the coin or anybody with the public key for which the hash is blah, blah, blah.\nAnd then there was, but then later on came SegWit and that created another two variations of how you could spend the coins.\nBecause you had the address of BC1, and you had the address that looked like a P2SH address with SegWit wrapped in it.\nSo the wallet just became a giant mess.\n\nAaron van Wirdum: 00:23:42\n\nBecause you have multi-sig writes and stuff like that.\n\nSjors Provoost: 00:23:45\n\nWell, yeah, that makes it even more complicated.\nBut basically the Bitcoin Core wallet became a bit unwieldy.\nAnd so one of the improvements that was introduced was to create a new way to store data and basically saying, well, here's keys, but more importantly, here's exactly what scripts you want to watch for.\nSo you can specifically say, I only want to check for Taproot transactions for this private key, and not also for legacy transactions for this private key.\nNow your wallet handles all this.\n\nAaron van Wirdum: 00:24:14\n\nWhat are the practical benefits of that?\nJust less resources?\n\nSjors Provoost: 00:24:17\n\nFor the end user, this doesn't matter.\n\nSjors Provoost: 00:24:19\n\nIt just means that their wallet software is better maintained.\nBecause it's less of a headache for the wallet developers to deal with this.\nSo it basically involved the giant rewrite, mostly done by Andrew Chow.\nAnd one of the challenges there is we have this old wallet and we want to move people over to the new wallet.\nAnd so the first step for that is this new RPC call called `migratewallet`, which does what it says it does.\n\nAaron van Wirdum: 00:24:43\n\nIt will migrate your wallet?\n\nSjors Provoost: 00:24:45\n\nAnd for the simplest cases, you know, if you created a wallet in the last couple years and you didn't do anything super fancy, very complicated, multi-sig setups, whatever, this will work.\nIf you did do something complicated, then please test it.\nIt'll make a backup, but maybe make your own backup too.\nAnd we'd like to see bug reports basically, because maybe you have some super complicated wallet setup that does not migrate properly.\n\nAaron van Wirdum: 00:25:09\n\nSo basically what this does is your wallet software will just go over all of the UTXOs and say, what, this is a paid to public key?\nThis is a multisig.\nAnd throw them into different buckets\n\nSjors Provoost: 00:25:19\n\nNo, it will not go over the UTXOs.\n\nSjors Provoost: 00:25:22\n\nNo, it will go over the keys inside the wallet.\nThe transaction list you have is kind of the same.\nIt'll look through what keys you have in the wallet and it will restructure those as descriptors.\n\nAaron van Wirdum: 00:25:31\n\nIt will throw these in the different buckets?\nOkay, instead of one big bucket.\n\nSjors Provoost: 00:25:36\n\nThat's right.\n\nAaron van Wirdum: 00:25:37\n\nOkay, I think that's clear enough then.\nAnd as mentioned, this is mostly to benefit just the developers, not so much users.\n\nSjors Provoost: 00:25:46\n\nI mean yeah, the users benefit indirectly, but yeah, it does.\nI mean, descriptors have already been used to allow taproot.\nSo if you wanted to use Taproot, you either need to create a whole new wallet or you need to migrate to a descriptor wallet and then add Taproot to it.\nSo there is that too.\n\n## Miniscript Support\n\nAaron van Wirdum: 00:26:04\n\nOkay, there's been moving on to the fourth point, Miniscript support.\nHas Miniscript support been added to Bitcoin Core?\n\nSjors Provoost: 00:26:11\n\nYes, in very limited fashion.\nI think we have done a whole episode about Miniscript, but it basically lets you do very advanced scripting systems.\nSo something like I want to spend with two keys or I want two signatures or after five years I want one signature Or if somebody has the pre-image of this SHA-256 hash, then they only need one signature plus whatever.\nMiniscript allows you to do fairly arbitrarily complicated things.\nAnd Bitcoin Core can now, if you have a piece of Miniscript, it can now watch that.\nYou cannot spend from it yet.\n\nAaron van Wirdum: 00:26:48\n\nI mean, the other way to put it, the simple way to put it maybe is miniscript allows for smart contracting type of stuff, right?\n\nSjors Provoost: 00:26:59\n\nYeah, I guess.\nI mean that might be overselling it a bit, but yeah.\nTo the degree that Bitcoin can support smart contracts, the Bitcoin script language is very complicated.\nYou don't want to write Bitcoin script by hand, you will make mistakes.\nLike even Andrew Poelstra and people like that will make mistakes.\nSo, Miniscript is designed to get the most out of the existing Bitcoin script system in a safe way.\nThat's, I think, the most fair way to put it.\n\nAaron van Wirdum: 00:27:26\n\nRight, sorry, and what does it mean that it's been added now?\nIn what way has it been added?\n\nSjors Provoost: 00:27:31\n\nIt means you can create a wallet.\nSo if you create a new wallet, you can put a piece of miniscript inside of that wallet and it will basically let you create addresses for that miniscript and you can send coins to those addresses.\nBut you can't spend them.\n\nAaron van Wirdum: 00:27:44\n\nI see.\nSo, you can't spend them.\nNot yet.\n\nSjors Provoost: 00:27:48\n\nSo you shouldn't do that.\n\nAaron van Wirdum: 00:27:49\n\nOkay, yeah, don't do it yet.\nAnd this sounds like you might need to run a separate wallet or a separate piece of software that you connect to your Bitcoin Core node.\n\nSjors Provoost: 00:28:00\n\nNo, well, yeah, in order to create the miniscript itself, you will need separate software.\nThere is a miniscript compiler, but you can write miniscript by hand too if you want to.\nSo, in principle, you don't need a second piece of software.\nNow, the idea is that a future version of Bitcoin Core will also be able to sign for it.\nBut you shouldn't count on that, you shouldn't use it until it does.\n\nAaron van Wirdum: 00:28:21\n\nOkay, well this sounds like a pretty big step then, doesn't it?\nIt sounds to me like it's a pretty big step.\n\nSjors Provoost: 00:28:26\n\nI think it is pretty big, yeah.\nAnd the other constraint is that it only works for the first version of SegWit.\nSo those are addresses with BC1Q.\nSo it does not work for Taproot yet.\nAnd because there's a lot of work that needs to be done, or at least there is work that needs to be done in order to have Miniscript work with Taproot at all.\nAnd then once it does that in general, so the specification of the manuscript can handle it, then the next challenge is to actually get that into Bitcoin Core and to really use Taproot and Miniscript well, you probably want musig to the signature aggregation stuff.\nThat also needs to be added to Bitcoin Core.\nSo there is a ton of work still left to do.\nBut this is one step.\n\nAaron van Wirdum: 00:29:06\n\nIs there currently, so we're right now talking about Bitcoin Core, obviously.\nIs there currently other Bitcoin software that already allows you to create and use Miniscript?\n\nSjors Provoost: 00:29:17\n\nNo, as far as I know, there is there's basically a library called Rust Miniscript and a library written by CPython that does Miniscript and C++ Those libraries you can use but they're not fully functional wallets So I don't know if anybody is using Miniscript in the wild, maybe Blockstream is for their what is it?\nLiquid sidechain stuff, I would know.\n\nAaron van Wirdum: 00:29:36\n\nOkay, well interesting, like I said that sounds like a pretty big step actually.\n\nSjors Provoost: 00:29:43\n\nYeah, and it would also I think This is the longer-term trend of hopefully turning Bitcoin Core from a not a very good wallet, was quite slow, quite weird, to hopefully a very good wallet.\nAnd at least a very good wallet for power users, right?\nSo maybe exchanges want to use it more.\nMy hope is that if this wallet becomes very powerful, then more people will help review the code and more people will help improve it.\nSo you kind of get this self-amplifying effect.\nOnce it's useful enough, more people will look at it, but it takes a very long time to become useful enough because it's not useful enough so not enough people are working on it.\nIt's really I think maybe four people.\n\n## Opt-in RBF\n\nAaron van Wirdum: 00:30:27\n\nAll right moving on to the next point.\nThe next point on our list is another point about RBF.\n\nSjors Provoost: 00:30:36\n\nThis is just about opt-in RBF, that the wallet will, the wallet RPC, so the command line wallet will now use it by default.\n\nAaron van Wirdum: 00:30:45\n\nOh, that's right.\nOkay, wait, so we're not talking about the GUI, right?\n\nSjors Provoost: 00:30:49\n\nNo, the GUI already switched to use RBF by default.\n\nAaron van Wirdum: 00:30:53\n\nAnd now the command line does as well?\n\nSjors Provoost: 00:30:54\n\nYeah.\n\nAaron van Wirdum: 00:30:56\n\nOkay, go on.\nMaybe I should just let you finish.\n\nSjors Provoost: 00:30:58\n\nSo why didn't it?\n\nAaron van Wirdum: 00:30:59\n\nYeah, why didn't it yet?\n\nSjors Provoost: 00:31:00\n\nSo one of the reasons is that people are using the Bitcoin Core wallet in some automated systems.\nSo if you're running a Bitcoin ATM, you may have some really old software that does not know that RBF exists, maybe because it's really old, and it might get confused if it's turned on by default.\nSo for those kind of systems you don't want to change things too quickly.\nBut I think it's been five years now so might be a good time to switch to default.\n\nAaron van Wirdum: 00:31:24\n\nThat should be enough time.\n\nSjors Provoost: 00:31:26\n\nWell hopefully.\n\nAaron van Wirdum: 00:31:28\n\nOkay, so would we expect more RBF transactions on the network now?\n\nSjors Provoost: 00:31:34\n\nWe'll have to see.\nIt depends on when people start using it.\nMy hope is no because my hope is that anybody who builds this kind of software already decided whether they want RBF on or off because it's just a default value.\nYou probably should already set that default to what you want it to be so that you're not surprised by this update.\nSo I hope to see no difference.\n\nSjors Provoost: 00:31:55\n\nBecause the worst-case scenario would be that some major company that has RBF turned off for some reason now suddenly turns it on and starts producing lots of RBF transactions confusing everybody in their ecosystem.\n\nAaron van Wirdum: 00:32:08\n\nYeah, it wouldn't really harm them in any way, would it?\n\nSjors Provoost: 00:32:12\n\nI don't know, maybe people are using that service to send coins to some other service that does not like it when transactions are RBF.\n\nAaron van Wirdum: 00:32:20\n\nYeah that does not accept RBF transactions.\n\nSjors Provoost: 00:32:22\n\nOr gets confused by them.\n\nAaron van Wirdum: 00:32:24\n\nYeah, these are out there.\nOkay, makes sense.\n\nSjors Provoost: 00:32:28\n\nSo that's why you want to be a little bit slow with these command line tools to change them.\n\n## Change Output\n\nAaron van Wirdum: 00:32:33\n\nRight, okay, I think we've covered five points now and we got seven in total, so we got two more to go.\n\nSjors Provoost: 00:32:40\n\nAll right.\n\nAaron van Wirdum: 00:32:42\n\nNumber six.\nThe change output amounts are randomized.\nIt says that's what it says.\n\nSjors Provoost: 00:32:52\n\nIt's very cool.\nYeah, so basically this has to do I mean I don't know the precise change, but the general problem is that when you're looking at the blockchain, you can kind of guess which address is changed and which address is not changed if you have an assumption about how the wallet picks coins.\nSo if the wallet is very efficient, it will look for the smallest coin possible to spend and then it will create as little change as possible.\nBut that means that generally when you see two outputs to a transaction, the biggest one is probably the amount that's being sent and the smallest one is probably the change.\n\nAaron van Wirdum: 00:33:30\n\nWell, is that necessarily true?\nThat's maybe true if there are several inputs, right?\nThat logic only holds up if there are several inputs, I think.\n\nSjors Provoost: 00:33:41\n\nOr if there's one input.\n\nSjors Provoost: 00:33:44\n\nLet's say you, well, if there is, depends on how much there is available, right?\nBut you're looking at the chain, so you don't know what was available.\nBut if your wallet is looking at a bag of coins, it might start with the smallest coin saying, nah, it's not big enough.\nAnd then keep looking and then find one coin that's big enough.\nAnd then use that to spend it.\nAnd it doesn't really matter, but if you know what software the person was using based on some other fingerprinting aspects, you can start then.\nYou know how that software works, you know how that software does its coin selection, you can use that against the user.\n\nAaron van Wirdum: 00:34:17\n\nOkay so do you know what algorithm Bitcoin Core was using up till now?\n\nSjors Provoost: 00:34:22\n\nIt's using a bunch of algorithms.\n\nAaron van Wirdum: 00:34:25\n\nOh several, and do you know which ones or no?\n\nSjors Provoost: 00:34:26\n\nNo, I should ask Murch.\nHe wrote a whole thesis on it and implemented a bunch of things.\nOne of them is-\n\nAaron van Wirdum: 00:34:31\n\nBut something changed.\n\nSjors Provoost: 00:34:33\n\nI think originally the system was called the knapsack.\nAnd I think the knapsack basically meant you just grabbed coins randomly and then see if it was enough.\nAnd then if it wasn't, you try it again.\nAnd then there was a new thing called branch and bound, which was a bit more smarter way to find coins.\nAnd there's also the trying to find a single coin that is exactly the right value strategy.\n\n\nSjors Provoost: 00:34:57\n\nThere's a bunch of things that are happening.\nIt's a bit complicated.\nBut what this basically does is make it more difficult to tell which one is the input, sorry, which one is the change and which one is the destination.\nAnd the way you do that is basically saying, well, rather than looking for the coin of the exact right size to spend, I'm going to look for a coin that is the amount that I need to spend plus two times the, yeah, I'm going to look for a coin that is at least three times, I guess, the amount that I'm trying to spend.\n\nAaron van Wirdum: 00:35:25\n\nRight, so you want to spend one Bitcoin, so you're going to look for UTXO of three Bitcoins.\n\nSjors Provoost: 00:35:29\n\nYeah, except you're not going to do that.\nYou're going to say, I'm going to pick a number between the amount I want to spend and three times the amount I want to spend between one and three yeah and I'm gonna pick that number randomly right so that means sometimes the biggest sometimes you're gonna pick a very high number and so the change address will actually be the smaller will be the bigger output And sometimes I pick the lower random number and the change output will be the biggest amount.\n\nAaron van Wirdum: 00:35:53\n\nOkay, so we're basically gonna keep using the algorithm that we were using, or at least, I don't know, but that's my assumption.\n\nSjors Provoost: 00:35:59\n\nYeah, I think that doesn't change.\n\nAaron van Wirdum: 00:36:01\n\nHowever, we're now going to look for coins as if we're looking for one to three times more than what we are actually spending.\n\nSjors Provoost: 00:36:09\n\nExactly.\nAnd that number is random.\n\nAaron van Wirdum: 00:36:10\n\nThat sounds interesting.\nDoesn't that mean that you sometimes end up using more UTXOs than you would actually require?\nIn other words, wouldn't you make transactions bigger than they really need to be?\n\nSjors Provoost: 00:36:25\n\nYeah, I think that might mean that sometimes you are spending more coins than necessary.\n\nAaron van Wirdum: 00:36:31\n\nOkay, so it's not optimizing for fees then or it's not also optimizing.\n\nSjors Provoost: 00:36:35\n\nI don't think so but there may be some caveats in that code you'd have to read through it to see what exactly it's doing maybe there's some some protection against spending too much on fees.\n\nAaron van Wirdum: 00:36:44\n\nRight Maybe it only works if this is not the case.\n\n\nSjors Provoost: 00:36:49\n\nI mean, if you're using the GUI, you can also do your coin selection completely manually.\nThere is a little menu where you can see what your inputs are and just select which ones you want to spend.\n\nAaron van Wirdum: 00:36:58\n\nSo there might be trade-offs that we're not completely clear on, but the general idea is you're going to look for more coins than you actually need for privacy purposes.\nThat's ultimately the benefit, right?\n\nSjors Provoost: 00:37:09\n\nYeah. I suppose one day we should do an episode about coin selection.\nThis is also something I haven't specialized in.\n\nAaron van Wirdum: 00:37:14\n\nYeah, we should maybe.\nThat does sound like an interesting topic.\nWe can go over all of this.\nLast point, Sjors.\n\n## SendAll\n\nSjors Provoost: 00:37:23\n\nYeah, this one isn't super interesting.\nIt's a new RPC called `sendall`.\nAnd so this is a command line tool.\nAnd the name suggests that you're sending all your money.\nThat's not actually true.\nYou can use it to send all your money away to a different wallet, let's say if you're trying to migrate.\nBut you can also say, take these coins, so these specific input coins, and send them all to a specific destination.\nThis is stuff that you could already do because there was one command line tool called `sendmany` and `sendtoaddress`.\nThere basically were already calls to do this.\n\nAaron van Wirdum: 00:37:55\n\nYeah, also in the GUI this is already possible, right?\n\nSjors Provoost: 00:37:58\n\nYeah.\nSo the underlying motivation here is actually that there are different intentions that the user might have.\nThey might want to send an entire coin to an exchange for privacy reasons or they might want to send an exact amount to an exchange and in retrospect, you don't really know what the user intended so that creates problems when you try to bump the fee.\nBut also the code that actually implements this is a bit of a mess because it has all these different features.\nSo you can do all these different things for different use cases.\nThat means your code is full of if, then, else, if, if, else, else, if.\nAnd so basically this is the first step to splitting that up to saying okay if you want to do this specific thing use the `sendall` method if you want to do this other thing use the send method and that's the first step to just you know at the command line it's easier to tell users to start using two different commands for two different things and then eventually I guess under the hood there will be some changes to the GUI to also use the separation.\n\nAaron van Wirdum: 00:38:52\n\nI mean, this sounds like something that basically all wallets already do.\n\nSjors Provoost: 00:38:58\n\nI don't know.\nLike I said, it's not a new piece of functionality.\n\nAaron van Wirdum: 00:39:01\n\nThe insulting thing though, is that other wallets, the universally accepted term for this is send-max.\n\nSjors Provoost: 00:39:07\n\nYeah, but it's send-max given a set of coins.\n\nAaron van Wirdum: 00:39:12\n\nThat's also what send-max is I think or not?\n\nSjors Provoost: 00:39:14\n\nI don't know yeah could be.\n\nAaron van Wirdum: 00:39:15\n\nThat's how I use it.\nThat's how I think about it.\nNo, but I get your point.\nOkay, yeah, this was not the most exciting future of the seven, but I'm happy we covered it, Sjors.\nAre you?\n\nSjors Provoost: 00:39:24\n\nLast but not least.\nYeah, like I said, there's probably at least probably 500 or maybe a thousand individual changes that could each be worth their own episode if you were truly interested in how compilers work and whatever.\n\nAaron van Wirdum: 00:39:36\n\nWell, we covered the highlights.\nAt least we covered our highlights.\nI think so too.\nAnd I think that makes for another successful episode, Sjors.\n\nSjors Provoost: 00:39:45\n\nWe'll see thank you for listening to Bitcoin\n\nAaron van Wirdum: 00:40:45\n\nExplained.\n\n",
    "body_type": "markdown",
    "created_at": "2022-10-07T00:00:00.000Z",
    "domain": "https://btctranscripts.com/",
    "url": "https://btctranscripts.com/bitcoin-explained/bitcoin-core-v24",
    "categories": [
        "podcast"
    ],
    "tags": [
        "bitcoin-core",
        "rbf",
        "coin-selection",
        "descriptors",
        "miniscript"
    ],
    "media": "https://www.youtube.com/watch?v=3UfrB7_ZOx0",
    "authors": [
        "Sjors Provoost",
        "Aaron van Wirdum"
    ],
    "indexed_at": "2024-03-21T16:33:36.099Z",
    "transcript_by": "realdezzy via review.btctranscripts.com",
    "summary": "In a recent episode of Bitcoin Explained, Sjors Provoost and Aaron van Wirdum engaged in a comprehensive discussion on the forthcoming Bitcoin Core release, version 24.0, from the picturesque city of Utrecht. The episode began on a lighter note, with conversations around the impact of daylight saving time on daily routines, setting a relaxed atmosphere for the deeper dive into Bitcoin's technical developments that followed.\n\nThe hosts illuminated the unique approach behind Bitcoin Core's update cycle, emphasizing its deviation from a fixed roadmap in favor of a more fluid, feature-ready release strategy. They detailed the biannual release pattern supplemented by minor updates focused on bug fixes, highlighting the community's commitment to maintaining the network's stability and security. This iterative process ensures each version undergoes thorough testing through \"release candidates\" before official deployment, showcasing a meticulous dedication to quality within the Bitcoin development ecosystem.\n\nA significant portion of the discussion was dedicated to explaining a pivotal enhancement in the new release aimed at improving the efficiency and security of the initial block download process. Provoost and van Wirdum elucidated how the modification in how Bitcoin nodes download headers from peers would bolster the blockchain's integrity by allowing nodes to verify the chain's authenticity and cumulative proof of work more effectively. This change not only enhances security but also optimizes the synchronization process for nodes joining the network.\n\nFurther delving into the defense mechanisms against cyber-attacks, particularly those targeting network resources through spamming fake block headers, Provoost shared insights into the innovative strategies adopted to mitigate these risks. The conversation highlighted the shift from static checkpoints to dynamic methods like double-header downloading from different peers, providing a nuanced view of Bitcoin's evolving security measures against resource exhaustion attacks.\n\nTurning their attention to transaction dynamics within the Bitcoin network, the hosts discussed the full adoption of Replace-by-Fee (RBF) capabilities, enabling users to adjust transaction fees to prioritize processing times amidst network congestion. This feature, initially proposed by Peter Todd, represents a significant evolution in user experience, allowing for greater flexibility in managing transactions on the Bitcoin network.\n\nThe podcast took another deep dive into the technological strides made with Bitcoin Core's transition towards descriptor wallets and the integration of Miniscript support. These developments mark a paradigm shift in how transactions are managed and validated, offering enhanced flexibility and security through a more structured, script-focused approach. The introduction of `migratewallet` RPC call for seamless migration to descriptor wallets and the potential of Miniscript for advanced smart contracting were highlighted as key milestones in Bitcoin Core's ongoing evolution.\n\nIn concluding their rich dialogue, Provoost and van Wirdum explored the broader implications of these updates for both power users, such as exchanges, and everyday Bitcoin enthusiasts. The integration of features like Miniscript, opt-in RBF on the command line interface, and privacy-enhancing measures like randomization of change output amounts reflect Bitcoin Core's commitment to enhancing user privacy, operational flexibility, and overall network efficiency.\n\nThrough this insightful episode, Provoost and van Wirdum provided listeners with a profound understanding of the significant technical advancements and future directions in Bitcoin Core development. Their discussions underscored the collective effort and innovation driving the Bitcoin ecosystem forward, ensuring its adaptability, resilience, and continual growth in the face of evolving challenges and opportunities."
}