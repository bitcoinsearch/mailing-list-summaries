{
    "id": "bitcointranscripts+bitcoin-explained+scaling-bitcoin-with-the-erlay-protocol",
    "title": "Scaling Bitcoin With The Erlay Protocol",
    "body_formatted": "{\"type\":\"heading\",\"text\":\"Preamble\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:00:07\"}, {\"type\":\"paragraph\",\"text\":\"Live from Utrecht, this is the Van Wirdum Sjorsnado.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:00:10\"}, {\"type\":\"paragraph\",\"text\":\"Hello again.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:00:12\"}, {\"type\":\"paragraph\",\"text\":\"We've done it again, Sjors.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:00:14\"}, {\"type\":\"paragraph\",\"text\":\"We've done it again.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:00:15\"}, {\"type\":\"paragraph\",\"text\":\"We recorded the whole episode without actually recording it.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:00:18\"}, {\"type\":\"paragraph\",\"text\":\"Yeah.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:00:19\"}, {\"type\":\"paragraph\",\"text\":\"So we're going to do the whole thing over.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:00:20\"}, {\"type\":\"paragraph\",\"text\":\"It's this thing where you press the button, but you don't press it hard enough.\\nAnd you have to check if the red light is blinking.\\nIt is now.\"}, {\"type\":\"heading\",\"text\":\"Sidebar about Podcast 2.0 Sat Streaming\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:00:28\"}, {\"type\":\"paragraph\",\"text\":\"Great. I think you have a bit of news, some exciting news for us.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:00:33\"}, {\"type\":\"paragraph\",\"text\":\"That's right. You can now stream your sats to us (Sjors and Aaron).\\nYeah, you can. It's very cool.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:00:41\"}, {\"type\":\"paragraph\",\"text\":\"How does that work?\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:00:49\"}, {\"type\":\"paragraph\",\"text\":\"The way it works is this standard called Podcasting 2.0.\\nSo for those who don't know, a podcast is essentially just an RSS feed with a bunch of information like the title and a nice picture and for every episode a link to some mp3 file that your podcast player downloads.\"}, {\"type\":\"paragraph\",\"text\":\"But it turns out you can add more stuff to this RSS feed and Adam Curry, the original podcaster, he basically started a project called Podcasting 2.0 which adds a bunch of new fields and one of those new fields is called 'value' and this value field lets you add for example a Lightning node public key to the RSS feed of your podcast.\"}, {\"type\":\"paragraph\",\"text\":\"And then if you have a podcast player that understands this, like a normal podcast player will just ignore it, but a player like in the Breez iOS test flight app, I think also like in the Sphinx app, if they understand it, and they have Lightning available, they'll start streaming sats to you as the people are listening.\\nAnd you can suggest a rate, but people can choose it themselves.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:01:58\"}, {\"type\":\"paragraph\",\"text\":\"So people can either listen for free or they can pay us.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:02:01\"}, {\"type\":\"paragraph\",\"text\":\"That's right.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:02:02\"}, {\"type\":\"paragraph\",\"text\":\"Well, let's see what they choose.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:02:04\"}, {\"type\":\"paragraph\",\"text\":\"So not only that, they can listen for free in a really well-functioning app maintained by Apple, or they can use very experimental software and have to deal with Lightning and then pay us.\"}, {\"type\":\"paragraph\",\"text\":\"We'll see which people prefer.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:02:21\"}, {\"type\":\"paragraph\",\"text\":\"Sounds like we're gonna be stacking sats, Sjors.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:02:23\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, I think the last time I checked the node there was zero sats in it, but it's only been live for a couple hours.\"}, {\"type\":\"heading\",\"text\":\"Sidebar about Taproot activation 'coin flip'\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:02:29\"}, {\"type\":\"paragraph\",\"text\":\"The other thing I wanted to mention is people keep pinging me about the coin flip.\\nDid you hear about the coin flip?\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:02:34\"}, {\"type\":\"paragraph\",\"text\":\"I did because you just told me in the previous take.\\nBut tell me again.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:02:38\"}, {\"type\":\"paragraph\",\"text\":\"I'm trying to pretend a little bit like this is an original episode.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:02:42\"}, {\"type\":\"paragraph\",\"text\":\"All right.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:02:43\"}, {\"type\":\"paragraph\",\"text\":\"I'll try that.\"}, {\"type\":\"paragraph\",\"text\":\"So the Speedy Trial discussion was winding down to block height or block time, which we discussed in our episode about Speedy Trial that was about Taproot activation.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:02:57\"}, {\"type\":\"paragraph\",\"text\":\"And the difference is basically, at least I find block height a little bit easier to understand, but the existing soft forks so far and BIP9 have all used block time, which is fine.\\nIt's just a little bit more difficult to think about, but in terms of code I don't think it matters that much.\"}, {\"type\":\"paragraph\",\"text\":\"So there's now two pull requests.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:03:17\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, and it looks like it's going to be the block time one based on a blockchain based coin flip they did.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:03:24\"}, {\"type\":\"paragraph\",\"text\":\"That's amazing, even though they can be gamed.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:03:31\"}, {\"type\":\"paragraph\",\"text\":\"This was mentioned on the IRC chat as well.\\nBut, it would be pretty expensive to game it.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:03:37\"}, {\"type\":\"paragraph\",\"text\":\"Well, the future is at stake, right?\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:03:40\"}, {\"type\":\"paragraph\",\"text\":\"The future of Bitcoin is at stake.\\nIf Speedy Trial happens at all... There's been a couple of NACKs by now, so we'll have to see.\"}, {\"type\":\"paragraph\",\"text\":\"This is not what our episode is about.\\nOur episode Sjors, this episode, episode 34 is about Erlay.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:03:56\"}, {\"type\":\"paragraph\",\"text\":\"Erlay.\"}, {\"type\":\"heading\",\"text\":\"Erlay\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:03:58\"}, {\"type\":\"paragraph\",\"text\":\"So [Erlay](https://arxiv.org/abs/1905.10518) is a project, I think it was started at the University of British Columbia, or at least University of British Columbia researchers Gleb Naumenko, Alexandra Fedorova and Ivan Beschastnikh were working on it, as well as Blockstream's Pieter Wuille and Greg Maxwell.\"}, {\"type\":\"heading\",\"text\":\"The problem that Erlay solves\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:04:32\"}, {\"type\":\"paragraph\",\"text\":\"So, Erlay, the problem it solves, Sjors, is that nodes use bandwidth.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:04:43\"}, {\"type\":\"paragraph\",\"text\":\"Lots of bandwidth.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:04:44\"}, {\"type\":\"paragraph\",\"text\":\"Yes, and this is a problem because we want people to be able to run full nodes.\\nAnd if full nodes use bandwidth and bandwidth costs money, the more bandwidth means it's more expensive to run a full node, which means fewer people will run full nodes or at least they'll be incentivized not to and it would be good if we could reduce the cost of running a full node.\"}, {\"type\":\"paragraph\",\"text\":\"So it would be good if we could find ways to make it cheaper to run full nodes which means if we could find ways to reduce bandwidth use.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:05:21\"}, {\"type\":\"paragraph\",\"text\":\"That's right and we've previously talked about downloading the blockchain as a source of bandwidth use and we talked about some ways to make that smarter.\\nBut, now we're going to talk about the transactions that are not yet in a block, the mempool.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:05:37\"}, {\"type\":\"paragraph\",\"text\":\"I want to finish (describing) the benefits (first).\"}, {\"type\":\"paragraph\",\"text\":\"Part one is it would be good if we could reduce bandwidth or if people choose to keep using the amount of bandwidth they're currently using, if we could further optimize the efficiency there, then we could have nodes connect to more other nodes.\\nWhich, would in turn benefit network robustness it would counter certain types of attacks like Eclipse attacks.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:06:09\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, because we talked about Eclipse attacks in earlier episodes and one of the solutions we already mentioned is: Well, just connect to more peers.\\nAnd there is a big downside to that, which we'll explain in a bit in terms of bandwidth use.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:06:23\"}, {\"type\":\"paragraph\",\"text\":\"So, if we could optimize bandwidth use, that means people can either run a full node more cheaply, or they can connect to more nodes, which counter certain types of attacks, or a bit of both. That's what we're trying to do is reduce bandwidth use.\"}, {\"type\":\"paragraph\",\"text\":\"So you already mentioned this, there's basically two main things that cause bandwidth.\\nOne of them is receiving and forwarding blocks themselves and this is what the blockchain consists of.\\nAnd, the other thing is receiving and forwarding transactions.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:06:59\"}, {\"type\":\"paragraph\",\"text\":\"That's right. Before they are in the block.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:07:02\"}, {\"type\":\"paragraph\",\"text\":\"This is how transactions find their way over the network, which ultimately is how they find their way to miners so they know which transactions they can include in blocks.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:07:14\"}, {\"type\":\"paragraph\",\"text\":\"Every node has a thing called the mempool, which is where they keep track of transactions that aren't in the block yet and they relay those to their peers.\"}, {\"type\":\"paragraph\",\"text\":\"And you might say, \\\"Well, why would you do that?\\\"\"}, {\"type\":\"paragraph\",\"text\":\"Well, there's some selfish interest in (that) you want to know as soon as somebody's about to send you a transaction, and you want to know as soon as somebody is about to cheat on you on Lightning.\\nIt's nice to know that these transactions might start happening before they're in a block.\"}, {\"type\":\"paragraph\",\"text\":\"But, there's also an altruistic reason: If nobody did this, then transactions would not get to miners, because you'd have to know which nodes are the miners and send it directly to them.\\nAnd so, especially because it's altruistic, you want to make it cheap or get a lot of value out of it.\"}, {\"type\":\"heading\",\"text\":\"Transaction relay\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:07:55\"}, {\"type\":\"paragraph\",\"text\":\"So, receiving and sending transactions over the network, not the blocks, the transactions, how does this actually work on the technical level?\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:08:10\"}, {\"type\":\"paragraph\",\"text\":\"Well, basically you just scream.\\nThat's kind of what it boils down to.\\nI mean, you hear about a transaction and it's like, \\\"Oh my God, everybody, did you know about this transaction?\\\"\"}, {\"type\":\"paragraph\",\"text\":\"So literally, you might be connected to, I don't know, eight peers outbound or even more inbound.\\nAnd if you hear it from your first peer, you will tell all your other peers about it and this is called flooding.\"}, {\"type\":\"paragraph\",\"text\":\"So everybody just gossips the transaction to as many nodes as they can.\\nThis uses an enormous amount of bandwidth, but it's very robust.\\nIt's very likely for a transaction to make it through and it'll make it through very fast.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:08:42\"}, {\"type\":\"paragraph\",\"text\":\"It's a little bit more nuanced than that because you send transaction IDs first, right?\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:08:51\"}, {\"type\":\"paragraph\",\"text\":\"Right.\\nSo there is some optimizations because what I just described would be sending the whole transaction and that would use a lot of bandwidth.\\nBut, what you could do instead, and what nodes actually do instead, is sending short ID's, which is just a very short hash of the transaction, not even the normal transaction ID, but something even smaller.\"}, {\"type\":\"paragraph\",\"text\":\"And then when a node receives those, they can say, \\\"I don't know about these ones, tell me more,\\\" and then you give the whole transaction.\\nThere's some back and forth and this saves bandwidth, but it's a one-off saving.\\nMaybe it reduces the total bandwidth by a factor of four, but that's it.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:09:26\"}, {\"type\":\"paragraph\",\"text\":\"Right.\\nTo make this very explicit, what happens is I receive a transaction ID or a short version of a transaction ID, which is a hash of a transaction or an even shorter version of that.\\nI check this against all of the transactions I have in my mempool.\\nIf I don't have it yet, then I get back to the node that sent me the ID and I tell them, \\\"Hey, send me this whole transaction. I haven't seen this yet.\\\"\\nThis node sends me the whole transaction.\"}, {\"type\":\"paragraph\",\"text\":\"Now I turn to all my other peers and I send them this ID and then some of these peers will get back to me and tell me, \\\"I don't have this transaction either, send it to me as well, please.\\\"\\nAnd that's how it's forwarded.\"}, {\"type\":\"paragraph\",\"text\":\"Or if they have it already, then I'm not going to send them the whole transaction.\\nI just send them the ID, they checked it, they already have it, so we're good.\"}, {\"type\":\"paragraph\",\"text\":\"Now, what happens is that this last example where I send out an ID and my peer already has that transaction, that actually happens a lot because they are connected to so many other peers as well, and odds are they already got it from someone else.\\nSo it happens a lot that these transaction IDs are basically sent for nothing, they already had the transaction.\"}, {\"type\":\"paragraph\",\"text\":\"So this is in a way wasted bandwidth, I'm sending this transaction ID to them, they're receiving it, but they already had the whole transaction so I'm sending the ID for no good reason.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:10:55\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, and it's good to realize that it's impossible, at least naively impossible, to prevent that waste, but we can get into how much of that waste it is.\\nBut, compared to the most theoretical ideal scenario, which is bad for decentralization reasons, if everybody just downloaded the transactions from a central website that would be the most efficient way to do it in terms of data usage.\\nBut, of course, we don't want to have a central website.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:11:22\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, I think more than half of all bandwidth that a node is sharing these transaction IDs.\\nAnd they ran the numbers at some point and I think about 44% of the total bandwidth use of a node is basically waste, are these transaction IDs that--\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:11:48\"}, {\"type\":\"paragraph\",\"text\":\"--are telling people what they already know.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:11:51\"}, {\"type\":\"paragraph\",\"text\":\"Exactly. This 44%, that's what we're gonna try to bring down with Erlay.\"}, {\"type\":\"heading\",\"text\":\"How Erlay works\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:11:59\"}, {\"type\":\"paragraph\",\"text\":\"Erlay, in order to bring that down, uses something called minisketch, right?\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:12:05\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, it basically does two general things.\\nOne is it still uses this flooding that we just described, and the other is it uses minisketch.\"}, {\"type\":\"paragraph\",\"text\":\"The flooding is reduced, it's only flooding now between publicly reachable nodes.\\nThe general idea is that some nodes can be reached from the internet, their IP is known, and other nodes are probably behind a firewall or they have a privacy setting on and they're not reachable.\"}, {\"type\":\"paragraph\",\"text\":\"But, the idea is that every node that is not reachable will connect to a node that is reachable, or almost everyone unless you do it manually. Because otherwise, how do you connect to the rest of the network?\\nThe idea is that as long as all these reachable nodes have like flood a lot between each other, then at least all the unreachable nodes are just one hop away from all the transaction data.\"}, {\"type\":\"paragraph\",\"text\":\"That's sort of the first step, where you reduce the flooding to a smaller group of people.\\nAnd then the second thing you do is, and this is the cool part, is the minisketch.\"}, {\"type\":\"heading\",\"text\":\"Minisketch\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:13:08\"}, {\"type\":\"paragraph\",\"text\":\"Right, so what's minisketch?\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:13:10\"}, {\"type\":\"paragraph\",\"text\":\"Okay, so the goal of minisketch is to do set reconciliation.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:13:14\"}, {\"type\":\"paragraph\",\"text\":\"What is set reconciliation?\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:13:17\"}, {\"type\":\"paragraph\",\"text\":\"A set is basically just a bag of stuff.\\nIn this case the contents of your mempool, the list of all your transactions, that's a set.\\nOr, the list of all the short IDs of your transactions is a set or whatever.\"}, {\"type\":\"paragraph\",\"text\":\"I have a mempool, so I have a set, and you have a mempool, so you have a set.\\nThe question is, what is the difference between these sets?\\nWhat are the transactions that I have that you don't have, and that you have that I don't have?\\nThat (difference) is probably just a fraction of the mempool.\"}, {\"type\":\"paragraph\",\"text\":\"That challenge in computer science is just called set reconciliation, trying to find out what the difference is and then trying for both of us to get the same set eventually.\\nSo sending the least amount of data over and back.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:13:58\"}, {\"type\":\"paragraph\",\"text\":\"So one way we could do that is you just send all of the transactions you have in your mempool to me.\\nI compare all of your transactions to all of my transactions.\\nI can easily tell the difference and send you the transactions that you didn't have yet and keep the transactions from yours that I didn't have and now the sets are reconciled.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:14:20\"}, {\"type\":\"paragraph\",\"text\":\"That is one way to do it that is worse than what we just described with flooding.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:14:23\"}, {\"type\":\"paragraph\",\"text\":\"Yes, this is a very resource intensive thing to do so we're using something more clever than this.\\nBut, this is the general principle, (and) we're just using something mathematically more clever.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:14:35\"}, {\"type\":\"paragraph\",\"text\":\"Exactly.\\nSo the mathematical clever thing is this: \\nAnd this is where we're going to get extremely hand-wavy, because I do not actually know or understand the moon math involved.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:14:46\"}, {\"type\":\"paragraph\",\"text\":\"God knows I don't either.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:14:48\"}, {\"type\":\"paragraph\",\"text\":\"No, that's okay though.\"}, {\"type\":\"paragraph\",\"text\":\"The idea is I take my mempool, the set, and I do some math on it and the end result is a little, maybe one kilobyte object or two kilobyte, or whatever.\\nSome small object compared to the rest of the mempool.\\nAnd you do the same type of operation and you end up with a one kilobyte object.\"}, {\"type\":\"paragraph\",\"text\":\"And now I send you my one kilobyte object.\\nThis is called the sketch.\\nSo I'm sending you my sketch and that's just a tiny thing.\"}, {\"type\":\"paragraph\",\"text\":\"You receive the sketch and now the math says that if the difference between our two mempools was actually less than the size of the sketch, then you can actually figure out exactly which transactions are missing on either side. \"}, {\"type\":\"paragraph\",\"text\":\"Only then, so if the difference is bigger, then you get gibberish, you don't know anything.\\nBut if the difference is the same or smaller, you can actually reconstruct which transactions I am missing and which transaction you are missing.\"}, {\"type\":\"paragraph\",\"text\":\"Then the procedure is pretty simple, your node will just give me the transactions that it knows I need and it will ask for the transactions that it needs.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:15:57\"}, {\"type\":\"paragraph\",\"text\":\"So if for some absurd reason, we have completely different mempools, then this won't work very well or at all?\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:16:05\"}, {\"type\":\"paragraph\",\"text\":\"No, and the good thing of course about the mempool is that because you're syncing it all the time, and because there are rules about highest fee things are more important, it's actually fairly predictable what the mempools of other people are going to look like.\\nFor the most part, it's going to be the same.\"}, {\"type\":\"paragraph\",\"text\":\"Then it's just a matter of finding the right parameters to use with this sketch.\\nSo, (finding) how big you want to make the sketches so that most of the time people will actually find the difference, but not so big that it just wastes more bandwidth than the flooding protocol.\\nAnd that's sort of what the paper went into with simulations.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:16:39\"}, {\"type\":\"paragraph\",\"text\":\"So if it's close enough, then I can figure out which transactions are the difference and we can reconcile just these transactions.\"}, {\"type\":\"heading\",\"text\":\"Other applications of minisketch\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:16:48\"}, {\"type\":\"paragraph\",\"text\":\"Without getting into the moon math specifically, I know there's been some other examples where this kind of math has been used.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:16:58\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, so it's interesting, and I only learned this today, maybe wrong on some of the stuff, but it refers to something called fuzzy matchers, I think was the term.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:17:08\"}, {\"type\":\"paragraph\",\"text\":\"I think so.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:17:10\"}, {\"type\":\"paragraph\",\"text\":\"So it refers to an older paper from, I think 2004 or 2008.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:17:13\"}, {\"type\":\"paragraph\",\"text\":\"The trick predates Bitcoin, basically.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:17:16\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, and I'm sure the general principle is even older.\\nBut, the problem they were trying to solve was, for example, biometric identification.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:17:26\"}, {\"type\":\"paragraph\",\"text\":\"Fingerprints.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:17:27\"}, {\"type\":\"paragraph\",\"text\":\"Yes, so if I wanna go to my moonbase and I wanna enter the moonbase, they want my fingerprint.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:17:34\"}, {\"type\":\"paragraph\",\"text\":\"Of course.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:17:34\"}, {\"type\":\"paragraph\",\"text\":\"But I don't want them to have a database.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:17:36\"}, {\"type\":\"paragraph\",\"text\":\"Everyone knows you can't get into your moonbase without a fingerprint.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:17:40\"}, {\"type\":\"paragraph\",\"text\":\"I don't want them to have a database of my fingerprint.\\nI don't want them to have a photo of my fingerprint.\\nBut, they're gonna need that, naively speaking, because when I put my finger on the little sensor, it's gonna take a picture and that picture is always gonna be slightly different than what it was before.\\nSo they cannot just store, say, a hash of the image.\\nThey have to store the image itself and then look at it and say, \\\"Well, this is so and so much difference.\\\"\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:18:06\"}, {\"type\":\"paragraph\",\"text\":\"The reason it's going to be slightly different than before is basically it's a photo and even if you take a photo of the same object, it's going to be slightly tilted or slightly darker or some pixels are going to be different at least.\\nSo it's going to be similar, but not literally exactly a copy.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:18:23\"}, {\"type\":\"paragraph\",\"text\":\"Right, because every single pixel is slightly different and the same really goes with normal passwords.\\nOne typo in your password and it just doesn't work anymore.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:18:31\"}, {\"type\":\"paragraph\",\"text\":\"So it could work, we could take a picture of your fingerprint and then make a new fingerprint and compare the two.\\nHowever, the problem here is that we don't want a database full of fingerprints because people can steal the database and abuse it and rob banks and leave your fingerprints all over there.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:18:50\"}, {\"type\":\"paragraph\",\"text\":\"There's another use case where this is an even bigger problem, which is what if I want to put some Bitcoin on a private key that is generated by my fingerprint?\"}, {\"type\":\"paragraph\",\"text\":\"In this case, there is no database, there is just my fingerprint and I want to construct a private key from that fingerprint.\\nIf I take a picture on the device and then take the image and put the image literally on a cold card and that (image) is its entropy, it'll give you a set of private keys.\\nThen if I repeat that, it'll give me a different set of private keys, so that'd be quite bad.\"}, {\"type\":\"paragraph\",\"text\":\"It would be nice, however, if you could do this in a way, and that's kind of what that original paper described,.\\nso (that) it would take certain properties of the fingerprint or the iris scan, doesn't really matter what, and then it would create a 'sketch' of your fingerprint.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:19:40\"}, {\"type\":\"paragraph\",\"text\":\"Right, that's where the term 'sketch' comes from.\\nIt's a mathematical sketch basically.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:19:46\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, a mathematical 'sketch' of your fingerprint, which is not the same as a hash but it is some sort of summary of it.\\nBut, if you have that sketch you cannot reconstruct a fingerprint.\\nIt is similar to a hash in that you can't go back.\\nIt's a one-way function but it has a slightly more more useful information than a hash does, and it's very small.\"}, {\"type\":\"paragraph\",\"text\":\"So, what the moonbase does, or what the iPhone would do, is it would store this sketch, and then when you reappear and you put your fingerprint on the sensor, it's now going to make a sketch of this new fingerprint.\\nAnd then, because of what we just talked about, if those sketches are similar enough, you can actually reconstruct the difference.\\nIn other words, in the case of the moonbase, you can say, \\\"Hey, I can reconstruct the difference, therefore I think this difference is small enough.\\\"\\nIt's the real person, it's the real fingerprint.\"}, {\"type\":\"paragraph\",\"text\":\"Or in the case of the private key, you can actually, because you stored a sketch of the original fingerprint, you can now, using the other fingerprint, essentially your second fingerprint, and this original sketch, so you make a sketch of the new one, you can actually reconstruct the exact sort of image that you would have had the first time around and so you do get the same entropy, and so you can use your fingerprint to store your Bitcoin.\"}, {\"type\":\"paragraph\",\"text\":\"Don't do this, but you could using this methodology.\"}, {\"type\":\"paragraph\",\"text\":\"And, this difference can also be used for mempool comparison.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:21:09\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, so this trick for comparing fingerprints is the same mathematical trick that we're now using in the context of Bitcoin for set reconciliation in mempools.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:21:24\"}, {\"type\":\"paragraph\",\"text\":\"Which will make it more efficient to put your node on the moon and we're a full circle.\"}, {\"type\":\"heading\",\"text\":\"How Erlay uses minisketch\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:21:31\"}, {\"type\":\"paragraph\",\"text\":\"Okay, how is this actually used in Bitcoin then?\\nWhat actually happens?\\nWhat's the step-by-step process if we're using set reconciliation?\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:21:43\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, if this stuff were to be merged in Bitcoin Core, the nice thing is it doesn't change any consensus rules, so it's just something people can use or they can not use it, and you connect to peers and if those peers support this way of handling things, then depending on whether they are public nodes or not, you would either do the original flooding or you would use the sketching and you would keep your mempool synced by using these sketches.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:22:09\"}, {\"type\":\"paragraph\",\"text\":\"So, instead of constantly sharing every transaction ID you receive with all your peers, now you're also once in a while just sharing a sketch and based on that sharing the transactions that you don't share yet?\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:22:26\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, and this is so much more efficient that you can have lots and lots of peers with which you are exchanging these sketches, far more than you could if you were using the flooding.\"}, {\"type\":\"paragraph\",\"text\":\"So you use flooding with a subset of your peers or not at all, and you use the sketches otherwise.\"}, {\"type\":\"paragraph\",\"text\":\"And if the sketch somehow fails, there's a little fallback that's [described in the protocol](https://github.com/bitcoin/bips/blob/master/bip-0330.mediawiki#sketch-extension) that says, \\\"Well, if the sketch is too big, you can try something half the [size of the first] sketch again and overlap [that with first sketch].\\\"\\nSo, you can do a second attempt if the difference is just a little bit bigger.\"}, {\"type\":\"paragraph\",\"text\":\"And then if you give up, if it fails again because the difference was too big, great, you just fall back to the original flooding protocol.\"}, {\"type\":\"paragraph\",\"text\":\"So that's kind of what it does.\"}, {\"type\":\"paragraph\",\"text\":\"And there's a [pull request](https://github.com/bitcoin/bitcoin/pull/21515) on it.\\nThere's a [BIP out there.](https://github.com/bitcoin/bips/blob/master/bip-0330.mediawiki)\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:23:06\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, this is it sounds very hypothetical, but this is actually something that's being developed and that could be merged into Bitcoin Core soonish.\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:23:19\"}, {\"type\":\"paragraph\",\"text\":\"I only briefly looked at the pull request and it looks like most of the things are in there but of course I haven't tested it or or thoroughly reviewed it.\\nBut my guess is it'll happen, or maybe not if there's a huge problem of course, but as far as I'm concerned it sounds pretty good.\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:23:39\"}, {\"type\":\"paragraph\",\"text\":\"Yeah, clear so far.\\nAnything else?\"}, {\"type\":\"paragraph\",\"text\":\"Sjors Provoost: 00:23:42\"}, {\"type\":\"paragraph\",\"text\":\"I don't think so.\\nThat's all we got.\\nAlright, so thank you for listening to the Van Wirdum Sjorsnado!\"}, {\"type\":\"paragraph\",\"text\":\"Aaron van Wirdum: 00:24:00\"}, {\"type\":\"paragraph\",\"text\":\"Bye.\"}",
    "body": "## Preamble\n\nAaron van Wirdum: 00:00:07\n\nLive from Utrecht, this is the Van Wirdum Sjorsnado.\n\nSjors Provoost: 00:00:10\n\nHello again.\n\nAaron van Wirdum: 00:00:12\n\nWe've done it again, Sjors.\n\nSjors Provoost: 00:00:14\n\nWe've done it again.\n\nAaron van Wirdum: 00:00:15\n\nWe recorded the whole episode without actually recording it.\n\nSjors Provoost: 00:00:18\n\nYeah.\n\nAaron van Wirdum: 00:00:19\n\nSo we're going to do the whole thing over.\n\nSjors Provoost: 00:00:20\n\nIt's this thing where you press the button, but you don't press it hard enough.\nAnd you have to check if the red light is blinking.\nIt is now.\n\n\n### Sidebar about Podcast 2.0 Sat Streaming\n\nAaron van Wirdum: 00:00:28\n\nGreat. I think you have a bit of news, some exciting news for us.\n\nSjors Provoost: 00:00:33\n\nThat's right. You can now stream your sats to us (Sjors and Aaron).\nYeah, you can. It's very cool.\n\nAaron van Wirdum: 00:00:41\n\nHow does that work?\n\nSjors Provoost: 00:00:49\n\nThe way it works is this standard called Podcasting 2.0.\nSo for those who don't know, a podcast is essentially just an RSS feed with a bunch of information like the title and a nice picture and for every episode a link to some mp3 file that your podcast player downloads.\n\nBut it turns out you can add more stuff to this RSS feed and Adam Curry, the original podcaster, he basically started a project called Podcasting 2.0 which adds a bunch of new fields and one of those new fields is called 'value' and this value field lets you add for example a Lightning node public key to the RSS feed of your podcast.\n\nAnd then if you have a podcast player that understands this, like a normal podcast player will just ignore it, but a player like in the Breez iOS test flight app, I think also like in the Sphinx app, if they understand it, and they have Lightning available, they'll start streaming sats to you as the people are listening.\nAnd you can suggest a rate, but people can choose it themselves.\n\nAaron van Wirdum: 00:01:58\n\nSo people can either listen for free or they can pay us.\n\nSjors Provoost: 00:02:01\n\nThat's right.\n\nAaron van Wirdum: 00:02:02\n\nWell, let's see what they choose.\n\nSjors Provoost: 00:02:04\n\nSo not only that, they can listen for free in a really well-functioning app maintained by Apple, or they can use very experimental software and have to deal with Lightning and then pay us.\n\nWe'll see which people prefer.\n\nAaron van Wirdum: 00:02:21\n\nSounds like we're gonna be stacking sats, Sjors.\n\nSjors Provoost: 00:02:23\n\nYeah, I think the last time I checked the node there was zero sats in it, but it's only been live for a couple hours.\n\n### Sidebar about Taproot activation 'coin flip'\n\nAaron van Wirdum: 00:02:29\n\nThe other thing I wanted to mention is people keep pinging me about the coin flip.\nDid you hear about the coin flip?\n\nSjors Provoost: 00:02:34\n\nI did because you just told me in the previous take.\nBut tell me again.\n\nAaron van Wirdum: 00:02:38\n\nI'm trying to pretend a little bit like this is an original episode.\n\nSjors Provoost: 00:02:42\n\nAll right.\n\nAaron van Wirdum: 00:02:43\n\nI'll try that.\n\nSo the Speedy Trial discussion was winding down to block height or block time, which we discussed in our episode about Speedy Trial that was about Taproot activation.\n\nSjors Provoost: 00:02:57\n\nAnd the difference is basically, at least I find block height a little bit easier to understand, but the existing soft forks so far and BIP9 have all used block time, which is fine.\nIt's just a little bit more difficult to think about, but in terms of code I don't think it matters that much.\n\nSo there's now two pull requests.\n\nAaron van Wirdum: 00:03:17\n\nYeah, and it looks like it's going to be the block time one based on a blockchain based coin flip they did.\n\nSjors Provoost: 00:03:24\n\nThat's amazing, even though they can be gamed.\n\nAaron van Wirdum: 00:03:31\n\nThis was mentioned on the IRC chat as well.\nBut, it would be pretty expensive to game it.\n\nSjors Provoost: 00:03:37\n\nWell, the future is at stake, right?\n\nAaron van Wirdum: 00:03:40\n\nThe future of Bitcoin is at stake.\nIf Speedy Trial happens at all... There's been a couple of NACKs by now, so we'll have to see.\n\nThis is not what our episode is about.\nOur episode Sjors, this episode, episode 34 is about Erlay.\n\nSjors Provoost: 00:03:56\n\nErlay.\n\n## Erlay\n\nAaron van Wirdum: 00:03:58\n\nSo [Erlay](https://arxiv.org/abs/1905.10518) is a project, I think it was started at the University of British Columbia, or at least University of British Columbia researchers Gleb Naumenko, Alexandra Fedorova and Ivan Beschastnikh were working on it, as well as Blockstream's Pieter Wuille and Greg Maxwell.\n\n### The problem that Erlay solves\n\nAaron van Wirdum: 00:04:32\n\nSo, Erlay, the problem it solves, Sjors, is that nodes use bandwidth.\n\nSjors Provoost: 00:04:43\n\nLots of bandwidth.\n\nAaron van Wirdum: 00:04:44\n\nYes, and this is a problem because we want people to be able to run full nodes.\nAnd if full nodes use bandwidth and bandwidth costs money, the more bandwidth means it's more expensive to run a full node, which means fewer people will run full nodes or at least they'll be incentivized not to and it would be good if we could reduce the cost of running a full node.\n\nSo it would be good if we could find ways to make it cheaper to run full nodes which means if we could find ways to reduce bandwidth use.\n\nSjors Provoost: 00:05:21\n\nThat's right and we've previously talked about downloading the blockchain as a source of bandwidth use and we talked about some ways to make that smarter.\nBut, now we're going to talk about the transactions that are not yet in a block, the mempool.\n\nAaron van Wirdum: 00:05:37\n\nI want to finish (describing) the benefits (first).\n\nPart one is it would be good if we could reduce bandwidth or if people choose to keep using the amount of bandwidth they're currently using, if we could further optimize the efficiency there, then we could have nodes connect to more other nodes.\nWhich, would in turn benefit network robustness it would counter certain types of attacks like Eclipse attacks.\n\nSjors Provoost: 00:06:09\n\nYeah, because we talked about Eclipse attacks in earlier episodes and one of the solutions we already mentioned is: Well, just connect to more peers.\nAnd there is a big downside to that, which we'll explain in a bit in terms of bandwidth use.\n\nAaron van Wirdum: 00:06:23\n\nSo, if we could optimize bandwidth use, that means people can either run a full node more cheaply, or they can connect to more nodes, which counter certain types of attacks, or a bit of both. That's what we're trying to do is reduce bandwidth use.\n\nSo you already mentioned this, there's basically two main things that cause bandwidth.\nOne of them is receiving and forwarding blocks themselves and this is what the blockchain consists of.\nAnd, the other thing is receiving and forwarding transactions.\n\nSjors Provoost: 00:06:59\n\nThat's right. Before they are in the block.\n\nAaron van Wirdum: 00:07:02\n\nThis is how transactions find their way over the network, which ultimately is how they find their way to miners so they know which transactions they can include in blocks.\n\nSjors Provoost: 00:07:14\n\nEvery node has a thing called the mempool, which is where they keep track of transactions that aren't in the block yet and they relay those to their peers.\n\nAnd you might say, \"Well, why would you do that?\"\n\nWell, there's some selfish interest in (that) you want to know as soon as somebody's about to send you a transaction, and you want to know as soon as somebody is about to cheat on you on Lightning.\nIt's nice to know that these transactions might start happening before they're in a block.\n\nBut, there's also an altruistic reason: If nobody did this, then transactions would not get to miners, because you'd have to know which nodes are the miners and send it directly to them.\nAnd so, especially because it's altruistic, you want to make it cheap or get a lot of value out of it.\n\n### Transaction relay\n\nAaron van Wirdum: 00:07:55\n\nSo, receiving and sending transactions over the network, not the blocks, the transactions, how does this actually work on the technical level?\n\nSjors Provoost: 00:08:10\n\nWell, basically you just scream.\nThat's kind of what it boils down to.\nI mean, you hear about a transaction and it's like, \"Oh my God, everybody, did you know about this transaction?\"\n\nSo literally, you might be connected to, I don't know, eight peers outbound or even more inbound.\nAnd if you hear it from your first peer, you will tell all your other peers about it and this is called flooding.\n\nSo everybody just gossips the transaction to as many nodes as they can.\nThis uses an enormous amount of bandwidth, but it's very robust.\nIt's very likely for a transaction to make it through and it'll make it through very fast.\n\nAaron van Wirdum: 00:08:42\n\nIt's a little bit more nuanced than that because you send transaction IDs first, right?\n\nSjors Provoost: 00:08:51\n\nRight.\nSo there is some optimizations because what I just described would be sending the whole transaction and that would use a lot of bandwidth.\nBut, what you could do instead, and what nodes actually do instead, is sending short ID's, which is just a very short hash of the transaction, not even the normal transaction ID, but something even smaller.\n\nAnd then when a node receives those, they can say, \"I don't know about these ones, tell me more,\" and then you give the whole transaction.\nThere's some back and forth and this saves bandwidth, but it's a one-off saving.\nMaybe it reduces the total bandwidth by a factor of four, but that's it.\n\nAaron van Wirdum: 00:09:26\n\nRight.\nTo make this very explicit, what happens is I receive a transaction ID or a short version of a transaction ID, which is a hash of a transaction or an even shorter version of that.\nI check this against all of the transactions I have in my mempool.\nIf I don't have it yet, then I get back to the node that sent me the ID and I tell them, \"Hey, send me this whole transaction. I haven't seen this yet.\"\nThis node sends me the whole transaction.\n\nNow I turn to all my other peers and I send them this ID and then some of these peers will get back to me and tell me, \"I don't have this transaction either, send it to me as well, please.\"\nAnd that's how it's forwarded.\n\nOr if they have it already, then I'm not going to send them the whole transaction.\nI just send them the ID, they checked it, they already have it, so we're good.\n\nNow, what happens is that this last example where I send out an ID and my peer already has that transaction, that actually happens a lot because they are connected to so many other peers as well, and odds are they already got it from someone else.\nSo it happens a lot that these transaction IDs are basically sent for nothing, they already had the transaction.\n\nSo this is in a way wasted bandwidth, I'm sending this transaction ID to them, they're receiving it, but they already had the whole transaction so I'm sending the ID for no good reason.\n\nSjors Provoost: 00:10:55\n\nYeah, and it's good to realize that it's impossible, at least naively impossible, to prevent that waste, but we can get into how much of that waste it is.\nBut, compared to the most theoretical ideal scenario, which is bad for decentralization reasons, if everybody just downloaded the transactions from a central website that would be the most efficient way to do it in terms of data usage.\nBut, of course, we don't want to have a central website.\n\nAaron van Wirdum: 00:11:22\n\nYeah, I think more than half of all bandwidth that a node is sharing these transaction IDs.\nAnd they ran the numbers at some point and I think about 44% of the total bandwidth use of a node is basically waste, are these transaction IDs that--\n\nSjors Provoost: 00:11:48\n\n--are telling people what they already know.\n\nAaron van Wirdum: 00:11:51\n\nExactly. This 44%, that's what we're gonna try to bring down with Erlay.\n\n### How Erlay works\n\nAaron van Wirdum: 00:11:59\n\nErlay, in order to bring that down, uses something called minisketch, right?\n\nSjors Provoost: 00:12:05\n\nYeah, it basically does two general things.\nOne is it still uses this flooding that we just described, and the other is it uses minisketch.\n\nThe flooding is reduced, it's only flooding now between publicly reachable nodes.\nThe general idea is that some nodes can be reached from the internet, their IP is known, and other nodes are probably behind a firewall or they have a privacy setting on and they're not reachable.\n\nBut, the idea is that every node that is not reachable will connect to a node that is reachable, or almost everyone unless you do it manually. Because otherwise, how do you connect to the rest of the network?\nThe idea is that as long as all these reachable nodes have like flood a lot between each other, then at least all the unreachable nodes are just one hop away from all the transaction data.\n\nThat's sort of the first step, where you reduce the flooding to a smaller group of people.\nAnd then the second thing you do is, and this is the cool part, is the minisketch.\n\n\n#### Minisketch\n\nAaron van Wirdum: 00:13:08\n\nRight, so what's minisketch?\n\nSjors Provoost: 00:13:10\n\nOkay, so the goal of minisketch is to do set reconciliation.\n\nAaron van Wirdum: 00:13:14\n\nWhat is set reconciliation?\n\nSjors Provoost: 00:13:17\n\nA set is basically just a bag of stuff.\nIn this case the contents of your mempool, the list of all your transactions, that's a set.\nOr, the list of all the short IDs of your transactions is a set or whatever.\n\nI have a mempool, so I have a set, and you have a mempool, so you have a set.\nThe question is, what is the difference between these sets?\nWhat are the transactions that I have that you don't have, and that you have that I don't have?\nThat (difference) is probably just a fraction of the mempool.\n\nThat challenge in computer science is just called set reconciliation, trying to find out what the difference is and then trying for both of us to get the same set eventually.\nSo sending the least amount of data over and back.\n\nAaron van Wirdum: 00:13:58\n\nSo one way we could do that is you just send all of the transactions you have in your mempool to me.\nI compare all of your transactions to all of my transactions.\nI can easily tell the difference and send you the transactions that you didn't have yet and keep the transactions from yours that I didn't have and now the sets are reconciled.\n\nSjors Provoost: 00:14:20\n\nThat is one way to do it that is worse than what we just described with flooding.\n\nAaron van Wirdum: 00:14:23\n\nYes, this is a very resource intensive thing to do so we're using something more clever than this.\nBut, this is the general principle, (and) we're just using something mathematically more clever.\n\nSjors Provoost: 00:14:35\n\nExactly.\nSo the mathematical clever thing is this: \nAnd this is where we're going to get extremely hand-wavy, because I do not actually know or understand the moon math involved.\n\nAaron van Wirdum: 00:14:46\n\nGod knows I don't either.\n\nSjors Provoost: 00:14:48\n\nNo, that's okay though.\n\nThe idea is I take my mempool, the set, and I do some math on it and the end result is a little, maybe one kilobyte object or two kilobyte, or whatever.\nSome small object compared to the rest of the mempool.\nAnd you do the same type of operation and you end up with a one kilobyte object.\n\nAnd now I send you my one kilobyte object.\nThis is called the sketch.\nSo I'm sending you my sketch and that's just a tiny thing.\n\nYou receive the sketch and now the math says that if the difference between our two mempools was actually less than the size of the sketch, then you can actually figure out exactly which transactions are missing on either side. \n\nOnly then, so if the difference is bigger, then you get gibberish, you don't know anything.\nBut if the difference is the same or smaller, you can actually reconstruct which transactions I am missing and which transaction you are missing.\n\nThen the procedure is pretty simple, your node will just give me the transactions that it knows I need and it will ask for the transactions that it needs.\n\nAaron van Wirdum: 00:15:57\n\nSo if for some absurd reason, we have completely different mempools, then this won't work very well or at all?\n\nSjors Provoost: 00:16:05\n\nNo, and the good thing of course about the mempool is that because you're syncing it all the time, and because there are rules about highest fee things are more important, it's actually fairly predictable what the mempools of other people are going to look like.\nFor the most part, it's going to be the same.\n\nThen it's just a matter of finding the right parameters to use with this sketch.\nSo, (finding) how big you want to make the sketches so that most of the time people will actually find the difference, but not so big that it just wastes more bandwidth than the flooding protocol.\nAnd that's sort of what the paper went into with simulations.\n\nAaron van Wirdum: 00:16:39\n\nSo if it's close enough, then I can figure out which transactions are the difference and we can reconcile just these transactions.\n\n##### Other applications of minisketch\n\nAaron van Wirdum: 00:16:48\n\nWithout getting into the moon math specifically, I know there's been some other examples where this kind of math has been used.\n\nSjors Provoost: 00:16:58\n\nYeah, so it's interesting, and I only learned this today, maybe wrong on some of the stuff, but it refers to something called fuzzy matchers, I think was the term.\n\nAaron van Wirdum: 00:17:08\n\nI think so.\n\nSjors Provoost: 00:17:10\n\nSo it refers to an older paper from, I think 2004 or 2008.\n\nAaron van Wirdum: 00:17:13\n\nThe trick predates Bitcoin, basically.\n\nSjors Provoost: 00:17:16\n\nYeah, and I'm sure the general principle is even older.\nBut, the problem they were trying to solve was, for example, biometric identification.\n\nAaron van Wirdum: 00:17:26\n\nFingerprints.\n\nSjors Provoost: 00:17:27\n\nYes, so if I wanna go to my moonbase and I wanna enter the moonbase, they want my fingerprint.\n\nAaron van Wirdum: 00:17:34\n\nOf course.\n\nSjors Provoost: 00:17:34\n\nBut I don't want them to have a database.\n\nAaron van Wirdum: 00:17:36\n\nEveryone knows you can't get into your moonbase without a fingerprint.\n\nSjors Provoost: 00:17:40\n\nI don't want them to have a database of my fingerprint.\nI don't want them to have a photo of my fingerprint.\nBut, they're gonna need that, naively speaking, because when I put my finger on the little sensor, it's gonna take a picture and that picture is always gonna be slightly different than what it was before.\nSo they cannot just store, say, a hash of the image.\nThey have to store the image itself and then look at it and say, \"Well, this is so and so much difference.\"\n\nAaron van Wirdum: 00:18:06\n\nThe reason it's going to be slightly different than before is basically it's a photo and even if you take a photo of the same object, it's going to be slightly tilted or slightly darker or some pixels are going to be different at least.\nSo it's going to be similar, but not literally exactly a copy.\n\nSjors Provoost: 00:18:23\n\nRight, because every single pixel is slightly different and the same really goes with normal passwords.\nOne typo in your password and it just doesn't work anymore.\n\nAaron van Wirdum: 00:18:31\n\nSo it could work, we could take a picture of your fingerprint and then make a new fingerprint and compare the two.\nHowever, the problem here is that we don't want a database full of fingerprints because people can steal the database and abuse it and rob banks and leave your fingerprints all over there.\n\nSjors Provoost: 00:18:50\n\nThere's another use case where this is an even bigger problem, which is what if I want to put some Bitcoin on a private key that is generated by my fingerprint?\n\nIn this case, there is no database, there is just my fingerprint and I want to construct a private key from that fingerprint.\nIf I take a picture on the device and then take the image and put the image literally on a cold card and that (image) is its entropy, it'll give you a set of private keys.\nThen if I repeat that, it'll give me a different set of private keys, so that'd be quite bad.\n\nIt would be nice, however, if you could do this in a way, and that's kind of what that original paper described,.\nso (that) it would take certain properties of the fingerprint or the iris scan, doesn't really matter what, and then it would create a 'sketch' of your fingerprint.\n\nAaron van Wirdum: 00:19:40\n\nRight, that's where the term 'sketch' comes from.\nIt's a mathematical sketch basically.\n\nSjors Provoost: 00:19:46\n\nYeah, a mathematical 'sketch' of your fingerprint, which is not the same as a hash but it is some sort of summary of it.\nBut, if you have that sketch you cannot reconstruct a fingerprint.\nIt is similar to a hash in that you can't go back.\nIt's a one-way function but it has a slightly more more useful information than a hash does, and it's very small.\n\nSo, what the moonbase does, or what the iPhone would do, is it would store this sketch, and then when you reappear and you put your fingerprint on the sensor, it's now going to make a sketch of this new fingerprint.\nAnd then, because of what we just talked about, if those sketches are similar enough, you can actually reconstruct the difference.\nIn other words, in the case of the moonbase, you can say, \"Hey, I can reconstruct the difference, therefore I think this difference is small enough.\"\nIt's the real person, it's the real fingerprint.\n\nOr in the case of the private key, you can actually, because you stored a sketch of the original fingerprint, you can now, using the other fingerprint, essentially your second fingerprint, and this original sketch, so you make a sketch of the new one, you can actually reconstruct the exact sort of image that you would have had the first time around and so you do get the same entropy, and so you can use your fingerprint to store your Bitcoin.\n\nDon't do this, but you could using this methodology.\n\nAnd, this difference can also be used for mempool comparison.\n\nAaron van Wirdum: 00:21:09\n\nYeah, so this trick for comparing fingerprints is the same mathematical trick that we're now using in the context of Bitcoin for set reconciliation in mempools.\n\nSjors Provoost: 00:21:24\n\nWhich will make it more efficient to put your node on the moon and we're a full circle.\n\n#### How Erlay uses minisketch\n\nAaron van Wirdum: 00:21:31\n\nOkay, how is this actually used in Bitcoin then?\nWhat actually happens?\nWhat's the step-by-step process if we're using set reconciliation?\n\nSjors Provoost: 00:21:43\n\nYeah, if this stuff were to be merged in Bitcoin Core, the nice thing is it doesn't change any consensus rules, so it's just something people can use or they can not use it, and you connect to peers and if those peers support this way of handling things, then depending on whether they are public nodes or not, you would either do the original flooding or you would use the sketching and you would keep your mempool synced by using these sketches.\n\nAaron van Wirdum: 00:22:09\n\nSo, instead of constantly sharing every transaction ID you receive with all your peers, now you're also once in a while just sharing a sketch and based on that sharing the transactions that you don't share yet?\n\nSjors Provoost: 00:22:26\n\nYeah, and this is so much more efficient that you can have lots and lots of peers with which you are exchanging these sketches, far more than you could if you were using the flooding.\n\nSo you use flooding with a subset of your peers or not at all, and you use the sketches otherwise.\n\nAnd if the sketch somehow fails, there's a little fallback that's [described in the protocol](https://github.com/bitcoin/bips/blob/master/bip-0330.mediawiki#sketch-extension) that says, \"Well, if the sketch is too big, you can try something half the [size of the first] sketch again and overlap [that with first sketch].\"\nSo, you can do a second attempt if the difference is just a little bit bigger.\n\nAnd then if you give up, if it fails again because the difference was too big, great, you just fall back to the original flooding protocol.\n\nSo that's kind of what it does.\n\nAnd there's a [pull request](https://github.com/bitcoin/bitcoin/pull/21515) on it.\nThere's a [BIP out there.](https://github.com/bitcoin/bips/blob/master/bip-0330.mediawiki)\n\nAaron van Wirdum: 00:23:06\n\nYeah, this is it sounds very hypothetical, but this is actually something that's being developed and that could be merged into Bitcoin Core soonish.\n\nSjors Provoost: 00:23:19\n\nI only briefly looked at the pull request and it looks like most of the things are in there but of course I haven't tested it or or thoroughly reviewed it.\nBut my guess is it'll happen, or maybe not if there's a huge problem of course, but as far as I'm concerned it sounds pretty good.\n\nAaron van Wirdum: 00:23:39\n\nYeah, clear so far.\nAnything else?\n\nSjors Provoost: 00:23:42\n\nI don't think so.\nThat's all we got.\nAlright, so thank you for listening to the Van Wirdum Sjorsnado!\n\nAaron van Wirdum: 00:24:00\n\nBye.\n\n",
    "body_type": "markdown",
    "created_at": "2021-04-08T00:00:00.000Z",
    "domain": "https://btctranscripts.com/",
    "url": "https://btctranscripts.com/bitcoin-explained/scaling-bitcoin-with-the-erlay-protocol",
    "categories": [
        "podcast"
    ],
    "tags": [
        "erlay",
        "minisketch"
    ],
    "media": "https://www.youtube.com/watch?v=Gq6vRnJnbBM",
    "authors": [
        "Sjors Provoost",
        "Aaron van Wirdum"
    ],
    "indexed_at": "2024-03-21T16:33:36.157Z",
    "transcript_by": "davidgumberg via review.btctranscripts.com",
    "summary": "In the latest episode of \"Van Wirdum Sjorsnado,\" hosts Aaron van Wirdum and Sjors Provoost delve into the intricacies of Bitcoin's technological progress with a focus on the Erlay protocol, an innovative approach aimed at enhancing the efficiency and resilience of the Bitcoin network. Their discussion begins with an unfortunate mishap\u2014a lost recording\u2014yet quickly transitions into an informative session about the potential of sat streaming through Podcast 2.0 to empower content creators financially. This sets the stage for a broader conversation on Bitcoin's development, particularly around the community-driven decision-making process, exemplified by the debate on Taproot activation methods and the use of a blockchain-based coin flip to reach consensus.\n\nCentral to their dialogue is the exploration of the Erlay protocol, conceptualized by researchers at the University of British Columbia and contributors from Blockstream. The protocol emerges as a pivotal solution to the challenge of high bandwidth consumption associated with running full Bitcoin nodes. By redefining how transaction information is relayed across the network, Erlay aims to significantly lower bandwidth requirements, thereby making it more feasible for individuals to operate full nodes. This advancement not only promises to reduce operational costs but also fortifies the network against specific types of attacks, such as Eclipse attacks, enhancing the overall robustness of the Bitcoin ecosystem.\n\nThe duo further discusses the technical nuances of Erlay, emphasizing its innovative approach to transaction relay. Traditionally, the method involves a flood-like broadcasting of transaction IDs to peers, leading to substantial bandwidth usage. Erlay introduces a more bandwidth-efficient mechanism that shares short versions of transaction IDs initially and transmits full transaction details upon request. This exchange mechanism seeks to balance bandwidth efficiency with the need for rapid dissemination of transaction information crucial for maintaining the network's integrity and security.\n\nProvoost and van Wirdum also highlight a significant inefficiency in the current system\u2014the redundant sharing of transaction IDs among nodes, which results in considerable bandwidth wastage. Erlay addresses this issue through two primary strategies: limiting the broadcasting of transactions to publicly reachable nodes and utilizing a set reconciliation technique known as minisketch. This technique enables the efficient identification of missing transactions between nodes with minimal data exchange, showcasing Erlay's potential to enhance scalability and efficiency without compromising Bitcoin's decentralized nature.\n\nMoreover, the conversation illuminates the broader applicability of the mathematical principles behind minisketch, drawing parallels with biometric identification systems. This analogy underscores the versatility of such techniques in offering privacy-preserving yet effective solutions across various technological realms, including blockchain.\n\nIn sum, the engaging dialogue between Sjors Provoost and Aaron van Wirdum provides invaluable insights into the challenges and innovative solutions shaping the future of Bitcoin's network efficiency. Through their detailed examination of the Erlay protocol, they underscore the community's dedication to improving scalability and accessibility, marking another step forward in the cryptocurrency's ongoing evolution."
}